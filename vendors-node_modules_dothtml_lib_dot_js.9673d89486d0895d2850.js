"use strict";
(self["webpackChunkwedding_website"] = self["webpackChunkwedding_website"] || []).push([["vendors-node_modules_dothtml_lib_dot_js"],{

/***/ "./node_modules/dothtml/lib/dot.js":
/*!*****************************************!*\
  !*** ./node_modules/dothtml/lib/dot.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ATTRIBUTE_MODE = exports.SELECTOR_MODE = void 0;
const event_bus_1 = __importDefault(__webpack_require__(/*! ./event-bus */ "./node_modules/dothtml/lib/event-bus.js"));
const style_builder_1 = __importStar(__webpack_require__(/*! ./styling/style-builder */ "./node_modules/dothtml/lib/styling/style-builder.js"));
const err_1 = __importDefault(__webpack_require__(/*! ./err */ "./node_modules/dothtml/lib/err.js"));
const dot_util_1 = __webpack_require__(/*! ./dot-util */ "./node_modules/dothtml/lib/dot-util.js");
const component_1 = __importDefault(__webpack_require__(/*! ./component */ "./node_modules/dothtml/lib/component.js"));
const arg_callback_obj_1 = __webpack_require__(/*! ./arg-callback-obj */ "./node_modules/dothtml/lib/arg-callback-obj.js");
const observable_array_1 = __importDefault(__webpack_require__(/*! ./observable-array */ "./node_modules/dothtml/lib/observable-array.js"));
const dot = (function (targetSelector) {
    //console.log(targetSelector);
    var targets = targetSelector ? (typeof targetSelector == "string" ? document.querySelectorAll(targetSelector)
        : (targetSelector instanceof Element || targetSelector instanceof Node ? [targetSelector]
            : ((targetSelector instanceof NodeList || (targetSelector instanceof Array) && targetSelector[0] && (targetSelector[0] instanceof Element || targetSelector[0] instanceof Node)) ? targetSelector
                : [])))
        : [];
    //console.log(targets);
    var newDot = new DotDocument();
    if (targets.length > 0) {
        newDot.__document = targets[0];
    }
    dot["__selectionMode"] = exports.SELECTOR_MODE;
    return newDot;
});
const DOCEL = "DOTHTML-DOCUMENT";
const DEFEL = "DOTHTML-DEFER";
var _anonFuncCounter = 0;
function ext(name, method) {
    _p[name] = dot[name] = method;
}
// Deletes one element (and not its children). 
// Used by _p.empty and _p.remove.
function deleteElement(element) {
    var deleted = null;
    var dc = element["__dothtml_component"];
    if (dc) {
        // var d = dc.deleting;
        dc.deleting && dc.deleting();
        dc["__$el"] = null;
        deleted = dc.deleted;
    }
    if (element.parentNode)
        element.parentNode.removeChild(element);
    deleted && deleted.apply(dc);
}
function _conditionalBlock(T, totalCondition, allConditions, contentCallback) {
    var startTextNode = document.createTextNode("");
    var endTextNode = document.createTextNode("");
    //var cb = {f:contentCallback,startNode:startTextNode, endNode:endTextNode,condition:totalCondition};
    var cb = new arg_callback_obj_1.ConditionalArgCallback(startTextNode, endTextNode, contentCallback, totalCondition);
    dot["__currentArgCallback"].push(cb);
    var renderContent = totalCondition();
    T = T._appendOrCreateDocument(startTextNode);
    for (var i = 0; i < allConditions.length; i++)
        allConditions[i]();
    cb.lastValue = renderContent;
    if (renderContent)
        T = T._appendOrCreateDocument(contentCallback);
    T = T._appendOrCreateDocument(endTextNode);
    dot["__currentArgCallback"].pop();
    return T;
}
function attachEvent(el, ev, val, a3) {
    if (el.addEventListener)
        el.addEventListener(ev, val, a3 || false);
    else
        el.attachEvent("on" + ev, val); //compatibility with old browsers.
}
function createElement(tag) {
    ext(tag, function (c) { return this.el(tag, c); });
}
;
function createAttribute(attribute, alias) {
    _p[alias || attribute] = function (value) { return this.attr(attribute, value); };
}
;
// Selection Mode enum.
exports.SELECTOR_MODE = 1;
exports.ATTRIBUTE_MODE = 2;
// TODO: this might need to go in just the right place.
// dotReady(dot, _p, _D);
// Dot document object.
// Formerly _D
var DotDocument = (function (document, classPrefix) {
    // Private vars.
    this.__document = document;
    this.__lastNode = document ? document.lastChild : null;
    this.__if = null;
    this.__pendingCalls = []; //Allows you to set parent attributes from children.
    this.__anonAttrFuncs = {}; //Only to be used by top-level dot object.
    this.__classPrefix = classPrefix || 0;
    this.__classedElements = [];
    this.__selectionMode = exports.SELECTOR_MODE;
});
// Prototype for the dot document object.
var _p = DotDocument.prototype;
var allTags = [
    "a",
    "aside",
    "abbr",
    "address",
    "area",
    "article",
    "audio",
    "b",
    "bdi",
    "bdo",
    "blockQuote",
    "body",
    "br",
    "button",
    "canvas",
    "caption",
    "cite",
    "code",
    "col",
    "colGroup",
    "content",
    "data",
    "dataList",
    "dd",
    "del",
    "details",
    "dfn",
    "dialog",
    "div",
    "dl",
    "dt",
    "em",
    "embed",
    "fieldSet",
    "figCaption",
    "figure",
    "footer",
    "form",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "header",
    "hr",
    "i",
    "iFrame",
    "img",
    "input",
    "ins",
    "kbd",
    "keyGen",
    "label",
    "legend",
    "li",
    "main",
    "map",
    "mark",
    "menu",
    "menuItem",
    "meter",
    "nav",
    "object",
    "ol",
    "optGroup",
    "option",
    "output",
    "p",
    "param",
    "pre",
    "progress",
    "q",
    "rp",
    "rt",
    "ruby",
    "s",
    "samp",
    "section",
    "select",
    "small",
    "source",
    "span",
    "strong",
    "svg",
    "sub",
    "summary",
    "sup",
    "table",
    "tBody",
    "td",
    "textArea",
    "tFoot",
    "th",
    "tHead",
    "time",
    "tr",
    "track",
    "u",
    "ul",
    "var",
    "video",
    "wbr"
];
var allAttributes = [
    "accept",
    "accessKey",
    "action",
    "align",
    "aLink",
    "alt",
    "archive",
    "autoComplete",
    "autoFocus",
    "autoPlay",
    "autoSave",
    "axis",
    "background",
    "bgColor",
    "border",
    "buffered",
    "cellPadding",
    "cellSpacing",
    "challenge",
    "char",
    "charOff",
    "checked",
    // "cite", //*
    //"class",
    "classId",
    "clear",
    "codeBase",
    "codeType",
    "color",
    "cols",
    "colSpan",
    "compact",
    "contentEditable",
    "contextMenu",
    "controls",
    "coords",
    "dateTime",
    "declare",
    "default",
    //"data", //*
    "dir",
    "dirName",
    "disabled",
    "download",
    "draggable",
    "dropZone",
    "encType",
    "face",
    "font",
    "fontFace",
    "fontFaceFormat",
    "fontFaceName",
    "fontFaceSrc",
    "fontFaceUri",
    "fontSpecification",
    "for",
    "foreignObject",
    // "form", //*
    "formAction",
    "frame",
    "frameBorder",
    "headers",
    "height",
    "hidden",
    "high",
    "hRef",
    "hRefLang",
    "hSpace",
    "icon",
    "id",
    "images",
    "isMap",
    "itemProp",
    "keyType",
    "kind",
    // "label", //*
    "lang",
    "list",
    "longDesc",
    "loop",
    "low",
    "manifest",
    "marginHeight",
    "marginWidth",
    "max",
    "maxLength",
    "media",
    "metadata",
    "method",
    "min",
    "missingGlyph",
    "multiple",
    "muted",
    "name",
    "noHRef",
    "noResize",
    "noShade",
    "noValidate",
    "nowrap",
    "open",
    "optimum",
    "pattern",
    "ping",
    "placeholder",
    "poster",
    "preload",
    "prompt",
    "radioGroup",
    "readOnly",
    "rel",
    "required",
    "rev",
    "reversed",
    "rows",
    "rowSpan",
    "rules",
    "sandbox",
    "scope",
    "scrolling",
    "seamless",
    "selected",
    "shape",
    "size",
    "sizes",
    // "span", //*
    "spellCheck",
    "src",
    "srcDoc",
    "srcLang",
    "srcSet",
    "standby",
    "start",
    "step",
    // "summary", //*
    "style",
    "tabIndex",
    "target",
    "title",
    "type",
    "useMap",
    "vAlign",
    "value",
    "valueType",
    "width",
    "wrap"
    //"dataA", //Special explicit 
    //"citeA",
    //"formA",
    //"labelA",
    //"spanA",
    //"summaryA"
];
var specialAttributes = [
    ["quoteCite", "cite"],
    ["objectData", "data"],
    ["whichForm", "form"],
    ["trackLabel", "label"],
    ["colSpan", "span"],
    ["tableSummary", "summary"],
    ["optionLabel", "label"],
    ["acceptCharset", "accept-charset"],
];
var allEventAttr = [
    "onAbort",
    "onBlur",
    "onChange",
    "onInput",
    "onCanPlay",
    "onCantPlayThrough",
    "onClick",
    "onCopy",
    "onContextMenu",
    "onCueChange",
    "onCut",
    "onDblClick",
    "onDrag",
    "onDragEnd",
    "onDragEnter",
    "onDragLeave",
    "onDragOver",
    "onDragStart",
    "onDrop",
    "onDurationChange",
    "onEmptied",
    "onEnded",
    "onError",
    "onFocus",
    "onHashChange",
    "onInvalid",
    "onKeyDown",
    "onKeyPress",
    "onKeyUp",
    "onLoad",
    "onLoadedData",
    "onLoadedMetadata",
    "onLoadStart",
    "onMouseDown",
    "onMouseEnter",
    "onMouseLeave",
    "onMouseMove",
    "onMouseOut",
    "onMouseOver",
    "onMouseUp",
    "onPointerCancel",
    "onPointerDown",
    "onPointerEnter",
    "onPointerLeave",
    "onPointerMove",
    "onPointerOut",
    "onPointerOver",
    "onPointerUp",
    "onTouchStart",
    "onTouchEnd",
    "onTouchCancel",
    "onTouchMove",
    "onMouseWheel",
    "onOffline",
    "onOnline",
    "onPageHide",
    "onPagePaste",
    "onPageShow",
    "onPause",
    "onPlay",
    "onPlaying",
    "onPopState",
    "onProgress",
    "onRateChange",
    "onReset",
    "onResize",
    "onScroll",
    "onSearch",
    "onSeeked",
    "onSeeking",
    "onSelect",
    "onStalled",
    "onStorage",
    "onSubmit",
    "onSuspend",
    "onTimeUpdate",
    "onToggle",
    "onUnload",
    "onVolumeChange",
    "onWaiting",
    "onWheel",
];
var i;
for (i in allTags)
    createElement(allTags[i]);
for (i in allAttributes)
    createAttribute(allAttributes[i]);
for (i in specialAttributes) {
    createAttribute(specialAttributes[i][1], specialAttributes[i][0]);
}
for (i in allEventAttr)
    createAttribute(allEventAttr[i]);
ext("as", function (dotElement) {
    return this;
});
ext("_getNewDocument", function () {
    return document.createElement(DOCEL);
});
ext("_getAnInstance", function () {
    if (this.__document || this.__pendingCalls.length > 0)
        return this;
    else {
        var d = new DotDocument(null, this.__classPrefix);
        d.__if = this.__if;
        return d;
    }
    ;
});
ext("_getLastChildOrNull", function () {
    if (this.__document && this.__document.lastChild)
        return this.__document.lastChild;
    return null;
});
//I'm not sure if this is supported anymore.
ext("getLast", function () {
    return this._getLastChildOrNull();
});
ext("getCurrent", function () {
    let last;
    switch (dot["__selectionMode"]) {
        case exports.SELECTOR_MODE: {
            last = this.__document;
            break;
        }
        case exports.ATTRIBUTE_MODE: {
            last = this.getLast() || this.__document;
            break;
        }
    }
    return last;
});
_p.toString = function () {
    if (this.__document)
        return this.__document.innerHTML;
    else
        return "";
};
_p.ref = function (name) {
    let l = this.getLast();
    let gl = dot_util_1.GlobalComponentStack.length;
    if (l && gl > 0) {
        let c = dot_util_1.GlobalComponentStack[gl - 1];
        c.$refs[name] = l;
    }
    return this;
};
//before is passed in so that attributes can be associated with before's sibling, instead of inheritingParent, the default.
ext("_evalContent", function (content, pendingCalls) {
    if (content == null || content == undefined)
        return null;
    if (typeof content === "string" || typeof content === "number" || typeof content === "boolean") { //Raw data
        let nDot = new DotDocument(this._getNewDocument(), this.__classPrefix);
        nDot.__document.innerHTML = content;
        return nDot.__document.childNodes;
    }
    else if (content instanceof Node)
        return content;
    else if (Object.prototype.toString.call(content) === '[object Array]') { //Array
        let nDot = new DotDocument(this._getNewDocument(), this.__classPrefix);
        for (let i = 0; i < content.length; i++) {
            nDot._appendOrCreateDocument(content[i]);
        }
        if (nDot.__document)
            return nDot.__document.childNodes;
    }
    else if ((0, dot_util_1.isF)(content)) //Function to evaluate
     {
        return this._evalContent(content(), pendingCalls);
    }
    else if (content instanceof component_1.default) {
        return this._evalContent(component_1.default.build(content));
    }
    else if (content instanceof DotDocument) { //DOT
        for (let i = 0; i < content["__pendingCalls"].length; i++) {
            pendingCalls.push(content["__pendingCalls"][i]);
        }
        let cp = this.__classPrefix;
        for (let i in content["__classedElements"]) {
            let el = content["__classedElements"][i];
            if (!cp) {
                this["__classedElements"].push(el);
            }
            else {
                el.className = "dot-" + (0, dot_util_1.str)(cp, 16) + "-" + el.className;
            }
        }
        if (content["__document"])
            return content["__document"].childNodes; //Return all the nodes in here.
    }
    return null;
});
ext("_appendOrCreateDocument", function (content, parentEl, beforeNode) {
    var T = this;
    // Validation
    ;
    ;
    ;
    if (parentEl && beforeNode && isNaN(beforeNode) && beforeNode.parentNode != parentEl)
        throw "beforeNode is not in parentEl.";
    // Find the parent, or create one.
    //Note: the stuff with setting parentEl to beforeNode's parent is due to a very strange bug where this.__document gets set to some phantom document when the wait function is used inside a div like so: DOT.div(DOT.wait(100, "hello!")); Try it. )
    parentEl = parentEl || (beforeNode && isNaN(beforeNode) ? beforeNode.parentNode : null) || T.__document || T._getNewDocument();
    if (!isNaN(beforeNode)) {
        beforeNode = parentEl.childNodes[beforeNode];
        //;;;		if(!beforeNode) throw "beforeNode not found."; // TODO: reenable this and investigate why it breaks.
    }
    // nd is a dot wrapper for parentEl (allows us to do dot ops on it).
    var nd = T.__document === parentEl ? T : new DotDocument(parentEl, T.__classPrefix);
    nd.__if = T.__if;
    var pendingCalls = []; //This will populate with pending calls.
    // Evaluate the content. This does not add it to the DOM pet.
    var eContent;
    var cf = (0, dot_util_1.isF)(content);
    // If it's a function, we need to consider 
    //if(cf) dot.__currentArgCallback.push({f:content,e:parentEl})
    if (cf)
        dot["__currentArgCallback"].push(new arg_callback_obj_1.ContentArgCallback(parentEl, content));
    try {
        eContent = nd._evalContent(content, /*parentEl, beforeNode,*/ pendingCalls);
    }
    finally {
        if (cf)
            dot["__currentArgCallback"].pop();
    }
    // Pending calls are calls included in the dot element which didn't get consumed and must be propagated up.
    // This usually includes attributes and waits.
    for (var i = 0; i < pendingCalls.length; i++) {
        var call = pendingCalls[i];
        //Three possibilities.
        //1. Use the pending call against the last sibling element, if one exists.
        //2. Otherwise, use it on the current parent, if it's ready.
        //3. Otherwise, save it as a pending call right here. // Don't think this ever happens.
        var pendingCallTarget = (beforeNode ? (beforeNode.previousSibling || parentEl /*Since lastChild will be a timeout*/) : null /*1*/) || parentEl.lastChild /*2*/ || parentEl;
        if (pendingCallTarget && pendingCallTarget.tagName != "DOCUMENT") {
            if (call.type == "attr") {
                if (!(0, dot_util_1.isF)(call.params[0])) {
                    pendingCallTarget.setAttribute(call.name, call.params[0]);
                }
                else {
                    // TODO: how do we know it's a valid event?
                    let newName = call.name;
                    attachEvent(pendingCallTarget, newName, call.params[0], call.arg3);
                }
            }
            else if (call.type == "wait") {
                call.callback();
            }
        }
        else {
            nd.__pendingCalls.push(call); /*3*/
        }
    }
    // Append content to the current document.
    if (eContent !== null && eContent !== undefined) {
        if (eContent instanceof NodeList) {
            //for(var i = 0; i < eContent.length; i++){
            while (eContent.length > 0) {
                if (beforeNode)
                    parentEl.insertBefore(eContent[0], beforeNode);
                else
                    parentEl.appendChild(eContent[0]);
            }
        }
        else {
            if (beforeNode)
                parentEl.insertBefore(eContent, beforeNode);
            else
                parentEl.appendChild(eContent);
        }
    }
    return nd;
    //return this;
});
ext("el", function (tag, content) {
    var T = this;
    var ne = document.createElement(tag);
    var nDoc = T.__document || T._getNewDocument();
    nDoc.appendChild(ne);
    if (content)
        T._appendOrCreateDocument(content, ne);
    var ret = T.__document === nDoc ? T : new DotDocument(nDoc, T.__classPrefix);
    if (content && content instanceof DotDocument)
        for (var i in content["__classedElements"])
            ret.__classedElements.push(content["__classedElements"][i]);
    dot["__selectionMode"] = exports.ATTRIBUTE_MODE;
    return ret;
});
ext("h", function (content) {
    var T = this;
    var hDoc = T._getNewDocument();
    var hDot = new DotDocument(hDoc, T.__classPrefix);
    //if(typeof content === "string" || typeof content === "number" || typeof content === "boolean") hDoc.innerHTML = content; //Raw data
    hDot._appendOrCreateDocument(content);
    var nDoc = T.__document || T._getNewDocument();
    while (hDoc.childNodes.length > 0) {
        nDoc.appendChild(hDoc.childNodes[0]);
    }
    return T.__document === nDoc ? T : new DotDocument(nDoc, T.__classPrefix);
});
ext("t", function (content) {
    var textNode = document.createTextNode(content);
    var nDoc = this.__document || this._getNewDocument();
    nDoc.appendChild(textNode);
    return new DotDocument(nDoc, this.__classPrefix);
});
ext("attr", function (attr, value, arg3) {
    var T = this;
    if ((0, dot_util_1.isF)(value)) { // events.
        if (attr.indexOf("on") == 0 && allEventAttr.indexOf(attr) != -1) {
            attr = attr.substring(2).toLowerCase();
        }
        else {
            // Unrecognized event.
            dot["__anonAttrFuncs"][_anonFuncCounter] = (value);
            value = "dot.__anonAttrFuncs[" + (_anonFuncCounter++) + "](arguments[0]);";
            // attr = attr.substring(2);
        }
    }
    if (T.__document) {
        var cn = T.__document.childNodes;
        var last = cn[cn.length - 1];
        if (last && last.setAttribute) {
            if (!(0, dot_util_1.isF)(value)) {
                // Objects (except for the css builder :/)
                if (typeof value == "object" && !(value instanceof style_builder_1._Builder)) {
                    var originalValue = value;
                    var valueSetter = function () {
                        var str = "";
                        (0, dot_util_1.eachK)(originalValue, function (k, v) {
                            v = (0, dot_util_1.isF)(v) ? v() : v;
                            if (!v)
                                return;
                            str += " " + k;
                        });
                        return str.substring(1);
                    };
                    //dot.__currentArgCallback.push({f:valueSetter,e:parentEl,a:attr})
                    dot["__currentArgCallback"].push(new arg_callback_obj_1.AttrArgCallback(last, attr, valueSetter));
                    value = valueSetter();
                    dot["__currentArgCallback"].pop();
                }
                var eValue = last.getAttribute(attr); //Appends the new value to any existing value.
                if (!eValue)
                    eValue = "";
                else
                    eValue += " ";
                last.setAttribute(attr, eValue + (value === undefined ? attr : value)); //||attr is for self-explaining attributes
            }
            else {
                attachEvent(last, attr, value, arg3);
            }
        }
    }
    else {
        // TODO: should probably remove pending calls. This has turned out to be an anti-pattern.
        var pD = T._getAnInstance();
        //if(!pD.__pendingCalls.length > 0) pD.__pendingCalls = [];
        pD.__pendingCalls.push({ type: "attr", name: attr, params: [value], arg3: arg3 });
        return pD;
    }
    return T;
});
ext("_appendSetElement", function (targetId, appendMode) {
    var T = this;
    if (!targetId) {
        (0, err_1.default)("A", targetId);
        return T;
    }
    var destination = document.getElementById(targetId);
    if (!destination) {
        (0, err_1.default)("F", targetId);
        return T;
    }
    if (T.__document) {
        if (!appendMode)
            destination.innerHTML = "";
        while (T.__document.childNodes.length > 0)
            destination.appendChild(T.__document.childNodes[0]);
    }
    return T;
});
ext("iterate", function (iterations, callback) {
    var target = this;
    // var copycontent = null;
    // Not sure what this was used for before the TS port.
    // var content = callback;
    // if(content instanceof DotDocument) {
    // 	copycontent = content.__document.cloneNode(true);
    // }
    for (var i = 0; i < iterations; i++) {
        let content = null;
        if ((0, dot_util_1.isF)(callback))
            content = callback(i);
        // if(copycontent) content.__document = copycontent.cloneNode(true);
        target = target._appendOrCreateDocument(content);
    }
    return target;
});
ext("each", function (array, callback, forceNoDeferred) {
    var target = this;
    if ((0, dot_util_1.isF)(array)) {
        if (!forceNoDeferred) {
            return target.defer(function (v) {
                v.each(array, callback, true);
            });
        }
        // console.log(this.__document);
        var func = array;
        //target = target._appendOrCreateDocument();
        // dot.__currentArgCallback.push({f:callback,d:target}); 
        dot["__currentArgCallback"].push(new arg_callback_obj_1.ArrayArgCallback(target, callback));
        try {
            array = func();
        }
        finally {
            dot["__currentArgCallback"].pop();
        }
    }
    if (array instanceof Array || array instanceof observable_array_1.default) {
        for (var i = 0; i < array.length; i++) {
            target = target._appendOrCreateDocument(callback(array[i], i));
        }
    }
    else {
        var keys = Object.keys(array);
        for (var i = 0; i < keys.length; i++) {
            var k = keys[i];
            target = target._appendOrCreateDocument(callback(array[k], k));
        }
    }
    return target;
});
//SVG
//_p.svg = function(){ERR("S")};
//Data is a special attribute.
_p.customData = function (suffix, value) {
    return this.attr("data-" + suffix, value);
};
_p.class = function (value) {
    var cp = this.__classPrefix;
    // This handles legitimate class prefixes. If we are dealing with a compted class list, each class list name is prefixed.
    if (cp) {
        var prefix = "dot-" + (0, dot_util_1.str)(cp, 16) + "-";
        if (typeof value == "string")
            value = prefix + value;
        else if (typeof value == "object") {
            var v2 = {};
            (0, dot_util_1.eachK)(value, function (k, v) {
                v2[prefix + k] = v;
            });
            value = v2;
        }
    }
    else {
        var el = this.getLast();
        el && this.__classedElements.push(el);
    }
    return this.attr("class", value);
};
_p.play = function () {
    let last = this.getCurrent();
    last.play && last.play();
    return this;
};
_p.pause = function (resetTime) {
    let last = this.getCurrent();
    last.pause && last.pause();
    if (resetTime)
        last.currentTime = 0;
    return this;
};
_p.stop = function () {
    return this.pause(true);
};
/**
 * Sets the value of an input or texterea.
 * @param {string} value - The value to be set.
 */
_p.setVal = function (value) {
    let last = this.getCurrent();
    if (!last)
        return this;
    // console.log("CHECKVALUE", value);
    //if ( typeof value === "number" ) val += "";
    if (Array.isArray && Array.isArray(value) || !Array.isArray && value.join) {
        value = value.join("");
    }
    else if (value == null) {
        value = "";
    }
    if (last.type == "checkbox") {
        last.checked = value ? true : false;
    }
    else if (last.type == "radio") {
        last.checked = value ? true : false;
    }
    else if (last.tagName == "OPTION") {
        last.selected = value ? true : false;
    }
    else {
        // console.log("UPDATING VALUE!!", value, last, last.value);
        last.value = value;
        // console.log("UPDATED!!", value, last, last.value);
    }
    return this;
};
_p.getVal = function () {
    var element = this.__lastNode || this.__document;
    if (!element || element.nodeType !== 1)
        return undefined;
    if (element["type"] == "checkbox") {
        return element["checked"] ? true : false;
    }
    else if (element["type"] == "radio") {
        return element["checked"] ? true : false;
    }
    else if (element.tagName == "OPTION") {
        return element["selected"] ? true : false;
    }
    else {
        return element["value"];
    }
};
ext("when", function (condition, contentCallback, ar) {
    var T = this._getAnInstance();
    if ((0, dot_util_1.isF)(condition)) {
        if (!ar)
            ar = T.__conditionalArray = [condition];
        var l = ar.length - 1;
        var totalCondition = function () {
            for (var i = 0; i < l; i++) {
                if (!!ar[i]()) {
                    return false;
                }
            }
            return !!condition();
        };
        T = _conditionalBlock(T, totalCondition, ar, contentCallback);
        // ar.push(condition);
    }
    else {
        // Old:
        if (!!condition) {
            T = T._appendOrCreateDocument((0, dot_util_1.isF)(contentCallback) ? contentCallback() : contentCallback);
            T.__if = true;
        }
        else {
            T.__if = false;
        }
    }
    return T;
});
ext("otherwiseWhen", function (condition, callback) {
    if ((0, dot_util_1.isF)(condition)) {
        var ar = this.__conditionalArray;
        if (!ar)
            (0, err_1.default)("MC");
        //var l = ar.length - 1;
        // var newCondition = function(){
        // 	for(var i = 0; i <= l; i++){
        // 		if(ar[i]()) return false;
        // 	}
        // 	return !!condition();
        // }
        ar.push(condition);
        return this.when(condition, callback, ar);
    }
    else {
        if (!this.__if) {
            return this.when(condition, callback);
        }
    }
    return this;
});
ext("otherwise", function (callback) {
    var ar = this.__conditionalArray;
    if (ar) {
        //var l = ar.length - 1;
        var newCondition = function () {
            return true;
        };
        ar.push(newCondition);
        return this.when(newCondition, callback, ar);
    }
    else if (!this.__if) {
        this.__if = null;
        return this._getAnInstance()._appendOrCreateDocument(callback);
    }
    return this;
});
ext("script", function (callback) {
    var last = this.getLast();
    (0, dot_util_1.sT)(function () { callback(last); }, 0);
    return this;
});
ext("wait", function (timeout, callback) {
    var timeoutDot = this.el(DEFEL);
    var timeoutNode = timeoutDot.__document.lastChild;
    (0, dot_util_1.sT)(() => {
        timeoutDot._appendOrCreateDocument(callback, null, timeoutNode);
        timeoutNode.parentElement.removeChild(timeoutNode);
    }, timeout);
    return timeoutDot;
    // Ideally something like this:
    //return this.defer(function(d){d.h(callback)}, timeout);
});
ext("defer", function (callback) {
    if (!(0, dot_util_1.isF)(callback))
        (0, err_1.default)("XF", "defer");
    var deferDot = this.el(DEFEL);
    var deferNode = deferDot.__document.lastChild;
    (0, dot_util_1.sT)(() => {
        callback(dot(deferNode.parentElement));
        deferNode.parentElement.removeChild(deferNode);
    }, 0);
    return deferDot;
});
ext("empty", function () {
    if (this.__document) {
        // Build a queue of items to remove.
        var queue = [this.__document];
        var firstQ = true;
        var stack = [];
        while (queue.length > 0) {
            var current = queue.shift();
            if (current.childNodes.length > 0) {
                for (var i = 0; i < current.childNodes.length; i++) {
                    queue.push(current.childNodes[i]);
                }
            }
            !firstQ && stack.push(current);
            firstQ = false;
        }
        while (stack.length > 0) {
            deleteElement(stack.pop());
        }
    }
    // Drop all the other nodes (like text)
    // Text seems to get deleted even without this code :).
    //while (this.__document.firstChild) {
    //	this.__document.removeChild(this.__document.firstChild);
    //}
    return this;
});
ext("remove", function () {
    this.empty();
    deleteElement(this.__document);
});
ext("scopeClass", function (prefix, content) {
    if (prefix == null) {
        prefix = dot_util_1.ClassPrefix.next;
    }
    var T = this;
    //T.__classPrefix = prefix || classPrefix.next;
    //doc.__oldClassPrefix.push(prefix);
    T.__classPrefix = prefix;
    var ret = T.h(content);
    T.__classPrefix = 0;
    //doc.__oldClassPrefix.pop();
    //T.__classPrefix = oldCp;
    return ret;
});
_p.bindTo = function (prop) {
    let lastProp = dot["__lastProp"];
    let lastIndex = dot["__lastIndex"];
    let lastComponent = dot["__lastComponent"];
    let last = this.getLast();
    //var noListener = true;
    let _value = lastComponent.props[lastProp];
    if (lastIndex != null && lastIndex != undefined)
        _value = _value[lastIndex];
    let ret = this.setVal(_value);
    // Binding from the input to the prop.
    attachEvent(last, "change", function (e) { lastComponent.props[lastProp] = dot(last).as(dot.input).getVal(); });
    lastComponent["__propContainer"].bindings[lastProp].push({
        element: last
    });
    //var noListener = false;
    return ret;
};
// ext("resetScopeClass", function(){
// 	ClassPrefix.reset();
// });
dot.resetScopeClass = function () {
    dot_util_1.ClassPrefix.reset();
    return this;
};
// _p.bindTo = function(binding){
// 	var last = this.getLast();
// 	//var noListener = true;
// 	var ret = this.setVal(binding.value);
// 	attachEvent(last, "change", function(e){binding.value = this.getVal();})
// 	binding.subscribe(last);
// 	//var noListener = false;
// 	return ret;
// }
// export DotDocument;
dot.css = style_builder_1.default;
dot.bus = event_bus_1.default;
// dot.component = addComponent;
// TODO: might remove this in v4+
// dot.removeComponent = removeComponent;
//Fill in all the other fields.
//if(Object.create) dot.prototype = Object.create(_p);
// dot.prototype.constructor = dot;
dot["__currentArgCallback"] = [];
dot["__document"] = null;
dot["__if"] = null;
dot["__pendingCalls"] = [];
dot["__anonAttrFuncs"] = {};
// TODO: these may already exist?
//dot.data = DotDocument.prototype.data;
//dot.dataA = DotDocument.prototype.dataA;
//dot.cite = DotDocument.prototype.cite;
//dot.form = DotDocument.prototype.form;
exports["default"] = dot;
//# sourceMappingURL=dot.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfZG90aHRtbF9saWJfZG90X2pzLjk2NzNkODk0ODZkMDg5NWQyODUwLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNCQUFzQixHQUFHLHFCQUFxQjtBQUM5QyxvQ0FBb0MsbUJBQU8sQ0FBQyw0REFBYTtBQUN6RCxxQ0FBcUMsbUJBQU8sQ0FBQyxvRkFBeUI7QUFDdEUsOEJBQThCLG1CQUFPLENBQUMsZ0RBQU87QUFDN0MsbUJBQW1CLG1CQUFPLENBQUMsMERBQVk7QUFDdkMsb0NBQW9DLG1CQUFPLENBQUMsNERBQWE7QUFDekQsMkJBQTJCLG1CQUFPLENBQUMsMEVBQW9CO0FBQ3ZELDJDQUEyQyxtQkFBTyxDQUFDLDBFQUFvQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQSw0QkFBNEIseUJBQXlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QiwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0dBQXNHO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RTtBQUM3RTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DLHdCQUF3QixzQ0FBc0M7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrT0FBK087QUFDL087QUFDQTtBQUNBO0FBQ0EsZUFBZSwrQ0FBK0M7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMscUJBQXFCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIscUJBQXFCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0hBQStIO0FBQy9IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EscURBQXFELGdDQUFnQztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdGQUF3RjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx1REFBdUQ7QUFDeEY7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsb0JBQW9CO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixRQUFRO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EscUNBQXFDLGlCQUFpQjtBQUN0RDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQywrQkFBK0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsbUVBQW1FO0FBQ2xIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLCtCQUErQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL3dlZGRpbmctd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9kb3RodG1sL2xpYi9kb3QuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XHJcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xyXG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcclxufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBvW2syXSA9IG1ba107XHJcbn0pKTtcclxudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XHJcbn0pIDogZnVuY3Rpb24obywgdikge1xyXG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xyXG59KTtcclxudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xyXG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5BVFRSSUJVVEVfTU9ERSA9IGV4cG9ydHMuU0VMRUNUT1JfTU9ERSA9IHZvaWQgMDtcclxuY29uc3QgZXZlbnRfYnVzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vZXZlbnQtYnVzXCIpKTtcclxuY29uc3Qgc3R5bGVfYnVpbGRlcl8xID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3N0eWxpbmcvc3R5bGUtYnVpbGRlclwiKSk7XHJcbmNvbnN0IGVycl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2VyclwiKSk7XHJcbmNvbnN0IGRvdF91dGlsXzEgPSByZXF1aXJlKFwiLi9kb3QtdXRpbFwiKTtcclxuY29uc3QgY29tcG9uZW50XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vY29tcG9uZW50XCIpKTtcclxuY29uc3QgYXJnX2NhbGxiYWNrX29ial8xID0gcmVxdWlyZShcIi4vYXJnLWNhbGxiYWNrLW9ialwiKTtcclxuY29uc3Qgb2JzZXJ2YWJsZV9hcnJheV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL29ic2VydmFibGUtYXJyYXlcIikpO1xyXG5jb25zdCBkb3QgPSAoZnVuY3Rpb24gKHRhcmdldFNlbGVjdG9yKSB7XHJcbiAgICAvL2NvbnNvbGUubG9nKHRhcmdldFNlbGVjdG9yKTtcclxuICAgIHZhciB0YXJnZXRzID0gdGFyZ2V0U2VsZWN0b3IgPyAodHlwZW9mIHRhcmdldFNlbGVjdG9yID09IFwic3RyaW5nXCIgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHRhcmdldFNlbGVjdG9yKVxyXG4gICAgICAgIDogKHRhcmdldFNlbGVjdG9yIGluc3RhbmNlb2YgRWxlbWVudCB8fCB0YXJnZXRTZWxlY3RvciBpbnN0YW5jZW9mIE5vZGUgPyBbdGFyZ2V0U2VsZWN0b3JdXHJcbiAgICAgICAgICAgIDogKCh0YXJnZXRTZWxlY3RvciBpbnN0YW5jZW9mIE5vZGVMaXN0IHx8ICh0YXJnZXRTZWxlY3RvciBpbnN0YW5jZW9mIEFycmF5KSAmJiB0YXJnZXRTZWxlY3RvclswXSAmJiAodGFyZ2V0U2VsZWN0b3JbMF0gaW5zdGFuY2VvZiBFbGVtZW50IHx8IHRhcmdldFNlbGVjdG9yWzBdIGluc3RhbmNlb2YgTm9kZSkpID8gdGFyZ2V0U2VsZWN0b3JcclxuICAgICAgICAgICAgICAgIDogW10pKSlcclxuICAgICAgICA6IFtdO1xyXG4gICAgLy9jb25zb2xlLmxvZyh0YXJnZXRzKTtcclxuICAgIHZhciBuZXdEb3QgPSBuZXcgRG90RG9jdW1lbnQoKTtcclxuICAgIGlmICh0YXJnZXRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBuZXdEb3QuX19kb2N1bWVudCA9IHRhcmdldHNbMF07XHJcbiAgICB9XHJcbiAgICBkb3RbXCJfX3NlbGVjdGlvbk1vZGVcIl0gPSBleHBvcnRzLlNFTEVDVE9SX01PREU7XHJcbiAgICByZXR1cm4gbmV3RG90O1xyXG59KTtcclxuY29uc3QgRE9DRUwgPSBcIkRPVEhUTUwtRE9DVU1FTlRcIjtcclxuY29uc3QgREVGRUwgPSBcIkRPVEhUTUwtREVGRVJcIjtcclxudmFyIF9hbm9uRnVuY0NvdW50ZXIgPSAwO1xyXG5mdW5jdGlvbiBleHQobmFtZSwgbWV0aG9kKSB7XHJcbiAgICBfcFtuYW1lXSA9IGRvdFtuYW1lXSA9IG1ldGhvZDtcclxufVxyXG4vLyBEZWxldGVzIG9uZSBlbGVtZW50IChhbmQgbm90IGl0cyBjaGlsZHJlbikuIFxyXG4vLyBVc2VkIGJ5IF9wLmVtcHR5IGFuZCBfcC5yZW1vdmUuXHJcbmZ1bmN0aW9uIGRlbGV0ZUVsZW1lbnQoZWxlbWVudCkge1xyXG4gICAgdmFyIGRlbGV0ZWQgPSBudWxsO1xyXG4gICAgdmFyIGRjID0gZWxlbWVudFtcIl9fZG90aHRtbF9jb21wb25lbnRcIl07XHJcbiAgICBpZiAoZGMpIHtcclxuICAgICAgICAvLyB2YXIgZCA9IGRjLmRlbGV0aW5nO1xyXG4gICAgICAgIGRjLmRlbGV0aW5nICYmIGRjLmRlbGV0aW5nKCk7XHJcbiAgICAgICAgZGNbXCJfXyRlbFwiXSA9IG51bGw7XHJcbiAgICAgICAgZGVsZXRlZCA9IGRjLmRlbGV0ZWQ7XHJcbiAgICB9XHJcbiAgICBpZiAoZWxlbWVudC5wYXJlbnROb2RlKVxyXG4gICAgICAgIGVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbGVtZW50KTtcclxuICAgIGRlbGV0ZWQgJiYgZGVsZXRlZC5hcHBseShkYyk7XHJcbn1cclxuZnVuY3Rpb24gX2NvbmRpdGlvbmFsQmxvY2soVCwgdG90YWxDb25kaXRpb24sIGFsbENvbmRpdGlvbnMsIGNvbnRlbnRDYWxsYmFjaykge1xyXG4gICAgdmFyIHN0YXJ0VGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlwiKTtcclxuICAgIHZhciBlbmRUZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXCIpO1xyXG4gICAgLy92YXIgY2IgPSB7Zjpjb250ZW50Q2FsbGJhY2ssc3RhcnROb2RlOnN0YXJ0VGV4dE5vZGUsIGVuZE5vZGU6ZW5kVGV4dE5vZGUsY29uZGl0aW9uOnRvdGFsQ29uZGl0aW9ufTtcclxuICAgIHZhciBjYiA9IG5ldyBhcmdfY2FsbGJhY2tfb2JqXzEuQ29uZGl0aW9uYWxBcmdDYWxsYmFjayhzdGFydFRleHROb2RlLCBlbmRUZXh0Tm9kZSwgY29udGVudENhbGxiYWNrLCB0b3RhbENvbmRpdGlvbik7XHJcbiAgICBkb3RbXCJfX2N1cnJlbnRBcmdDYWxsYmFja1wiXS5wdXNoKGNiKTtcclxuICAgIHZhciByZW5kZXJDb250ZW50ID0gdG90YWxDb25kaXRpb24oKTtcclxuICAgIFQgPSBULl9hcHBlbmRPckNyZWF0ZURvY3VtZW50KHN0YXJ0VGV4dE5vZGUpO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxDb25kaXRpb25zLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIGFsbENvbmRpdGlvbnNbaV0oKTtcclxuICAgIGNiLmxhc3RWYWx1ZSA9IHJlbmRlckNvbnRlbnQ7XHJcbiAgICBpZiAocmVuZGVyQ29udGVudClcclxuICAgICAgICBUID0gVC5fYXBwZW5kT3JDcmVhdGVEb2N1bWVudChjb250ZW50Q2FsbGJhY2spO1xyXG4gICAgVCA9IFQuX2FwcGVuZE9yQ3JlYXRlRG9jdW1lbnQoZW5kVGV4dE5vZGUpO1xyXG4gICAgZG90W1wiX19jdXJyZW50QXJnQ2FsbGJhY2tcIl0ucG9wKCk7XHJcbiAgICByZXR1cm4gVDtcclxufVxyXG5mdW5jdGlvbiBhdHRhY2hFdmVudChlbCwgZXYsIHZhbCwgYTMpIHtcclxuICAgIGlmIChlbC5hZGRFdmVudExpc3RlbmVyKVxyXG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXYsIHZhbCwgYTMgfHwgZmFsc2UpO1xyXG4gICAgZWxzZVxyXG4gICAgICAgIGVsLmF0dGFjaEV2ZW50KFwib25cIiArIGV2LCB2YWwpOyAvL2NvbXBhdGliaWxpdHkgd2l0aCBvbGQgYnJvd3NlcnMuXHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0YWcpIHtcclxuICAgIGV4dCh0YWcsIGZ1bmN0aW9uIChjKSB7IHJldHVybiB0aGlzLmVsKHRhZywgYyk7IH0pO1xyXG59XHJcbjtcclxuZnVuY3Rpb24gY3JlYXRlQXR0cmlidXRlKGF0dHJpYnV0ZSwgYWxpYXMpIHtcclxuICAgIF9wW2FsaWFzIHx8IGF0dHJpYnV0ZV0gPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHRoaXMuYXR0cihhdHRyaWJ1dGUsIHZhbHVlKTsgfTtcclxufVxyXG47XHJcbi8vIFNlbGVjdGlvbiBNb2RlIGVudW0uXHJcbmV4cG9ydHMuU0VMRUNUT1JfTU9ERSA9IDE7XHJcbmV4cG9ydHMuQVRUUklCVVRFX01PREUgPSAyO1xyXG4vLyBUT0RPOiB0aGlzIG1pZ2h0IG5lZWQgdG8gZ28gaW4ganVzdCB0aGUgcmlnaHQgcGxhY2UuXHJcbi8vIGRvdFJlYWR5KGRvdCwgX3AsIF9EKTtcclxuLy8gRG90IGRvY3VtZW50IG9iamVjdC5cclxuLy8gRm9ybWVybHkgX0RcclxudmFyIERvdERvY3VtZW50ID0gKGZ1bmN0aW9uIChkb2N1bWVudCwgY2xhc3NQcmVmaXgpIHtcclxuICAgIC8vIFByaXZhdGUgdmFycy5cclxuICAgIHRoaXMuX19kb2N1bWVudCA9IGRvY3VtZW50O1xyXG4gICAgdGhpcy5fX2xhc3ROb2RlID0gZG9jdW1lbnQgPyBkb2N1bWVudC5sYXN0Q2hpbGQgOiBudWxsO1xyXG4gICAgdGhpcy5fX2lmID0gbnVsbDtcclxuICAgIHRoaXMuX19wZW5kaW5nQ2FsbHMgPSBbXTsgLy9BbGxvd3MgeW91IHRvIHNldCBwYXJlbnQgYXR0cmlidXRlcyBmcm9tIGNoaWxkcmVuLlxyXG4gICAgdGhpcy5fX2Fub25BdHRyRnVuY3MgPSB7fTsgLy9Pbmx5IHRvIGJlIHVzZWQgYnkgdG9wLWxldmVsIGRvdCBvYmplY3QuXHJcbiAgICB0aGlzLl9fY2xhc3NQcmVmaXggPSBjbGFzc1ByZWZpeCB8fCAwO1xyXG4gICAgdGhpcy5fX2NsYXNzZWRFbGVtZW50cyA9IFtdO1xyXG4gICAgdGhpcy5fX3NlbGVjdGlvbk1vZGUgPSBleHBvcnRzLlNFTEVDVE9SX01PREU7XHJcbn0pO1xyXG4vLyBQcm90b3R5cGUgZm9yIHRoZSBkb3QgZG9jdW1lbnQgb2JqZWN0LlxyXG52YXIgX3AgPSBEb3REb2N1bWVudC5wcm90b3R5cGU7XHJcbnZhciBhbGxUYWdzID0gW1xyXG4gICAgXCJhXCIsXHJcbiAgICBcImFzaWRlXCIsXHJcbiAgICBcImFiYnJcIixcclxuICAgIFwiYWRkcmVzc1wiLFxyXG4gICAgXCJhcmVhXCIsXHJcbiAgICBcImFydGljbGVcIixcclxuICAgIFwiYXVkaW9cIixcclxuICAgIFwiYlwiLFxyXG4gICAgXCJiZGlcIixcclxuICAgIFwiYmRvXCIsXHJcbiAgICBcImJsb2NrUXVvdGVcIixcclxuICAgIFwiYm9keVwiLFxyXG4gICAgXCJiclwiLFxyXG4gICAgXCJidXR0b25cIixcclxuICAgIFwiY2FudmFzXCIsXHJcbiAgICBcImNhcHRpb25cIixcclxuICAgIFwiY2l0ZVwiLFxyXG4gICAgXCJjb2RlXCIsXHJcbiAgICBcImNvbFwiLFxyXG4gICAgXCJjb2xHcm91cFwiLFxyXG4gICAgXCJjb250ZW50XCIsXHJcbiAgICBcImRhdGFcIixcclxuICAgIFwiZGF0YUxpc3RcIixcclxuICAgIFwiZGRcIixcclxuICAgIFwiZGVsXCIsXHJcbiAgICBcImRldGFpbHNcIixcclxuICAgIFwiZGZuXCIsXHJcbiAgICBcImRpYWxvZ1wiLFxyXG4gICAgXCJkaXZcIixcclxuICAgIFwiZGxcIixcclxuICAgIFwiZHRcIixcclxuICAgIFwiZW1cIixcclxuICAgIFwiZW1iZWRcIixcclxuICAgIFwiZmllbGRTZXRcIixcclxuICAgIFwiZmlnQ2FwdGlvblwiLFxyXG4gICAgXCJmaWd1cmVcIixcclxuICAgIFwiZm9vdGVyXCIsXHJcbiAgICBcImZvcm1cIixcclxuICAgIFwiaDFcIixcclxuICAgIFwiaDJcIixcclxuICAgIFwiaDNcIixcclxuICAgIFwiaDRcIixcclxuICAgIFwiaDVcIixcclxuICAgIFwiaDZcIixcclxuICAgIFwiaGVhZGVyXCIsXHJcbiAgICBcImhyXCIsXHJcbiAgICBcImlcIixcclxuICAgIFwiaUZyYW1lXCIsXHJcbiAgICBcImltZ1wiLFxyXG4gICAgXCJpbnB1dFwiLFxyXG4gICAgXCJpbnNcIixcclxuICAgIFwia2JkXCIsXHJcbiAgICBcImtleUdlblwiLFxyXG4gICAgXCJsYWJlbFwiLFxyXG4gICAgXCJsZWdlbmRcIixcclxuICAgIFwibGlcIixcclxuICAgIFwibWFpblwiLFxyXG4gICAgXCJtYXBcIixcclxuICAgIFwibWFya1wiLFxyXG4gICAgXCJtZW51XCIsXHJcbiAgICBcIm1lbnVJdGVtXCIsXHJcbiAgICBcIm1ldGVyXCIsXHJcbiAgICBcIm5hdlwiLFxyXG4gICAgXCJvYmplY3RcIixcclxuICAgIFwib2xcIixcclxuICAgIFwib3B0R3JvdXBcIixcclxuICAgIFwib3B0aW9uXCIsXHJcbiAgICBcIm91dHB1dFwiLFxyXG4gICAgXCJwXCIsXHJcbiAgICBcInBhcmFtXCIsXHJcbiAgICBcInByZVwiLFxyXG4gICAgXCJwcm9ncmVzc1wiLFxyXG4gICAgXCJxXCIsXHJcbiAgICBcInJwXCIsXHJcbiAgICBcInJ0XCIsXHJcbiAgICBcInJ1YnlcIixcclxuICAgIFwic1wiLFxyXG4gICAgXCJzYW1wXCIsXHJcbiAgICBcInNlY3Rpb25cIixcclxuICAgIFwic2VsZWN0XCIsXHJcbiAgICBcInNtYWxsXCIsXHJcbiAgICBcInNvdXJjZVwiLFxyXG4gICAgXCJzcGFuXCIsXHJcbiAgICBcInN0cm9uZ1wiLFxyXG4gICAgXCJzdmdcIixcclxuICAgIFwic3ViXCIsXHJcbiAgICBcInN1bW1hcnlcIixcclxuICAgIFwic3VwXCIsXHJcbiAgICBcInRhYmxlXCIsXHJcbiAgICBcInRCb2R5XCIsXHJcbiAgICBcInRkXCIsXHJcbiAgICBcInRleHRBcmVhXCIsXHJcbiAgICBcInRGb290XCIsXHJcbiAgICBcInRoXCIsXHJcbiAgICBcInRIZWFkXCIsXHJcbiAgICBcInRpbWVcIixcclxuICAgIFwidHJcIixcclxuICAgIFwidHJhY2tcIixcclxuICAgIFwidVwiLFxyXG4gICAgXCJ1bFwiLFxyXG4gICAgXCJ2YXJcIixcclxuICAgIFwidmlkZW9cIixcclxuICAgIFwid2JyXCJcclxuXTtcclxudmFyIGFsbEF0dHJpYnV0ZXMgPSBbXHJcbiAgICBcImFjY2VwdFwiLFxyXG4gICAgXCJhY2Nlc3NLZXlcIixcclxuICAgIFwiYWN0aW9uXCIsXHJcbiAgICBcImFsaWduXCIsXHJcbiAgICBcImFMaW5rXCIsXHJcbiAgICBcImFsdFwiLFxyXG4gICAgXCJhcmNoaXZlXCIsXHJcbiAgICBcImF1dG9Db21wbGV0ZVwiLFxyXG4gICAgXCJhdXRvRm9jdXNcIixcclxuICAgIFwiYXV0b1BsYXlcIixcclxuICAgIFwiYXV0b1NhdmVcIixcclxuICAgIFwiYXhpc1wiLFxyXG4gICAgXCJiYWNrZ3JvdW5kXCIsXHJcbiAgICBcImJnQ29sb3JcIixcclxuICAgIFwiYm9yZGVyXCIsXHJcbiAgICBcImJ1ZmZlcmVkXCIsXHJcbiAgICBcImNlbGxQYWRkaW5nXCIsXHJcbiAgICBcImNlbGxTcGFjaW5nXCIsXHJcbiAgICBcImNoYWxsZW5nZVwiLFxyXG4gICAgXCJjaGFyXCIsXHJcbiAgICBcImNoYXJPZmZcIixcclxuICAgIFwiY2hlY2tlZFwiLFxyXG4gICAgLy8gXCJjaXRlXCIsIC8vKlxyXG4gICAgLy9cImNsYXNzXCIsXHJcbiAgICBcImNsYXNzSWRcIixcclxuICAgIFwiY2xlYXJcIixcclxuICAgIFwiY29kZUJhc2VcIixcclxuICAgIFwiY29kZVR5cGVcIixcclxuICAgIFwiY29sb3JcIixcclxuICAgIFwiY29sc1wiLFxyXG4gICAgXCJjb2xTcGFuXCIsXHJcbiAgICBcImNvbXBhY3RcIixcclxuICAgIFwiY29udGVudEVkaXRhYmxlXCIsXHJcbiAgICBcImNvbnRleHRNZW51XCIsXHJcbiAgICBcImNvbnRyb2xzXCIsXHJcbiAgICBcImNvb3Jkc1wiLFxyXG4gICAgXCJkYXRlVGltZVwiLFxyXG4gICAgXCJkZWNsYXJlXCIsXHJcbiAgICBcImRlZmF1bHRcIixcclxuICAgIC8vXCJkYXRhXCIsIC8vKlxyXG4gICAgXCJkaXJcIixcclxuICAgIFwiZGlyTmFtZVwiLFxyXG4gICAgXCJkaXNhYmxlZFwiLFxyXG4gICAgXCJkb3dubG9hZFwiLFxyXG4gICAgXCJkcmFnZ2FibGVcIixcclxuICAgIFwiZHJvcFpvbmVcIixcclxuICAgIFwiZW5jVHlwZVwiLFxyXG4gICAgXCJmYWNlXCIsXHJcbiAgICBcImZvbnRcIixcclxuICAgIFwiZm9udEZhY2VcIixcclxuICAgIFwiZm9udEZhY2VGb3JtYXRcIixcclxuICAgIFwiZm9udEZhY2VOYW1lXCIsXHJcbiAgICBcImZvbnRGYWNlU3JjXCIsXHJcbiAgICBcImZvbnRGYWNlVXJpXCIsXHJcbiAgICBcImZvbnRTcGVjaWZpY2F0aW9uXCIsXHJcbiAgICBcImZvclwiLFxyXG4gICAgXCJmb3JlaWduT2JqZWN0XCIsXHJcbiAgICAvLyBcImZvcm1cIiwgLy8qXHJcbiAgICBcImZvcm1BY3Rpb25cIixcclxuICAgIFwiZnJhbWVcIixcclxuICAgIFwiZnJhbWVCb3JkZXJcIixcclxuICAgIFwiaGVhZGVyc1wiLFxyXG4gICAgXCJoZWlnaHRcIixcclxuICAgIFwiaGlkZGVuXCIsXHJcbiAgICBcImhpZ2hcIixcclxuICAgIFwiaFJlZlwiLFxyXG4gICAgXCJoUmVmTGFuZ1wiLFxyXG4gICAgXCJoU3BhY2VcIixcclxuICAgIFwiaWNvblwiLFxyXG4gICAgXCJpZFwiLFxyXG4gICAgXCJpbWFnZXNcIixcclxuICAgIFwiaXNNYXBcIixcclxuICAgIFwiaXRlbVByb3BcIixcclxuICAgIFwia2V5VHlwZVwiLFxyXG4gICAgXCJraW5kXCIsXHJcbiAgICAvLyBcImxhYmVsXCIsIC8vKlxyXG4gICAgXCJsYW5nXCIsXHJcbiAgICBcImxpc3RcIixcclxuICAgIFwibG9uZ0Rlc2NcIixcclxuICAgIFwibG9vcFwiLFxyXG4gICAgXCJsb3dcIixcclxuICAgIFwibWFuaWZlc3RcIixcclxuICAgIFwibWFyZ2luSGVpZ2h0XCIsXHJcbiAgICBcIm1hcmdpbldpZHRoXCIsXHJcbiAgICBcIm1heFwiLFxyXG4gICAgXCJtYXhMZW5ndGhcIixcclxuICAgIFwibWVkaWFcIixcclxuICAgIFwibWV0YWRhdGFcIixcclxuICAgIFwibWV0aG9kXCIsXHJcbiAgICBcIm1pblwiLFxyXG4gICAgXCJtaXNzaW5nR2x5cGhcIixcclxuICAgIFwibXVsdGlwbGVcIixcclxuICAgIFwibXV0ZWRcIixcclxuICAgIFwibmFtZVwiLFxyXG4gICAgXCJub0hSZWZcIixcclxuICAgIFwibm9SZXNpemVcIixcclxuICAgIFwibm9TaGFkZVwiLFxyXG4gICAgXCJub1ZhbGlkYXRlXCIsXHJcbiAgICBcIm5vd3JhcFwiLFxyXG4gICAgXCJvcGVuXCIsXHJcbiAgICBcIm9wdGltdW1cIixcclxuICAgIFwicGF0dGVyblwiLFxyXG4gICAgXCJwaW5nXCIsXHJcbiAgICBcInBsYWNlaG9sZGVyXCIsXHJcbiAgICBcInBvc3RlclwiLFxyXG4gICAgXCJwcmVsb2FkXCIsXHJcbiAgICBcInByb21wdFwiLFxyXG4gICAgXCJyYWRpb0dyb3VwXCIsXHJcbiAgICBcInJlYWRPbmx5XCIsXHJcbiAgICBcInJlbFwiLFxyXG4gICAgXCJyZXF1aXJlZFwiLFxyXG4gICAgXCJyZXZcIixcclxuICAgIFwicmV2ZXJzZWRcIixcclxuICAgIFwicm93c1wiLFxyXG4gICAgXCJyb3dTcGFuXCIsXHJcbiAgICBcInJ1bGVzXCIsXHJcbiAgICBcInNhbmRib3hcIixcclxuICAgIFwic2NvcGVcIixcclxuICAgIFwic2Nyb2xsaW5nXCIsXHJcbiAgICBcInNlYW1sZXNzXCIsXHJcbiAgICBcInNlbGVjdGVkXCIsXHJcbiAgICBcInNoYXBlXCIsXHJcbiAgICBcInNpemVcIixcclxuICAgIFwic2l6ZXNcIixcclxuICAgIC8vIFwic3BhblwiLCAvLypcclxuICAgIFwic3BlbGxDaGVja1wiLFxyXG4gICAgXCJzcmNcIixcclxuICAgIFwic3JjRG9jXCIsXHJcbiAgICBcInNyY0xhbmdcIixcclxuICAgIFwic3JjU2V0XCIsXHJcbiAgICBcInN0YW5kYnlcIixcclxuICAgIFwic3RhcnRcIixcclxuICAgIFwic3RlcFwiLFxyXG4gICAgLy8gXCJzdW1tYXJ5XCIsIC8vKlxyXG4gICAgXCJzdHlsZVwiLFxyXG4gICAgXCJ0YWJJbmRleFwiLFxyXG4gICAgXCJ0YXJnZXRcIixcclxuICAgIFwidGl0bGVcIixcclxuICAgIFwidHlwZVwiLFxyXG4gICAgXCJ1c2VNYXBcIixcclxuICAgIFwidkFsaWduXCIsXHJcbiAgICBcInZhbHVlXCIsXHJcbiAgICBcInZhbHVlVHlwZVwiLFxyXG4gICAgXCJ3aWR0aFwiLFxyXG4gICAgXCJ3cmFwXCJcclxuICAgIC8vXCJkYXRhQVwiLCAvL1NwZWNpYWwgZXhwbGljaXQgXHJcbiAgICAvL1wiY2l0ZUFcIixcclxuICAgIC8vXCJmb3JtQVwiLFxyXG4gICAgLy9cImxhYmVsQVwiLFxyXG4gICAgLy9cInNwYW5BXCIsXHJcbiAgICAvL1wic3VtbWFyeUFcIlxyXG5dO1xyXG52YXIgc3BlY2lhbEF0dHJpYnV0ZXMgPSBbXHJcbiAgICBbXCJxdW90ZUNpdGVcIiwgXCJjaXRlXCJdLFxyXG4gICAgW1wib2JqZWN0RGF0YVwiLCBcImRhdGFcIl0sXHJcbiAgICBbXCJ3aGljaEZvcm1cIiwgXCJmb3JtXCJdLFxyXG4gICAgW1widHJhY2tMYWJlbFwiLCBcImxhYmVsXCJdLFxyXG4gICAgW1wiY29sU3BhblwiLCBcInNwYW5cIl0sXHJcbiAgICBbXCJ0YWJsZVN1bW1hcnlcIiwgXCJzdW1tYXJ5XCJdLFxyXG4gICAgW1wib3B0aW9uTGFiZWxcIiwgXCJsYWJlbFwiXSxcclxuICAgIFtcImFjY2VwdENoYXJzZXRcIiwgXCJhY2NlcHQtY2hhcnNldFwiXSxcclxuXTtcclxudmFyIGFsbEV2ZW50QXR0ciA9IFtcclxuICAgIFwib25BYm9ydFwiLFxyXG4gICAgXCJvbkJsdXJcIixcclxuICAgIFwib25DaGFuZ2VcIixcclxuICAgIFwib25JbnB1dFwiLFxyXG4gICAgXCJvbkNhblBsYXlcIixcclxuICAgIFwib25DYW50UGxheVRocm91Z2hcIixcclxuICAgIFwib25DbGlja1wiLFxyXG4gICAgXCJvbkNvcHlcIixcclxuICAgIFwib25Db250ZXh0TWVudVwiLFxyXG4gICAgXCJvbkN1ZUNoYW5nZVwiLFxyXG4gICAgXCJvbkN1dFwiLFxyXG4gICAgXCJvbkRibENsaWNrXCIsXHJcbiAgICBcIm9uRHJhZ1wiLFxyXG4gICAgXCJvbkRyYWdFbmRcIixcclxuICAgIFwib25EcmFnRW50ZXJcIixcclxuICAgIFwib25EcmFnTGVhdmVcIixcclxuICAgIFwib25EcmFnT3ZlclwiLFxyXG4gICAgXCJvbkRyYWdTdGFydFwiLFxyXG4gICAgXCJvbkRyb3BcIixcclxuICAgIFwib25EdXJhdGlvbkNoYW5nZVwiLFxyXG4gICAgXCJvbkVtcHRpZWRcIixcclxuICAgIFwib25FbmRlZFwiLFxyXG4gICAgXCJvbkVycm9yXCIsXHJcbiAgICBcIm9uRm9jdXNcIixcclxuICAgIFwib25IYXNoQ2hhbmdlXCIsXHJcbiAgICBcIm9uSW52YWxpZFwiLFxyXG4gICAgXCJvbktleURvd25cIixcclxuICAgIFwib25LZXlQcmVzc1wiLFxyXG4gICAgXCJvbktleVVwXCIsXHJcbiAgICBcIm9uTG9hZFwiLFxyXG4gICAgXCJvbkxvYWRlZERhdGFcIixcclxuICAgIFwib25Mb2FkZWRNZXRhZGF0YVwiLFxyXG4gICAgXCJvbkxvYWRTdGFydFwiLFxyXG4gICAgXCJvbk1vdXNlRG93blwiLFxyXG4gICAgXCJvbk1vdXNlRW50ZXJcIixcclxuICAgIFwib25Nb3VzZUxlYXZlXCIsXHJcbiAgICBcIm9uTW91c2VNb3ZlXCIsXHJcbiAgICBcIm9uTW91c2VPdXRcIixcclxuICAgIFwib25Nb3VzZU92ZXJcIixcclxuICAgIFwib25Nb3VzZVVwXCIsXHJcbiAgICBcIm9uUG9pbnRlckNhbmNlbFwiLFxyXG4gICAgXCJvblBvaW50ZXJEb3duXCIsXHJcbiAgICBcIm9uUG9pbnRlckVudGVyXCIsXHJcbiAgICBcIm9uUG9pbnRlckxlYXZlXCIsXHJcbiAgICBcIm9uUG9pbnRlck1vdmVcIixcclxuICAgIFwib25Qb2ludGVyT3V0XCIsXHJcbiAgICBcIm9uUG9pbnRlck92ZXJcIixcclxuICAgIFwib25Qb2ludGVyVXBcIixcclxuICAgIFwib25Ub3VjaFN0YXJ0XCIsXHJcbiAgICBcIm9uVG91Y2hFbmRcIixcclxuICAgIFwib25Ub3VjaENhbmNlbFwiLFxyXG4gICAgXCJvblRvdWNoTW92ZVwiLFxyXG4gICAgXCJvbk1vdXNlV2hlZWxcIixcclxuICAgIFwib25PZmZsaW5lXCIsXHJcbiAgICBcIm9uT25saW5lXCIsXHJcbiAgICBcIm9uUGFnZUhpZGVcIixcclxuICAgIFwib25QYWdlUGFzdGVcIixcclxuICAgIFwib25QYWdlU2hvd1wiLFxyXG4gICAgXCJvblBhdXNlXCIsXHJcbiAgICBcIm9uUGxheVwiLFxyXG4gICAgXCJvblBsYXlpbmdcIixcclxuICAgIFwib25Qb3BTdGF0ZVwiLFxyXG4gICAgXCJvblByb2dyZXNzXCIsXHJcbiAgICBcIm9uUmF0ZUNoYW5nZVwiLFxyXG4gICAgXCJvblJlc2V0XCIsXHJcbiAgICBcIm9uUmVzaXplXCIsXHJcbiAgICBcIm9uU2Nyb2xsXCIsXHJcbiAgICBcIm9uU2VhcmNoXCIsXHJcbiAgICBcIm9uU2Vla2VkXCIsXHJcbiAgICBcIm9uU2Vla2luZ1wiLFxyXG4gICAgXCJvblNlbGVjdFwiLFxyXG4gICAgXCJvblN0YWxsZWRcIixcclxuICAgIFwib25TdG9yYWdlXCIsXHJcbiAgICBcIm9uU3VibWl0XCIsXHJcbiAgICBcIm9uU3VzcGVuZFwiLFxyXG4gICAgXCJvblRpbWVVcGRhdGVcIixcclxuICAgIFwib25Ub2dnbGVcIixcclxuICAgIFwib25VbmxvYWRcIixcclxuICAgIFwib25Wb2x1bWVDaGFuZ2VcIixcclxuICAgIFwib25XYWl0aW5nXCIsXHJcbiAgICBcIm9uV2hlZWxcIixcclxuXTtcclxudmFyIGk7XHJcbmZvciAoaSBpbiBhbGxUYWdzKVxyXG4gICAgY3JlYXRlRWxlbWVudChhbGxUYWdzW2ldKTtcclxuZm9yIChpIGluIGFsbEF0dHJpYnV0ZXMpXHJcbiAgICBjcmVhdGVBdHRyaWJ1dGUoYWxsQXR0cmlidXRlc1tpXSk7XHJcbmZvciAoaSBpbiBzcGVjaWFsQXR0cmlidXRlcykge1xyXG4gICAgY3JlYXRlQXR0cmlidXRlKHNwZWNpYWxBdHRyaWJ1dGVzW2ldWzFdLCBzcGVjaWFsQXR0cmlidXRlc1tpXVswXSk7XHJcbn1cclxuZm9yIChpIGluIGFsbEV2ZW50QXR0cilcclxuICAgIGNyZWF0ZUF0dHJpYnV0ZShhbGxFdmVudEF0dHJbaV0pO1xyXG5leHQoXCJhc1wiLCBmdW5jdGlvbiAoZG90RWxlbWVudCkge1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn0pO1xyXG5leHQoXCJfZ2V0TmV3RG9jdW1lbnRcIiwgZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoRE9DRUwpO1xyXG59KTtcclxuZXh0KFwiX2dldEFuSW5zdGFuY2VcIiwgZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKHRoaXMuX19kb2N1bWVudCB8fCB0aGlzLl9fcGVuZGluZ0NhbGxzLmxlbmd0aCA+IDApXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB2YXIgZCA9IG5ldyBEb3REb2N1bWVudChudWxsLCB0aGlzLl9fY2xhc3NQcmVmaXgpO1xyXG4gICAgICAgIGQuX19pZiA9IHRoaXMuX19pZjtcclxuICAgICAgICByZXR1cm4gZDtcclxuICAgIH1cclxuICAgIDtcclxufSk7XHJcbmV4dChcIl9nZXRMYXN0Q2hpbGRPck51bGxcIiwgZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKHRoaXMuX19kb2N1bWVudCAmJiB0aGlzLl9fZG9jdW1lbnQubGFzdENoaWxkKVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9fZG9jdW1lbnQubGFzdENoaWxkO1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbn0pO1xyXG4vL0knbSBub3Qgc3VyZSBpZiB0aGlzIGlzIHN1cHBvcnRlZCBhbnltb3JlLlxyXG5leHQoXCJnZXRMYXN0XCIsIGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB0aGlzLl9nZXRMYXN0Q2hpbGRPck51bGwoKTtcclxufSk7XHJcbmV4dChcImdldEN1cnJlbnRcIiwgZnVuY3Rpb24gKCkge1xyXG4gICAgbGV0IGxhc3Q7XHJcbiAgICBzd2l0Y2ggKGRvdFtcIl9fc2VsZWN0aW9uTW9kZVwiXSkge1xyXG4gICAgICAgIGNhc2UgZXhwb3J0cy5TRUxFQ1RPUl9NT0RFOiB7XHJcbiAgICAgICAgICAgIGxhc3QgPSB0aGlzLl9fZG9jdW1lbnQ7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIGV4cG9ydHMuQVRUUklCVVRFX01PREU6IHtcclxuICAgICAgICAgICAgbGFzdCA9IHRoaXMuZ2V0TGFzdCgpIHx8IHRoaXMuX19kb2N1bWVudDtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxhc3Q7XHJcbn0pO1xyXG5fcC50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICh0aGlzLl9fZG9jdW1lbnQpXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX19kb2N1bWVudC5pbm5lckhUTUw7XHJcbiAgICBlbHNlXHJcbiAgICAgICAgcmV0dXJuIFwiXCI7XHJcbn07XHJcbl9wLnJlZiA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICBsZXQgbCA9IHRoaXMuZ2V0TGFzdCgpO1xyXG4gICAgbGV0IGdsID0gZG90X3V0aWxfMS5HbG9iYWxDb21wb25lbnRTdGFjay5sZW5ndGg7XHJcbiAgICBpZiAobCAmJiBnbCA+IDApIHtcclxuICAgICAgICBsZXQgYyA9IGRvdF91dGlsXzEuR2xvYmFsQ29tcG9uZW50U3RhY2tbZ2wgLSAxXTtcclxuICAgICAgICBjLiRyZWZzW25hbWVdID0gbDtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG4vL2JlZm9yZSBpcyBwYXNzZWQgaW4gc28gdGhhdCBhdHRyaWJ1dGVzIGNhbiBiZSBhc3NvY2lhdGVkIHdpdGggYmVmb3JlJ3Mgc2libGluZywgaW5zdGVhZCBvZiBpbmhlcml0aW5nUGFyZW50LCB0aGUgZGVmYXVsdC5cclxuZXh0KFwiX2V2YWxDb250ZW50XCIsIGZ1bmN0aW9uIChjb250ZW50LCBwZW5kaW5nQ2FsbHMpIHtcclxuICAgIGlmIChjb250ZW50ID09IG51bGwgfHwgY29udGVudCA9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIGNvbnRlbnQgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIGNvbnRlbnQgPT09IFwiYm9vbGVhblwiKSB7IC8vUmF3IGRhdGFcclxuICAgICAgICBsZXQgbkRvdCA9IG5ldyBEb3REb2N1bWVudCh0aGlzLl9nZXROZXdEb2N1bWVudCgpLCB0aGlzLl9fY2xhc3NQcmVmaXgpO1xyXG4gICAgICAgIG5Eb3QuX19kb2N1bWVudC5pbm5lckhUTUwgPSBjb250ZW50O1xyXG4gICAgICAgIHJldHVybiBuRG90Ll9fZG9jdW1lbnQuY2hpbGROb2RlcztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBOb2RlKVxyXG4gICAgICAgIHJldHVybiBjb250ZW50O1xyXG4gICAgZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGNvbnRlbnQpID09PSAnW29iamVjdCBBcnJheV0nKSB7IC8vQXJyYXlcclxuICAgICAgICBsZXQgbkRvdCA9IG5ldyBEb3REb2N1bWVudCh0aGlzLl9nZXROZXdEb2N1bWVudCgpLCB0aGlzLl9fY2xhc3NQcmVmaXgpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29udGVudC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBuRG90Ll9hcHBlbmRPckNyZWF0ZURvY3VtZW50KGNvbnRlbnRbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobkRvdC5fX2RvY3VtZW50KVxyXG4gICAgICAgICAgICByZXR1cm4gbkRvdC5fX2RvY3VtZW50LmNoaWxkTm9kZXM7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgoMCwgZG90X3V0aWxfMS5pc0YpKGNvbnRlbnQpKSAvL0Z1bmN0aW9uIHRvIGV2YWx1YXRlXHJcbiAgICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9ldmFsQ29udGVudChjb250ZW50KCksIHBlbmRpbmdDYWxscyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChjb250ZW50IGluc3RhbmNlb2YgY29tcG9uZW50XzEuZGVmYXVsdCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9ldmFsQ29udGVudChjb21wb25lbnRfMS5kZWZhdWx0LmJ1aWxkKGNvbnRlbnQpKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBEb3REb2N1bWVudCkgeyAvL0RPVFxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29udGVudFtcIl9fcGVuZGluZ0NhbGxzXCJdLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHBlbmRpbmdDYWxscy5wdXNoKGNvbnRlbnRbXCJfX3BlbmRpbmdDYWxsc1wiXVtpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBjcCA9IHRoaXMuX19jbGFzc1ByZWZpeDtcclxuICAgICAgICBmb3IgKGxldCBpIGluIGNvbnRlbnRbXCJfX2NsYXNzZWRFbGVtZW50c1wiXSkge1xyXG4gICAgICAgICAgICBsZXQgZWwgPSBjb250ZW50W1wiX19jbGFzc2VkRWxlbWVudHNcIl1baV07XHJcbiAgICAgICAgICAgIGlmICghY3ApIHtcclxuICAgICAgICAgICAgICAgIHRoaXNbXCJfX2NsYXNzZWRFbGVtZW50c1wiXS5wdXNoKGVsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGVsLmNsYXNzTmFtZSA9IFwiZG90LVwiICsgKDAsIGRvdF91dGlsXzEuc3RyKShjcCwgMTYpICsgXCItXCIgKyBlbC5jbGFzc05hbWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvbnRlbnRbXCJfX2RvY3VtZW50XCJdKVxyXG4gICAgICAgICAgICByZXR1cm4gY29udGVudFtcIl9fZG9jdW1lbnRcIl0uY2hpbGROb2RlczsgLy9SZXR1cm4gYWxsIHRoZSBub2RlcyBpbiBoZXJlLlxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn0pO1xyXG5leHQoXCJfYXBwZW5kT3JDcmVhdGVEb2N1bWVudFwiLCBmdW5jdGlvbiAoY29udGVudCwgcGFyZW50RWwsIGJlZm9yZU5vZGUpIHtcclxuICAgIHZhciBUID0gdGhpcztcclxuICAgIC8vIFZhbGlkYXRpb25cclxuICAgIDtcclxuICAgIDtcclxuICAgIDtcclxuICAgIGlmIChwYXJlbnRFbCAmJiBiZWZvcmVOb2RlICYmIGlzTmFOKGJlZm9yZU5vZGUpICYmIGJlZm9yZU5vZGUucGFyZW50Tm9kZSAhPSBwYXJlbnRFbClcclxuICAgICAgICB0aHJvdyBcImJlZm9yZU5vZGUgaXMgbm90IGluIHBhcmVudEVsLlwiO1xyXG4gICAgLy8gRmluZCB0aGUgcGFyZW50LCBvciBjcmVhdGUgb25lLlxyXG4gICAgLy9Ob3RlOiB0aGUgc3R1ZmYgd2l0aCBzZXR0aW5nIHBhcmVudEVsIHRvIGJlZm9yZU5vZGUncyBwYXJlbnQgaXMgZHVlIHRvIGEgdmVyeSBzdHJhbmdlIGJ1ZyB3aGVyZSB0aGlzLl9fZG9jdW1lbnQgZ2V0cyBzZXQgdG8gc29tZSBwaGFudG9tIGRvY3VtZW50IHdoZW4gdGhlIHdhaXQgZnVuY3Rpb24gaXMgdXNlZCBpbnNpZGUgYSBkaXYgbGlrZSBzbzogRE9ULmRpdihET1Qud2FpdCgxMDAsIFwiaGVsbG8hXCIpKTsgVHJ5IGl0LiApXHJcbiAgICBwYXJlbnRFbCA9IHBhcmVudEVsIHx8IChiZWZvcmVOb2RlICYmIGlzTmFOKGJlZm9yZU5vZGUpID8gYmVmb3JlTm9kZS5wYXJlbnROb2RlIDogbnVsbCkgfHwgVC5fX2RvY3VtZW50IHx8IFQuX2dldE5ld0RvY3VtZW50KCk7XHJcbiAgICBpZiAoIWlzTmFOKGJlZm9yZU5vZGUpKSB7XHJcbiAgICAgICAgYmVmb3JlTm9kZSA9IHBhcmVudEVsLmNoaWxkTm9kZXNbYmVmb3JlTm9kZV07XHJcbiAgICAgICAgLy87OztcdFx0aWYoIWJlZm9yZU5vZGUpIHRocm93IFwiYmVmb3JlTm9kZSBub3QgZm91bmQuXCI7IC8vIFRPRE86IHJlZW5hYmxlIHRoaXMgYW5kIGludmVzdGlnYXRlIHdoeSBpdCBicmVha3MuXHJcbiAgICB9XHJcbiAgICAvLyBuZCBpcyBhIGRvdCB3cmFwcGVyIGZvciBwYXJlbnRFbCAoYWxsb3dzIHVzIHRvIGRvIGRvdCBvcHMgb24gaXQpLlxyXG4gICAgdmFyIG5kID0gVC5fX2RvY3VtZW50ID09PSBwYXJlbnRFbCA/IFQgOiBuZXcgRG90RG9jdW1lbnQocGFyZW50RWwsIFQuX19jbGFzc1ByZWZpeCk7XHJcbiAgICBuZC5fX2lmID0gVC5fX2lmO1xyXG4gICAgdmFyIHBlbmRpbmdDYWxscyA9IFtdOyAvL1RoaXMgd2lsbCBwb3B1bGF0ZSB3aXRoIHBlbmRpbmcgY2FsbHMuXHJcbiAgICAvLyBFdmFsdWF0ZSB0aGUgY29udGVudC4gVGhpcyBkb2VzIG5vdCBhZGQgaXQgdG8gdGhlIERPTSBwZXQuXHJcbiAgICB2YXIgZUNvbnRlbnQ7XHJcbiAgICB2YXIgY2YgPSAoMCwgZG90X3V0aWxfMS5pc0YpKGNvbnRlbnQpO1xyXG4gICAgLy8gSWYgaXQncyBhIGZ1bmN0aW9uLCB3ZSBuZWVkIHRvIGNvbnNpZGVyIFxyXG4gICAgLy9pZihjZikgZG90Ll9fY3VycmVudEFyZ0NhbGxiYWNrLnB1c2goe2Y6Y29udGVudCxlOnBhcmVudEVsfSlcclxuICAgIGlmIChjZilcclxuICAgICAgICBkb3RbXCJfX2N1cnJlbnRBcmdDYWxsYmFja1wiXS5wdXNoKG5ldyBhcmdfY2FsbGJhY2tfb2JqXzEuQ29udGVudEFyZ0NhbGxiYWNrKHBhcmVudEVsLCBjb250ZW50KSk7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGVDb250ZW50ID0gbmQuX2V2YWxDb250ZW50KGNvbnRlbnQsIC8qcGFyZW50RWwsIGJlZm9yZU5vZGUsKi8gcGVuZGluZ0NhbGxzKTtcclxuICAgIH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICAgIGlmIChjZilcclxuICAgICAgICAgICAgZG90W1wiX19jdXJyZW50QXJnQ2FsbGJhY2tcIl0ucG9wKCk7XHJcbiAgICB9XHJcbiAgICAvLyBQZW5kaW5nIGNhbGxzIGFyZSBjYWxscyBpbmNsdWRlZCBpbiB0aGUgZG90IGVsZW1lbnQgd2hpY2ggZGlkbid0IGdldCBjb25zdW1lZCBhbmQgbXVzdCBiZSBwcm9wYWdhdGVkIHVwLlxyXG4gICAgLy8gVGhpcyB1c3VhbGx5IGluY2x1ZGVzIGF0dHJpYnV0ZXMgYW5kIHdhaXRzLlxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwZW5kaW5nQ2FsbHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIgY2FsbCA9IHBlbmRpbmdDYWxsc1tpXTtcclxuICAgICAgICAvL1RocmVlIHBvc3NpYmlsaXRpZXMuXHJcbiAgICAgICAgLy8xLiBVc2UgdGhlIHBlbmRpbmcgY2FsbCBhZ2FpbnN0IHRoZSBsYXN0IHNpYmxpbmcgZWxlbWVudCwgaWYgb25lIGV4aXN0cy5cclxuICAgICAgICAvLzIuIE90aGVyd2lzZSwgdXNlIGl0IG9uIHRoZSBjdXJyZW50IHBhcmVudCwgaWYgaXQncyByZWFkeS5cclxuICAgICAgICAvLzMuIE90aGVyd2lzZSwgc2F2ZSBpdCBhcyBhIHBlbmRpbmcgY2FsbCByaWdodCBoZXJlLiAvLyBEb24ndCB0aGluayB0aGlzIGV2ZXIgaGFwcGVucy5cclxuICAgICAgICB2YXIgcGVuZGluZ0NhbGxUYXJnZXQgPSAoYmVmb3JlTm9kZSA/IChiZWZvcmVOb2RlLnByZXZpb3VzU2libGluZyB8fCBwYXJlbnRFbCAvKlNpbmNlIGxhc3RDaGlsZCB3aWxsIGJlIGEgdGltZW91dCovKSA6IG51bGwgLyoxKi8pIHx8IHBhcmVudEVsLmxhc3RDaGlsZCAvKjIqLyB8fCBwYXJlbnRFbDtcclxuICAgICAgICBpZiAocGVuZGluZ0NhbGxUYXJnZXQgJiYgcGVuZGluZ0NhbGxUYXJnZXQudGFnTmFtZSAhPSBcIkRPQ1VNRU5UXCIpIHtcclxuICAgICAgICAgICAgaWYgKGNhbGwudHlwZSA9PSBcImF0dHJcIikge1xyXG4gICAgICAgICAgICAgICAgaWYgKCEoMCwgZG90X3V0aWxfMS5pc0YpKGNhbGwucGFyYW1zWzBdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmdDYWxsVGFyZ2V0LnNldEF0dHJpYnV0ZShjYWxsLm5hbWUsIGNhbGwucGFyYW1zWzBdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IGhvdyBkbyB3ZSBrbm93IGl0J3MgYSB2YWxpZCBldmVudD9cclxuICAgICAgICAgICAgICAgICAgICBsZXQgbmV3TmFtZSA9IGNhbGwubmFtZTtcclxuICAgICAgICAgICAgICAgICAgICBhdHRhY2hFdmVudChwZW5kaW5nQ2FsbFRhcmdldCwgbmV3TmFtZSwgY2FsbC5wYXJhbXNbMF0sIGNhbGwuYXJnMyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY2FsbC50eXBlID09IFwid2FpdFwiKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsLmNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG5kLl9fcGVuZGluZ0NhbGxzLnB1c2goY2FsbCk7IC8qMyovXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gQXBwZW5kIGNvbnRlbnQgdG8gdGhlIGN1cnJlbnQgZG9jdW1lbnQuXHJcbiAgICBpZiAoZUNvbnRlbnQgIT09IG51bGwgJiYgZUNvbnRlbnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGlmIChlQ29udGVudCBpbnN0YW5jZW9mIE5vZGVMaXN0KSB7XHJcbiAgICAgICAgICAgIC8vZm9yKHZhciBpID0gMDsgaSA8IGVDb250ZW50Lmxlbmd0aDsgaSsrKXtcclxuICAgICAgICAgICAgd2hpbGUgKGVDb250ZW50Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGlmIChiZWZvcmVOb2RlKVxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudEVsLmluc2VydEJlZm9yZShlQ29udGVudFswXSwgYmVmb3JlTm9kZSk7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50RWwuYXBwZW5kQ2hpbGQoZUNvbnRlbnRbMF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoYmVmb3JlTm9kZSlcclxuICAgICAgICAgICAgICAgIHBhcmVudEVsLmluc2VydEJlZm9yZShlQ29udGVudCwgYmVmb3JlTm9kZSk7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHBhcmVudEVsLmFwcGVuZENoaWxkKGVDb250ZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmQ7XHJcbiAgICAvL3JldHVybiB0aGlzO1xyXG59KTtcclxuZXh0KFwiZWxcIiwgZnVuY3Rpb24gKHRhZywgY29udGVudCkge1xyXG4gICAgdmFyIFQgPSB0aGlzO1xyXG4gICAgdmFyIG5lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xyXG4gICAgdmFyIG5Eb2MgPSBULl9fZG9jdW1lbnQgfHwgVC5fZ2V0TmV3RG9jdW1lbnQoKTtcclxuICAgIG5Eb2MuYXBwZW5kQ2hpbGQobmUpO1xyXG4gICAgaWYgKGNvbnRlbnQpXHJcbiAgICAgICAgVC5fYXBwZW5kT3JDcmVhdGVEb2N1bWVudChjb250ZW50LCBuZSk7XHJcbiAgICB2YXIgcmV0ID0gVC5fX2RvY3VtZW50ID09PSBuRG9jID8gVCA6IG5ldyBEb3REb2N1bWVudChuRG9jLCBULl9fY2xhc3NQcmVmaXgpO1xyXG4gICAgaWYgKGNvbnRlbnQgJiYgY29udGVudCBpbnN0YW5jZW9mIERvdERvY3VtZW50KVxyXG4gICAgICAgIGZvciAodmFyIGkgaW4gY29udGVudFtcIl9fY2xhc3NlZEVsZW1lbnRzXCJdKVxyXG4gICAgICAgICAgICByZXQuX19jbGFzc2VkRWxlbWVudHMucHVzaChjb250ZW50W1wiX19jbGFzc2VkRWxlbWVudHNcIl1baV0pO1xyXG4gICAgZG90W1wiX19zZWxlY3Rpb25Nb2RlXCJdID0gZXhwb3J0cy5BVFRSSUJVVEVfTU9ERTtcclxuICAgIHJldHVybiByZXQ7XHJcbn0pO1xyXG5leHQoXCJoXCIsIGZ1bmN0aW9uIChjb250ZW50KSB7XHJcbiAgICB2YXIgVCA9IHRoaXM7XHJcbiAgICB2YXIgaERvYyA9IFQuX2dldE5ld0RvY3VtZW50KCk7XHJcbiAgICB2YXIgaERvdCA9IG5ldyBEb3REb2N1bWVudChoRG9jLCBULl9fY2xhc3NQcmVmaXgpO1xyXG4gICAgLy9pZih0eXBlb2YgY29udGVudCA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgY29udGVudCA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgY29udGVudCA9PT0gXCJib29sZWFuXCIpIGhEb2MuaW5uZXJIVE1MID0gY29udGVudDsgLy9SYXcgZGF0YVxyXG4gICAgaERvdC5fYXBwZW5kT3JDcmVhdGVEb2N1bWVudChjb250ZW50KTtcclxuICAgIHZhciBuRG9jID0gVC5fX2RvY3VtZW50IHx8IFQuX2dldE5ld0RvY3VtZW50KCk7XHJcbiAgICB3aGlsZSAoaERvYy5jaGlsZE5vZGVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBuRG9jLmFwcGVuZENoaWxkKGhEb2MuY2hpbGROb2Rlc1swXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gVC5fX2RvY3VtZW50ID09PSBuRG9jID8gVCA6IG5ldyBEb3REb2N1bWVudChuRG9jLCBULl9fY2xhc3NQcmVmaXgpO1xyXG59KTtcclxuZXh0KFwidFwiLCBmdW5jdGlvbiAoY29udGVudCkge1xyXG4gICAgdmFyIHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY29udGVudCk7XHJcbiAgICB2YXIgbkRvYyA9IHRoaXMuX19kb2N1bWVudCB8fCB0aGlzLl9nZXROZXdEb2N1bWVudCgpO1xyXG4gICAgbkRvYy5hcHBlbmRDaGlsZCh0ZXh0Tm9kZSk7XHJcbiAgICByZXR1cm4gbmV3IERvdERvY3VtZW50KG5Eb2MsIHRoaXMuX19jbGFzc1ByZWZpeCk7XHJcbn0pO1xyXG5leHQoXCJhdHRyXCIsIGZ1bmN0aW9uIChhdHRyLCB2YWx1ZSwgYXJnMykge1xyXG4gICAgdmFyIFQgPSB0aGlzO1xyXG4gICAgaWYgKCgwLCBkb3RfdXRpbF8xLmlzRikodmFsdWUpKSB7IC8vIGV2ZW50cy5cclxuICAgICAgICBpZiAoYXR0ci5pbmRleE9mKFwib25cIikgPT0gMCAmJiBhbGxFdmVudEF0dHIuaW5kZXhPZihhdHRyKSAhPSAtMSkge1xyXG4gICAgICAgICAgICBhdHRyID0gYXR0ci5zdWJzdHJpbmcoMikudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFVucmVjb2duaXplZCBldmVudC5cclxuICAgICAgICAgICAgZG90W1wiX19hbm9uQXR0ckZ1bmNzXCJdW19hbm9uRnVuY0NvdW50ZXJdID0gKHZhbHVlKTtcclxuICAgICAgICAgICAgdmFsdWUgPSBcImRvdC5fX2Fub25BdHRyRnVuY3NbXCIgKyAoX2Fub25GdW5jQ291bnRlcisrKSArIFwiXShhcmd1bWVudHNbMF0pO1wiO1xyXG4gICAgICAgICAgICAvLyBhdHRyID0gYXR0ci5zdWJzdHJpbmcoMik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKFQuX19kb2N1bWVudCkge1xyXG4gICAgICAgIHZhciBjbiA9IFQuX19kb2N1bWVudC5jaGlsZE5vZGVzO1xyXG4gICAgICAgIHZhciBsYXN0ID0gY25bY24ubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgaWYgKGxhc3QgJiYgbGFzdC5zZXRBdHRyaWJ1dGUpIHtcclxuICAgICAgICAgICAgaWYgKCEoMCwgZG90X3V0aWxfMS5pc0YpKHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gT2JqZWN0cyAoZXhjZXB0IGZvciB0aGUgY3NzIGJ1aWxkZXIgOi8pXHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIHN0eWxlX2J1aWxkZXJfMS5fQnVpbGRlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb3JpZ2luYWxWYWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZVNldHRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0ciA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCBkb3RfdXRpbF8xLmVhY2hLKShvcmlnaW5hbFZhbHVlLCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdiA9ICgwLCBkb3RfdXRpbF8xLmlzRikodikgPyB2KCkgOiB2O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF2KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBcIiBcIiArIGs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyLnN1YnN0cmluZygxKTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIC8vZG90Ll9fY3VycmVudEFyZ0NhbGxiYWNrLnB1c2goe2Y6dmFsdWVTZXR0ZXIsZTpwYXJlbnRFbCxhOmF0dHJ9KVxyXG4gICAgICAgICAgICAgICAgICAgIGRvdFtcIl9fY3VycmVudEFyZ0NhbGxiYWNrXCJdLnB1c2gobmV3IGFyZ19jYWxsYmFja19vYmpfMS5BdHRyQXJnQ2FsbGJhY2sobGFzdCwgYXR0ciwgdmFsdWVTZXR0ZXIpKTtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlU2V0dGVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZG90W1wiX19jdXJyZW50QXJnQ2FsbGJhY2tcIl0ucG9wKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgZVZhbHVlID0gbGFzdC5nZXRBdHRyaWJ1dGUoYXR0cik7IC8vQXBwZW5kcyB0aGUgbmV3IHZhbHVlIHRvIGFueSBleGlzdGluZyB2YWx1ZS5cclxuICAgICAgICAgICAgICAgIGlmICghZVZhbHVlKVxyXG4gICAgICAgICAgICAgICAgICAgIGVWYWx1ZSA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgZVZhbHVlICs9IFwiIFwiO1xyXG4gICAgICAgICAgICAgICAgbGFzdC5zZXRBdHRyaWJ1dGUoYXR0ciwgZVZhbHVlICsgKHZhbHVlID09PSB1bmRlZmluZWQgPyBhdHRyIDogdmFsdWUpKTsgLy98fGF0dHIgaXMgZm9yIHNlbGYtZXhwbGFpbmluZyBhdHRyaWJ1dGVzXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBhdHRhY2hFdmVudChsYXN0LCBhdHRyLCB2YWx1ZSwgYXJnMyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBUT0RPOiBzaG91bGQgcHJvYmFibHkgcmVtb3ZlIHBlbmRpbmcgY2FsbHMuIFRoaXMgaGFzIHR1cm5lZCBvdXQgdG8gYmUgYW4gYW50aS1wYXR0ZXJuLlxyXG4gICAgICAgIHZhciBwRCA9IFQuX2dldEFuSW5zdGFuY2UoKTtcclxuICAgICAgICAvL2lmKCFwRC5fX3BlbmRpbmdDYWxscy5sZW5ndGggPiAwKSBwRC5fX3BlbmRpbmdDYWxscyA9IFtdO1xyXG4gICAgICAgIHBELl9fcGVuZGluZ0NhbGxzLnB1c2goeyB0eXBlOiBcImF0dHJcIiwgbmFtZTogYXR0ciwgcGFyYW1zOiBbdmFsdWVdLCBhcmczOiBhcmczIH0pO1xyXG4gICAgICAgIHJldHVybiBwRDtcclxuICAgIH1cclxuICAgIHJldHVybiBUO1xyXG59KTtcclxuZXh0KFwiX2FwcGVuZFNldEVsZW1lbnRcIiwgZnVuY3Rpb24gKHRhcmdldElkLCBhcHBlbmRNb2RlKSB7XHJcbiAgICB2YXIgVCA9IHRoaXM7XHJcbiAgICBpZiAoIXRhcmdldElkKSB7XHJcbiAgICAgICAgKDAsIGVycl8xLmRlZmF1bHQpKFwiQVwiLCB0YXJnZXRJZCk7XHJcbiAgICAgICAgcmV0dXJuIFQ7XHJcbiAgICB9XHJcbiAgICB2YXIgZGVzdGluYXRpb24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0YXJnZXRJZCk7XHJcbiAgICBpZiAoIWRlc3RpbmF0aW9uKSB7XHJcbiAgICAgICAgKDAsIGVycl8xLmRlZmF1bHQpKFwiRlwiLCB0YXJnZXRJZCk7XHJcbiAgICAgICAgcmV0dXJuIFQ7XHJcbiAgICB9XHJcbiAgICBpZiAoVC5fX2RvY3VtZW50KSB7XHJcbiAgICAgICAgaWYgKCFhcHBlbmRNb2RlKVxyXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5pbm5lckhUTUwgPSBcIlwiO1xyXG4gICAgICAgIHdoaWxlIChULl9fZG9jdW1lbnQuY2hpbGROb2Rlcy5sZW5ndGggPiAwKVxyXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5hcHBlbmRDaGlsZChULl9fZG9jdW1lbnQuY2hpbGROb2Rlc1swXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gVDtcclxufSk7XHJcbmV4dChcIml0ZXJhdGVcIiwgZnVuY3Rpb24gKGl0ZXJhdGlvbnMsIGNhbGxiYWNrKSB7XHJcbiAgICB2YXIgdGFyZ2V0ID0gdGhpcztcclxuICAgIC8vIHZhciBjb3B5Y29udGVudCA9IG51bGw7XHJcbiAgICAvLyBOb3Qgc3VyZSB3aGF0IHRoaXMgd2FzIHVzZWQgZm9yIGJlZm9yZSB0aGUgVFMgcG9ydC5cclxuICAgIC8vIHZhciBjb250ZW50ID0gY2FsbGJhY2s7XHJcbiAgICAvLyBpZihjb250ZW50IGluc3RhbmNlb2YgRG90RG9jdW1lbnQpIHtcclxuICAgIC8vIFx0Y29weWNvbnRlbnQgPSBjb250ZW50Ll9fZG9jdW1lbnQuY2xvbmVOb2RlKHRydWUpO1xyXG4gICAgLy8gfVxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVyYXRpb25zOyBpKyspIHtcclxuICAgICAgICBsZXQgY29udGVudCA9IG51bGw7XHJcbiAgICAgICAgaWYgKCgwLCBkb3RfdXRpbF8xLmlzRikoY2FsbGJhY2spKVxyXG4gICAgICAgICAgICBjb250ZW50ID0gY2FsbGJhY2soaSk7XHJcbiAgICAgICAgLy8gaWYoY29weWNvbnRlbnQpIGNvbnRlbnQuX19kb2N1bWVudCA9IGNvcHljb250ZW50LmNsb25lTm9kZSh0cnVlKTtcclxuICAgICAgICB0YXJnZXQgPSB0YXJnZXQuX2FwcGVuZE9yQ3JlYXRlRG9jdW1lbnQoY29udGVudCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGFyZ2V0O1xyXG59KTtcclxuZXh0KFwiZWFjaFwiLCBmdW5jdGlvbiAoYXJyYXksIGNhbGxiYWNrLCBmb3JjZU5vRGVmZXJyZWQpIHtcclxuICAgIHZhciB0YXJnZXQgPSB0aGlzO1xyXG4gICAgaWYgKCgwLCBkb3RfdXRpbF8xLmlzRikoYXJyYXkpKSB7XHJcbiAgICAgICAgaWYgKCFmb3JjZU5vRGVmZXJyZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5kZWZlcihmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgdi5lYWNoKGFycmF5LCBjYWxsYmFjaywgdHJ1ZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLl9fZG9jdW1lbnQpO1xyXG4gICAgICAgIHZhciBmdW5jID0gYXJyYXk7XHJcbiAgICAgICAgLy90YXJnZXQgPSB0YXJnZXQuX2FwcGVuZE9yQ3JlYXRlRG9jdW1lbnQoKTtcclxuICAgICAgICAvLyBkb3QuX19jdXJyZW50QXJnQ2FsbGJhY2sucHVzaCh7ZjpjYWxsYmFjayxkOnRhcmdldH0pOyBcclxuICAgICAgICBkb3RbXCJfX2N1cnJlbnRBcmdDYWxsYmFja1wiXS5wdXNoKG5ldyBhcmdfY2FsbGJhY2tfb2JqXzEuQXJyYXlBcmdDYWxsYmFjayh0YXJnZXQsIGNhbGxiYWNrKSk7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgYXJyYXkgPSBmdW5jKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICBkb3RbXCJfX2N1cnJlbnRBcmdDYWxsYmFja1wiXS5wb3AoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoYXJyYXkgaW5zdGFuY2VvZiBBcnJheSB8fCBhcnJheSBpbnN0YW5jZW9mIG9ic2VydmFibGVfYXJyYXlfMS5kZWZhdWx0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQuX2FwcGVuZE9yQ3JlYXRlRG9jdW1lbnQoY2FsbGJhY2soYXJyYXlbaV0sIGkpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFycmF5KTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGsgPSBrZXlzW2ldO1xyXG4gICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQuX2FwcGVuZE9yQ3JlYXRlRG9jdW1lbnQoY2FsbGJhY2soYXJyYXlba10sIGspKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGFyZ2V0O1xyXG59KTtcclxuLy9TVkdcclxuLy9fcC5zdmcgPSBmdW5jdGlvbigpe0VSUihcIlNcIil9O1xyXG4vL0RhdGEgaXMgYSBzcGVjaWFsIGF0dHJpYnV0ZS5cclxuX3AuY3VzdG9tRGF0YSA9IGZ1bmN0aW9uIChzdWZmaXgsIHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdGhpcy5hdHRyKFwiZGF0YS1cIiArIHN1ZmZpeCwgdmFsdWUpO1xyXG59O1xyXG5fcC5jbGFzcyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgdmFyIGNwID0gdGhpcy5fX2NsYXNzUHJlZml4O1xyXG4gICAgLy8gVGhpcyBoYW5kbGVzIGxlZ2l0aW1hdGUgY2xhc3MgcHJlZml4ZXMuIElmIHdlIGFyZSBkZWFsaW5nIHdpdGggYSBjb21wdGVkIGNsYXNzIGxpc3QsIGVhY2ggY2xhc3MgbGlzdCBuYW1lIGlzIHByZWZpeGVkLlxyXG4gICAgaWYgKGNwKSB7XHJcbiAgICAgICAgdmFyIHByZWZpeCA9IFwiZG90LVwiICsgKDAsIGRvdF91dGlsXzEuc3RyKShjcCwgMTYpICsgXCItXCI7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiKVxyXG4gICAgICAgICAgICB2YWx1ZSA9IHByZWZpeCArIHZhbHVlO1xyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgICAgIHZhciB2MiA9IHt9O1xyXG4gICAgICAgICAgICAoMCwgZG90X3V0aWxfMS5lYWNoSykodmFsdWUsIGZ1bmN0aW9uIChrLCB2KSB7XHJcbiAgICAgICAgICAgICAgICB2MltwcmVmaXggKyBrXSA9IHY7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB2YWx1ZSA9IHYyO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZhciBlbCA9IHRoaXMuZ2V0TGFzdCgpO1xyXG4gICAgICAgIGVsICYmIHRoaXMuX19jbGFzc2VkRWxlbWVudHMucHVzaChlbCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5hdHRyKFwiY2xhc3NcIiwgdmFsdWUpO1xyXG59O1xyXG5fcC5wbGF5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgbGV0IGxhc3QgPSB0aGlzLmdldEN1cnJlbnQoKTtcclxuICAgIGxhc3QucGxheSAmJiBsYXN0LnBsYXkoKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5fcC5wYXVzZSA9IGZ1bmN0aW9uIChyZXNldFRpbWUpIHtcclxuICAgIGxldCBsYXN0ID0gdGhpcy5nZXRDdXJyZW50KCk7XHJcbiAgICBsYXN0LnBhdXNlICYmIGxhc3QucGF1c2UoKTtcclxuICAgIGlmIChyZXNldFRpbWUpXHJcbiAgICAgICAgbGFzdC5jdXJyZW50VGltZSA9IDA7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuX3Auc3RvcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB0aGlzLnBhdXNlKHRydWUpO1xyXG59O1xyXG4vKipcclxuICogU2V0cyB0aGUgdmFsdWUgb2YgYW4gaW5wdXQgb3IgdGV4dGVyZWEuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBiZSBzZXQuXHJcbiAqL1xyXG5fcC5zZXRWYWwgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgIGxldCBsYXN0ID0gdGhpcy5nZXRDdXJyZW50KCk7XHJcbiAgICBpZiAoIWxhc3QpXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAvLyBjb25zb2xlLmxvZyhcIkNIRUNLVkFMVUVcIiwgdmFsdWUpO1xyXG4gICAgLy9pZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiApIHZhbCArPSBcIlwiO1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgIUFycmF5LmlzQXJyYXkgJiYgdmFsdWUuam9pbikge1xyXG4gICAgICAgIHZhbHVlID0gdmFsdWUuam9pbihcIlwiKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHZhbHVlID09IG51bGwpIHtcclxuICAgICAgICB2YWx1ZSA9IFwiXCI7XHJcbiAgICB9XHJcbiAgICBpZiAobGFzdC50eXBlID09IFwiY2hlY2tib3hcIikge1xyXG4gICAgICAgIGxhc3QuY2hlY2tlZCA9IHZhbHVlID8gdHJ1ZSA6IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobGFzdC50eXBlID09IFwicmFkaW9cIikge1xyXG4gICAgICAgIGxhc3QuY2hlY2tlZCA9IHZhbHVlID8gdHJ1ZSA6IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobGFzdC50YWdOYW1lID09IFwiT1BUSU9OXCIpIHtcclxuICAgICAgICBsYXN0LnNlbGVjdGVkID0gdmFsdWUgPyB0cnVlIDogZmFsc2U7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIlVQREFUSU5HIFZBTFVFISFcIiwgdmFsdWUsIGxhc3QsIGxhc3QudmFsdWUpO1xyXG4gICAgICAgIGxhc3QudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIlVQREFURUQhIVwiLCB2YWx1ZSwgbGFzdCwgbGFzdC52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuX3AuZ2V0VmFsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGVsZW1lbnQgPSB0aGlzLl9fbGFzdE5vZGUgfHwgdGhpcy5fX2RvY3VtZW50O1xyXG4gICAgaWYgKCFlbGVtZW50IHx8IGVsZW1lbnQubm9kZVR5cGUgIT09IDEpXHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIGlmIChlbGVtZW50W1widHlwZVwiXSA9PSBcImNoZWNrYm94XCIpIHtcclxuICAgICAgICByZXR1cm4gZWxlbWVudFtcImNoZWNrZWRcIl0gPyB0cnVlIDogZmFsc2U7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChlbGVtZW50W1widHlwZVwiXSA9PSBcInJhZGlvXCIpIHtcclxuICAgICAgICByZXR1cm4gZWxlbWVudFtcImNoZWNrZWRcIl0gPyB0cnVlIDogZmFsc2U7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChlbGVtZW50LnRhZ05hbWUgPT0gXCJPUFRJT05cIikge1xyXG4gICAgICAgIHJldHVybiBlbGVtZW50W1wic2VsZWN0ZWRcIl0gPyB0cnVlIDogZmFsc2U7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gZWxlbWVudFtcInZhbHVlXCJdO1xyXG4gICAgfVxyXG59O1xyXG5leHQoXCJ3aGVuXCIsIGZ1bmN0aW9uIChjb25kaXRpb24sIGNvbnRlbnRDYWxsYmFjaywgYXIpIHtcclxuICAgIHZhciBUID0gdGhpcy5fZ2V0QW5JbnN0YW5jZSgpO1xyXG4gICAgaWYgKCgwLCBkb3RfdXRpbF8xLmlzRikoY29uZGl0aW9uKSkge1xyXG4gICAgICAgIGlmICghYXIpXHJcbiAgICAgICAgICAgIGFyID0gVC5fX2NvbmRpdGlvbmFsQXJyYXkgPSBbY29uZGl0aW9uXTtcclxuICAgICAgICB2YXIgbCA9IGFyLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgdmFyIHRvdGFsQ29uZGl0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCEhYXJbaV0oKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gISFjb25kaXRpb24oKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFQgPSBfY29uZGl0aW9uYWxCbG9jayhULCB0b3RhbENvbmRpdGlvbiwgYXIsIGNvbnRlbnRDYWxsYmFjayk7XHJcbiAgICAgICAgLy8gYXIucHVzaChjb25kaXRpb24pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gT2xkOlxyXG4gICAgICAgIGlmICghIWNvbmRpdGlvbikge1xyXG4gICAgICAgICAgICBUID0gVC5fYXBwZW5kT3JDcmVhdGVEb2N1bWVudCgoMCwgZG90X3V0aWxfMS5pc0YpKGNvbnRlbnRDYWxsYmFjaykgPyBjb250ZW50Q2FsbGJhY2soKSA6IGNvbnRlbnRDYWxsYmFjayk7XHJcbiAgICAgICAgICAgIFQuX19pZiA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBULl9faWYgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gVDtcclxufSk7XHJcbmV4dChcIm90aGVyd2lzZVdoZW5cIiwgZnVuY3Rpb24gKGNvbmRpdGlvbiwgY2FsbGJhY2spIHtcclxuICAgIGlmICgoMCwgZG90X3V0aWxfMS5pc0YpKGNvbmRpdGlvbikpIHtcclxuICAgICAgICB2YXIgYXIgPSB0aGlzLl9fY29uZGl0aW9uYWxBcnJheTtcclxuICAgICAgICBpZiAoIWFyKVxyXG4gICAgICAgICAgICAoMCwgZXJyXzEuZGVmYXVsdCkoXCJNQ1wiKTtcclxuICAgICAgICAvL3ZhciBsID0gYXIubGVuZ3RoIC0gMTtcclxuICAgICAgICAvLyB2YXIgbmV3Q29uZGl0aW9uID0gZnVuY3Rpb24oKXtcclxuICAgICAgICAvLyBcdGZvcih2YXIgaSA9IDA7IGkgPD0gbDsgaSsrKXtcclxuICAgICAgICAvLyBcdFx0aWYoYXJbaV0oKSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIC8vIFx0fVxyXG4gICAgICAgIC8vIFx0cmV0dXJuICEhY29uZGl0aW9uKCk7XHJcbiAgICAgICAgLy8gfVxyXG4gICAgICAgIGFyLnB1c2goY29uZGl0aW9uKTtcclxuICAgICAgICByZXR1cm4gdGhpcy53aGVuKGNvbmRpdGlvbiwgY2FsbGJhY2ssIGFyKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmICghdGhpcy5fX2lmKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndoZW4oY29uZGl0aW9uLCBjYWxsYmFjayk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn0pO1xyXG5leHQoXCJvdGhlcndpc2VcIiwgZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICB2YXIgYXIgPSB0aGlzLl9fY29uZGl0aW9uYWxBcnJheTtcclxuICAgIGlmIChhcikge1xyXG4gICAgICAgIC8vdmFyIGwgPSBhci5sZW5ndGggLSAxO1xyXG4gICAgICAgIHZhciBuZXdDb25kaXRpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgYXIucHVzaChuZXdDb25kaXRpb24pO1xyXG4gICAgICAgIHJldHVybiB0aGlzLndoZW4obmV3Q29uZGl0aW9uLCBjYWxsYmFjaywgYXIpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoIXRoaXMuX19pZikge1xyXG4gICAgICAgIHRoaXMuX19pZiA9IG51bGw7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldEFuSW5zdGFuY2UoKS5fYXBwZW5kT3JDcmVhdGVEb2N1bWVudChjYWxsYmFjayk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxufSk7XHJcbmV4dChcInNjcmlwdFwiLCBmdW5jdGlvbiAoY2FsbGJhY2spIHtcclxuICAgIHZhciBsYXN0ID0gdGhpcy5nZXRMYXN0KCk7XHJcbiAgICAoMCwgZG90X3V0aWxfMS5zVCkoZnVuY3Rpb24gKCkgeyBjYWxsYmFjayhsYXN0KTsgfSwgMCk7XHJcbiAgICByZXR1cm4gdGhpcztcclxufSk7XHJcbmV4dChcIndhaXRcIiwgZnVuY3Rpb24gKHRpbWVvdXQsIGNhbGxiYWNrKSB7XHJcbiAgICB2YXIgdGltZW91dERvdCA9IHRoaXMuZWwoREVGRUwpO1xyXG4gICAgdmFyIHRpbWVvdXROb2RlID0gdGltZW91dERvdC5fX2RvY3VtZW50Lmxhc3RDaGlsZDtcclxuICAgICgwLCBkb3RfdXRpbF8xLnNUKSgoKSA9PiB7XHJcbiAgICAgICAgdGltZW91dERvdC5fYXBwZW5kT3JDcmVhdGVEb2N1bWVudChjYWxsYmFjaywgbnVsbCwgdGltZW91dE5vZGUpO1xyXG4gICAgICAgIHRpbWVvdXROb2RlLnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQodGltZW91dE5vZGUpO1xyXG4gICAgfSwgdGltZW91dCk7XHJcbiAgICByZXR1cm4gdGltZW91dERvdDtcclxuICAgIC8vIElkZWFsbHkgc29tZXRoaW5nIGxpa2UgdGhpczpcclxuICAgIC8vcmV0dXJuIHRoaXMuZGVmZXIoZnVuY3Rpb24oZCl7ZC5oKGNhbGxiYWNrKX0sIHRpbWVvdXQpO1xyXG59KTtcclxuZXh0KFwiZGVmZXJcIiwgZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICBpZiAoISgwLCBkb3RfdXRpbF8xLmlzRikoY2FsbGJhY2spKVxyXG4gICAgICAgICgwLCBlcnJfMS5kZWZhdWx0KShcIlhGXCIsIFwiZGVmZXJcIik7XHJcbiAgICB2YXIgZGVmZXJEb3QgPSB0aGlzLmVsKERFRkVMKTtcclxuICAgIHZhciBkZWZlck5vZGUgPSBkZWZlckRvdC5fX2RvY3VtZW50Lmxhc3RDaGlsZDtcclxuICAgICgwLCBkb3RfdXRpbF8xLnNUKSgoKSA9PiB7XHJcbiAgICAgICAgY2FsbGJhY2soZG90KGRlZmVyTm9kZS5wYXJlbnRFbGVtZW50KSk7XHJcbiAgICAgICAgZGVmZXJOb2RlLnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoZGVmZXJOb2RlKTtcclxuICAgIH0sIDApO1xyXG4gICAgcmV0dXJuIGRlZmVyRG90O1xyXG59KTtcclxuZXh0KFwiZW1wdHlcIiwgZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKHRoaXMuX19kb2N1bWVudCkge1xyXG4gICAgICAgIC8vIEJ1aWxkIGEgcXVldWUgb2YgaXRlbXMgdG8gcmVtb3ZlLlxyXG4gICAgICAgIHZhciBxdWV1ZSA9IFt0aGlzLl9fZG9jdW1lbnRdO1xyXG4gICAgICAgIHZhciBmaXJzdFEgPSB0cnVlO1xyXG4gICAgICAgIHZhciBzdGFjayA9IFtdO1xyXG4gICAgICAgIHdoaWxlIChxdWV1ZS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHZhciBjdXJyZW50ID0gcXVldWUuc2hpZnQoKTtcclxuICAgICAgICAgICAgaWYgKGN1cnJlbnQuY2hpbGROb2Rlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGN1cnJlbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2goY3VycmVudC5jaGlsZE5vZGVzW2ldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAhZmlyc3RRICYmIHN0YWNrLnB1c2goY3VycmVudCk7XHJcbiAgICAgICAgICAgIGZpcnN0USA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBkZWxldGVFbGVtZW50KHN0YWNrLnBvcCgpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBEcm9wIGFsbCB0aGUgb3RoZXIgbm9kZXMgKGxpa2UgdGV4dClcclxuICAgIC8vIFRleHQgc2VlbXMgdG8gZ2V0IGRlbGV0ZWQgZXZlbiB3aXRob3V0IHRoaXMgY29kZSA6KS5cclxuICAgIC8vd2hpbGUgKHRoaXMuX19kb2N1bWVudC5maXJzdENoaWxkKSB7XHJcbiAgICAvL1x0dGhpcy5fX2RvY3VtZW50LnJlbW92ZUNoaWxkKHRoaXMuX19kb2N1bWVudC5maXJzdENoaWxkKTtcclxuICAgIC8vfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn0pO1xyXG5leHQoXCJyZW1vdmVcIiwgZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5lbXB0eSgpO1xyXG4gICAgZGVsZXRlRWxlbWVudCh0aGlzLl9fZG9jdW1lbnQpO1xyXG59KTtcclxuZXh0KFwic2NvcGVDbGFzc1wiLCBmdW5jdGlvbiAocHJlZml4LCBjb250ZW50KSB7XHJcbiAgICBpZiAocHJlZml4ID09IG51bGwpIHtcclxuICAgICAgICBwcmVmaXggPSBkb3RfdXRpbF8xLkNsYXNzUHJlZml4Lm5leHQ7XHJcbiAgICB9XHJcbiAgICB2YXIgVCA9IHRoaXM7XHJcbiAgICAvL1QuX19jbGFzc1ByZWZpeCA9IHByZWZpeCB8fCBjbGFzc1ByZWZpeC5uZXh0O1xyXG4gICAgLy9kb2MuX19vbGRDbGFzc1ByZWZpeC5wdXNoKHByZWZpeCk7XHJcbiAgICBULl9fY2xhc3NQcmVmaXggPSBwcmVmaXg7XHJcbiAgICB2YXIgcmV0ID0gVC5oKGNvbnRlbnQpO1xyXG4gICAgVC5fX2NsYXNzUHJlZml4ID0gMDtcclxuICAgIC8vZG9jLl9fb2xkQ2xhc3NQcmVmaXgucG9wKCk7XHJcbiAgICAvL1QuX19jbGFzc1ByZWZpeCA9IG9sZENwO1xyXG4gICAgcmV0dXJuIHJldDtcclxufSk7XHJcbl9wLmJpbmRUbyA9IGZ1bmN0aW9uIChwcm9wKSB7XHJcbiAgICBsZXQgbGFzdFByb3AgPSBkb3RbXCJfX2xhc3RQcm9wXCJdO1xyXG4gICAgbGV0IGxhc3RJbmRleCA9IGRvdFtcIl9fbGFzdEluZGV4XCJdO1xyXG4gICAgbGV0IGxhc3RDb21wb25lbnQgPSBkb3RbXCJfX2xhc3RDb21wb25lbnRcIl07XHJcbiAgICBsZXQgbGFzdCA9IHRoaXMuZ2V0TGFzdCgpO1xyXG4gICAgLy92YXIgbm9MaXN0ZW5lciA9IHRydWU7XHJcbiAgICBsZXQgX3ZhbHVlID0gbGFzdENvbXBvbmVudC5wcm9wc1tsYXN0UHJvcF07XHJcbiAgICBpZiAobGFzdEluZGV4ICE9IG51bGwgJiYgbGFzdEluZGV4ICE9IHVuZGVmaW5lZClcclxuICAgICAgICBfdmFsdWUgPSBfdmFsdWVbbGFzdEluZGV4XTtcclxuICAgIGxldCByZXQgPSB0aGlzLnNldFZhbChfdmFsdWUpO1xyXG4gICAgLy8gQmluZGluZyBmcm9tIHRoZSBpbnB1dCB0byB0aGUgcHJvcC5cclxuICAgIGF0dGFjaEV2ZW50KGxhc3QsIFwiY2hhbmdlXCIsIGZ1bmN0aW9uIChlKSB7IGxhc3RDb21wb25lbnQucHJvcHNbbGFzdFByb3BdID0gZG90KGxhc3QpLmFzKGRvdC5pbnB1dCkuZ2V0VmFsKCk7IH0pO1xyXG4gICAgbGFzdENvbXBvbmVudFtcIl9fcHJvcENvbnRhaW5lclwiXS5iaW5kaW5nc1tsYXN0UHJvcF0ucHVzaCh7XHJcbiAgICAgICAgZWxlbWVudDogbGFzdFxyXG4gICAgfSk7XHJcbiAgICAvL3ZhciBub0xpc3RlbmVyID0gZmFsc2U7XHJcbiAgICByZXR1cm4gcmV0O1xyXG59O1xyXG4vLyBleHQoXCJyZXNldFNjb3BlQ2xhc3NcIiwgZnVuY3Rpb24oKXtcclxuLy8gXHRDbGFzc1ByZWZpeC5yZXNldCgpO1xyXG4vLyB9KTtcclxuZG90LnJlc2V0U2NvcGVDbGFzcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGRvdF91dGlsXzEuQ2xhc3NQcmVmaXgucmVzZXQoKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG4vLyBfcC5iaW5kVG8gPSBmdW5jdGlvbihiaW5kaW5nKXtcclxuLy8gXHR2YXIgbGFzdCA9IHRoaXMuZ2V0TGFzdCgpO1xyXG4vLyBcdC8vdmFyIG5vTGlzdGVuZXIgPSB0cnVlO1xyXG4vLyBcdHZhciByZXQgPSB0aGlzLnNldFZhbChiaW5kaW5nLnZhbHVlKTtcclxuLy8gXHRhdHRhY2hFdmVudChsYXN0LCBcImNoYW5nZVwiLCBmdW5jdGlvbihlKXtiaW5kaW5nLnZhbHVlID0gdGhpcy5nZXRWYWwoKTt9KVxyXG4vLyBcdGJpbmRpbmcuc3Vic2NyaWJlKGxhc3QpO1xyXG4vLyBcdC8vdmFyIG5vTGlzdGVuZXIgPSBmYWxzZTtcclxuLy8gXHRyZXR1cm4gcmV0O1xyXG4vLyB9XHJcbi8vIGV4cG9ydCBEb3REb2N1bWVudDtcclxuZG90LmNzcyA9IHN0eWxlX2J1aWxkZXJfMS5kZWZhdWx0O1xyXG5kb3QuYnVzID0gZXZlbnRfYnVzXzEuZGVmYXVsdDtcclxuLy8gZG90LmNvbXBvbmVudCA9IGFkZENvbXBvbmVudDtcclxuLy8gVE9ETzogbWlnaHQgcmVtb3ZlIHRoaXMgaW4gdjQrXHJcbi8vIGRvdC5yZW1vdmVDb21wb25lbnQgPSByZW1vdmVDb21wb25lbnQ7XHJcbi8vRmlsbCBpbiBhbGwgdGhlIG90aGVyIGZpZWxkcy5cclxuLy9pZihPYmplY3QuY3JlYXRlKSBkb3QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShfcCk7XHJcbi8vIGRvdC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBkb3Q7XHJcbmRvdFtcIl9fY3VycmVudEFyZ0NhbGxiYWNrXCJdID0gW107XHJcbmRvdFtcIl9fZG9jdW1lbnRcIl0gPSBudWxsO1xyXG5kb3RbXCJfX2lmXCJdID0gbnVsbDtcclxuZG90W1wiX19wZW5kaW5nQ2FsbHNcIl0gPSBbXTtcclxuZG90W1wiX19hbm9uQXR0ckZ1bmNzXCJdID0ge307XHJcbi8vIFRPRE86IHRoZXNlIG1heSBhbHJlYWR5IGV4aXN0P1xyXG4vL2RvdC5kYXRhID0gRG90RG9jdW1lbnQucHJvdG90eXBlLmRhdGE7XHJcbi8vZG90LmRhdGFBID0gRG90RG9jdW1lbnQucHJvdG90eXBlLmRhdGFBO1xyXG4vL2RvdC5jaXRlID0gRG90RG9jdW1lbnQucHJvdG90eXBlLmNpdGU7XHJcbi8vZG90LmZvcm0gPSBEb3REb2N1bWVudC5wcm90b3R5cGUuZm9ybTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gZG90O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kb3QuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9