"use strict";
(self["webpackChunkwedding_website"] = self["webpackChunkwedding_website"] || []).push([["vendors-node_modules_pixi_mesh-extras_lib_index_js"],{

/***/ "./node_modules/@pixi/mesh-extras/lib/NineSlicePlane.js":
/*!**************************************************************!*\
  !*** ./node_modules/@pixi/mesh-extras/lib/NineSlicePlane.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js");
var SimplePlane = __webpack_require__(/*! ./SimplePlane.js */ "./node_modules/@pixi/mesh-extras/lib/SimplePlane.js");

const DEFAULT_BORDER_SIZE = 10;
class NineSlicePlane extends SimplePlane.SimplePlane {
  constructor(texture, leftWidth, topHeight, rightWidth, bottomHeight) {
    super(core.Texture.WHITE, 4, 4);
    this._origWidth = texture.orig.width;
    this._origHeight = texture.orig.height;
    this._width = this._origWidth;
    this._height = this._origHeight;
    this._leftWidth = leftWidth ?? texture.defaultBorders?.left ?? DEFAULT_BORDER_SIZE;
    this._rightWidth = rightWidth ?? texture.defaultBorders?.right ?? DEFAULT_BORDER_SIZE;
    this._topHeight = topHeight ?? texture.defaultBorders?.top ?? DEFAULT_BORDER_SIZE;
    this._bottomHeight = bottomHeight ?? texture.defaultBorders?.bottom ?? DEFAULT_BORDER_SIZE;
    this.texture = texture;
  }
  textureUpdated() {
    this._textureID = this.shader.texture._updateID;
    this._refresh();
  }
  get vertices() {
    return this.geometry.getBuffer("aVertexPosition").data;
  }
  set vertices(value) {
    this.geometry.getBuffer("aVertexPosition").data = value;
  }
  updateHorizontalVertices() {
    const vertices = this.vertices;
    const scale = this._getMinScale();
    vertices[9] = vertices[11] = vertices[13] = vertices[15] = this._topHeight * scale;
    vertices[17] = vertices[19] = vertices[21] = vertices[23] = this._height - this._bottomHeight * scale;
    vertices[25] = vertices[27] = vertices[29] = vertices[31] = this._height;
  }
  updateVerticalVertices() {
    const vertices = this.vertices;
    const scale = this._getMinScale();
    vertices[2] = vertices[10] = vertices[18] = vertices[26] = this._leftWidth * scale;
    vertices[4] = vertices[12] = vertices[20] = vertices[28] = this._width - this._rightWidth * scale;
    vertices[6] = vertices[14] = vertices[22] = vertices[30] = this._width;
  }
  _getMinScale() {
    const w = this._leftWidth + this._rightWidth;
    const scaleW = this._width > w ? 1 : this._width / w;
    const h = this._topHeight + this._bottomHeight;
    const scaleH = this._height > h ? 1 : this._height / h;
    const scale = Math.min(scaleW, scaleH);
    return scale;
  }
  get width() {
    return this._width;
  }
  set width(value) {
    this._width = value;
    this._refresh();
  }
  get height() {
    return this._height;
  }
  set height(value) {
    this._height = value;
    this._refresh();
  }
  get leftWidth() {
    return this._leftWidth;
  }
  set leftWidth(value) {
    this._leftWidth = value;
    this._refresh();
  }
  get rightWidth() {
    return this._rightWidth;
  }
  set rightWidth(value) {
    this._rightWidth = value;
    this._refresh();
  }
  get topHeight() {
    return this._topHeight;
  }
  set topHeight(value) {
    this._topHeight = value;
    this._refresh();
  }
  get bottomHeight() {
    return this._bottomHeight;
  }
  set bottomHeight(value) {
    this._bottomHeight = value;
    this._refresh();
  }
  _refresh() {
    const texture = this.texture;
    const uvs = this.geometry.buffers[1].data;
    this._origWidth = texture.orig.width;
    this._origHeight = texture.orig.height;
    const _uvw = 1 / this._origWidth;
    const _uvh = 1 / this._origHeight;
    uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;
    uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;
    uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;
    uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;
    uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;
    uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - _uvw * this._rightWidth;
    uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;
    uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - _uvh * this._bottomHeight;
    this.updateHorizontalVertices();
    this.updateVerticalVertices();
    this.geometry.buffers[0].update();
    this.geometry.buffers[1].update();
  }
}

exports.NineSlicePlane = NineSlicePlane;
//# sourceMappingURL=NineSlicePlane.js.map


/***/ }),

/***/ "./node_modules/@pixi/mesh-extras/lib/SimpleMesh.js":
/*!**********************************************************!*\
  !*** ./node_modules/@pixi/mesh-extras/lib/SimpleMesh.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js");
var mesh = __webpack_require__(/*! @pixi/mesh */ "./node_modules/@pixi/mesh/lib/index.js");

class SimpleMesh extends mesh.Mesh {
  constructor(texture = core.Texture.EMPTY, vertices, uvs, indices, drawMode) {
    const geometry = new mesh.MeshGeometry(vertices, uvs, indices);
    geometry.getBuffer("aVertexPosition").static = false;
    const meshMaterial = new mesh.MeshMaterial(texture);
    super(geometry, meshMaterial, null, drawMode);
    this.autoUpdate = true;
  }
  get vertices() {
    return this.geometry.getBuffer("aVertexPosition").data;
  }
  set vertices(value) {
    this.geometry.getBuffer("aVertexPosition").data = value;
  }
  _render(renderer) {
    if (this.autoUpdate) {
      this.geometry.getBuffer("aVertexPosition").update();
    }
    super._render(renderer);
  }
}

exports.SimpleMesh = SimpleMesh;
//# sourceMappingURL=SimpleMesh.js.map


/***/ }),

/***/ "./node_modules/@pixi/mesh-extras/lib/SimplePlane.js":
/*!***********************************************************!*\
  !*** ./node_modules/@pixi/mesh-extras/lib/SimplePlane.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js");
var mesh = __webpack_require__(/*! @pixi/mesh */ "./node_modules/@pixi/mesh/lib/index.js");
var PlaneGeometry = __webpack_require__(/*! ./geometry/PlaneGeometry.js */ "./node_modules/@pixi/mesh-extras/lib/geometry/PlaneGeometry.js");

class SimplePlane extends mesh.Mesh {
  constructor(texture, verticesX, verticesY) {
    const planeGeometry = new PlaneGeometry.PlaneGeometry(texture.width, texture.height, verticesX, verticesY);
    const meshMaterial = new mesh.MeshMaterial(core.Texture.WHITE);
    super(planeGeometry, meshMaterial);
    this.texture = texture;
    this.autoResize = true;
  }
  textureUpdated() {
    this._textureID = this.shader.texture._updateID;
    const geometry = this.geometry;
    const { width, height } = this.shader.texture;
    if (this.autoResize && (geometry.width !== width || geometry.height !== height)) {
      geometry.width = this.shader.texture.width;
      geometry.height = this.shader.texture.height;
      geometry.build();
    }
  }
  set texture(value) {
    if (this.shader.texture === value) {
      return;
    }
    this.shader.texture = value;
    this._textureID = -1;
    if (value.baseTexture.valid) {
      this.textureUpdated();
    } else {
      value.once("update", this.textureUpdated, this);
    }
  }
  get texture() {
    return this.shader.texture;
  }
  _render(renderer) {
    if (this._textureID !== this.shader.texture._updateID) {
      this.textureUpdated();
    }
    super._render(renderer);
  }
  destroy(options) {
    this.shader.texture.off("update", this.textureUpdated, this);
    super.destroy(options);
  }
}

exports.SimplePlane = SimplePlane;
//# sourceMappingURL=SimplePlane.js.map


/***/ }),

/***/ "./node_modules/@pixi/mesh-extras/lib/SimpleRope.js":
/*!**********************************************************!*\
  !*** ./node_modules/@pixi/mesh-extras/lib/SimpleRope.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js");
var mesh = __webpack_require__(/*! @pixi/mesh */ "./node_modules/@pixi/mesh/lib/index.js");
var RopeGeometry = __webpack_require__(/*! ./geometry/RopeGeometry.js */ "./node_modules/@pixi/mesh-extras/lib/geometry/RopeGeometry.js");

class SimpleRope extends mesh.Mesh {
  constructor(texture, points, textureScale = 0) {
    const ropeGeometry = new RopeGeometry.RopeGeometry(texture.height, points, textureScale);
    const meshMaterial = new mesh.MeshMaterial(texture);
    if (textureScale > 0) {
      texture.baseTexture.wrapMode = core.WRAP_MODES.REPEAT;
    }
    super(ropeGeometry, meshMaterial);
    this.autoUpdate = true;
  }
  _render(renderer) {
    const geometry = this.geometry;
    if (this.autoUpdate || geometry._width !== this.shader.texture.height) {
      geometry._width = this.shader.texture.height;
      geometry.update();
    }
    super._render(renderer);
  }
}

exports.SimpleRope = SimpleRope;
//# sourceMappingURL=SimpleRope.js.map


/***/ }),

/***/ "./node_modules/@pixi/mesh-extras/lib/geometry/PlaneGeometry.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@pixi/mesh-extras/lib/geometry/PlaneGeometry.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({ value: true }));

var mesh = __webpack_require__(/*! @pixi/mesh */ "./node_modules/@pixi/mesh/lib/index.js");

class PlaneGeometry extends mesh.MeshGeometry {
  constructor(width = 100, height = 100, segWidth = 10, segHeight = 10) {
    super();
    this.segWidth = segWidth;
    this.segHeight = segHeight;
    this.width = width;
    this.height = height;
    this.build();
  }
  build() {
    const total = this.segWidth * this.segHeight;
    const verts = [];
    const uvs = [];
    const indices = [];
    const segmentsX = this.segWidth - 1;
    const segmentsY = this.segHeight - 1;
    const sizeX = this.width / segmentsX;
    const sizeY = this.height / segmentsY;
    for (let i = 0; i < total; i++) {
      const x = i % this.segWidth;
      const y = i / this.segWidth | 0;
      verts.push(x * sizeX, y * sizeY);
      uvs.push(x / segmentsX, y / segmentsY);
    }
    const totalSub = segmentsX * segmentsY;
    for (let i = 0; i < totalSub; i++) {
      const xpos = i % segmentsX;
      const ypos = i / segmentsX | 0;
      const value = ypos * this.segWidth + xpos;
      const value2 = ypos * this.segWidth + xpos + 1;
      const value3 = (ypos + 1) * this.segWidth + xpos;
      const value4 = (ypos + 1) * this.segWidth + xpos + 1;
      indices.push(value, value2, value3, value2, value4, value3);
    }
    this.buffers[0].data = new Float32Array(verts);
    this.buffers[1].data = new Float32Array(uvs);
    this.indexBuffer.data = new Uint16Array(indices);
    this.buffers[0].update();
    this.buffers[1].update();
    this.indexBuffer.update();
  }
}

exports.PlaneGeometry = PlaneGeometry;
//# sourceMappingURL=PlaneGeometry.js.map


/***/ }),

/***/ "./node_modules/@pixi/mesh-extras/lib/geometry/RopeGeometry.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@pixi/mesh-extras/lib/geometry/RopeGeometry.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({ value: true }));

var mesh = __webpack_require__(/*! @pixi/mesh */ "./node_modules/@pixi/mesh/lib/index.js");

class RopeGeometry extends mesh.MeshGeometry {
  constructor(width = 200, points, textureScale = 0) {
    super(new Float32Array(points.length * 4), new Float32Array(points.length * 4), new Uint16Array((points.length - 1) * 6));
    this.points = points;
    this._width = width;
    this.textureScale = textureScale;
    this.build();
  }
  get width() {
    return this._width;
  }
  build() {
    const points = this.points;
    if (!points)
      return;
    const vertexBuffer = this.getBuffer("aVertexPosition");
    const uvBuffer = this.getBuffer("aTextureCoord");
    const indexBuffer = this.getIndex();
    if (points.length < 1) {
      return;
    }
    if (vertexBuffer.data.length / 4 !== points.length) {
      vertexBuffer.data = new Float32Array(points.length * 4);
      uvBuffer.data = new Float32Array(points.length * 4);
      indexBuffer.data = new Uint16Array((points.length - 1) * 6);
    }
    const uvs = uvBuffer.data;
    const indices = indexBuffer.data;
    uvs[0] = 0;
    uvs[1] = 0;
    uvs[2] = 0;
    uvs[3] = 1;
    let amount = 0;
    let prev = points[0];
    const textureWidth = this._width * this.textureScale;
    const total = points.length;
    for (let i = 0; i < total; i++) {
      const index = i * 4;
      if (this.textureScale > 0) {
        const dx = prev.x - points[i].x;
        const dy = prev.y - points[i].y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        prev = points[i];
        amount += distance / textureWidth;
      } else {
        amount = i / (total - 1);
      }
      uvs[index] = amount;
      uvs[index + 1] = 0;
      uvs[index + 2] = amount;
      uvs[index + 3] = 1;
    }
    let indexCount = 0;
    for (let i = 0; i < total - 1; i++) {
      const index = i * 2;
      indices[indexCount++] = index;
      indices[indexCount++] = index + 1;
      indices[indexCount++] = index + 2;
      indices[indexCount++] = index + 2;
      indices[indexCount++] = index + 1;
      indices[indexCount++] = index + 3;
    }
    uvBuffer.update();
    indexBuffer.update();
    this.updateVertices();
  }
  updateVertices() {
    const points = this.points;
    if (points.length < 1) {
      return;
    }
    let lastPoint = points[0];
    let nextPoint;
    let perpX = 0;
    let perpY = 0;
    const vertices = this.buffers[0].data;
    const total = points.length;
    const halfWidth = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2;
    for (let i = 0; i < total; i++) {
      const point = points[i];
      const index = i * 4;
      if (i < points.length - 1) {
        nextPoint = points[i + 1];
      } else {
        nextPoint = point;
      }
      perpY = -(nextPoint.x - lastPoint.x);
      perpX = nextPoint.y - lastPoint.y;
      let ratio = (1 - i / (total - 1)) * 10;
      if (ratio > 1) {
        ratio = 1;
      }
      const perpLength = Math.sqrt(perpX * perpX + perpY * perpY);
      if (perpLength < 1e-6) {
        perpX = 0;
        perpY = 0;
      } else {
        perpX /= perpLength;
        perpY /= perpLength;
        perpX *= halfWidth;
        perpY *= halfWidth;
      }
      vertices[index] = point.x + perpX;
      vertices[index + 1] = point.y + perpY;
      vertices[index + 2] = point.x - perpX;
      vertices[index + 3] = point.y - perpY;
      lastPoint = point;
    }
    this.buffers[0].update();
  }
  update() {
    if (this.textureScale > 0) {
      this.build();
    } else {
      this.updateVertices();
    }
  }
}

exports.RopeGeometry = RopeGeometry;
//# sourceMappingURL=RopeGeometry.js.map


/***/ }),

/***/ "./node_modules/@pixi/mesh-extras/lib/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@pixi/mesh-extras/lib/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({ value: true }));

var PlaneGeometry = __webpack_require__(/*! ./geometry/PlaneGeometry.js */ "./node_modules/@pixi/mesh-extras/lib/geometry/PlaneGeometry.js");
var RopeGeometry = __webpack_require__(/*! ./geometry/RopeGeometry.js */ "./node_modules/@pixi/mesh-extras/lib/geometry/RopeGeometry.js");
var NineSlicePlane = __webpack_require__(/*! ./NineSlicePlane.js */ "./node_modules/@pixi/mesh-extras/lib/NineSlicePlane.js");
var SimpleMesh = __webpack_require__(/*! ./SimpleMesh.js */ "./node_modules/@pixi/mesh-extras/lib/SimpleMesh.js");
var SimplePlane = __webpack_require__(/*! ./SimplePlane.js */ "./node_modules/@pixi/mesh-extras/lib/SimplePlane.js");
var SimpleRope = __webpack_require__(/*! ./SimpleRope.js */ "./node_modules/@pixi/mesh-extras/lib/SimpleRope.js");



exports.PlaneGeometry = PlaneGeometry.PlaneGeometry;
exports.RopeGeometry = RopeGeometry.RopeGeometry;
exports.NineSlicePlane = NineSlicePlane.NineSlicePlane;
exports.SimpleMesh = SimpleMesh.SimpleMesh;
exports.SimplePlane = SimplePlane.SimplePlane;
exports.SimpleRope = SimpleRope.SimpleRope;
//# sourceMappingURL=index.js.map


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfcGl4aV9tZXNoLWV4dHJhc19saWJfaW5kZXhfanMuMDUwYzYwM2FjNGQ2MDIxMmI0YzMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQWE7O0FBRWIsOENBQTZDLEVBQUUsYUFBYSxFQUFDOztBQUU3RCxXQUFXLG1CQUFPLENBQUMsMERBQVk7QUFDL0Isa0JBQWtCLG1CQUFPLENBQUMsNkVBQWtCOztBQUU1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0I7QUFDdEI7Ozs7Ozs7Ozs7O0FDdEhhOztBQUViLDhDQUE2QyxFQUFFLGFBQWEsRUFBQzs7QUFFN0QsV0FBVyxtQkFBTyxDQUFDLDBEQUFZO0FBQy9CLFdBQVcsbUJBQU8sQ0FBQywwREFBWTs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7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RUEsb0JBQW9CO0FBQ3BCOzs7Ozs7Ozs7OztBQzlIYTs7QUFFYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7O0FBRTdELG9CQUFvQixtQkFBTyxDQUFDLG1HQUE2QjtBQUN6RCxtQkFBbUIsbUJBQU8sQ0FBQyxpR0FBNEI7QUFDdkQscUJBQXFCLG1CQUFPLENBQUMsbUZBQXFCO0FBQ2xELGlCQUFpQixtQkFBTyxDQUFDLDJFQUFpQjtBQUMxQyxrQkFBa0IsbUJBQU8sQ0FBQyw2RUFBa0I7QUFDNUMsaUJBQWlCLG1CQUFPLENBQUMsMkVBQWlCOzs7O0FBSTFDLHFCQUFxQjtBQUNyQixvQkFBb0I7QUFDcEIsc0JBQXNCO0FBQ3RCLGtCQUFrQjtBQUNsQixtQkFBbUI7QUFDbkIsa0JBQWtCO0FBQ2xCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2VkZGluZy13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL0BwaXhpL21lc2gtZXh0cmFzL2xpYi9OaW5lU2xpY2VQbGFuZS5qcyIsIndlYnBhY2s6Ly93ZWRkaW5nLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvQHBpeGkvbWVzaC1leHRyYXMvbGliL1NpbXBsZU1lc2guanMiLCJ3ZWJwYWNrOi8vd2VkZGluZy13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL0BwaXhpL21lc2gtZXh0cmFzL2xpYi9TaW1wbGVQbGFuZS5qcyIsIndlYnBhY2s6Ly93ZWRkaW5nLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvQHBpeGkvbWVzaC1leHRyYXMvbGliL1NpbXBsZVJvcGUuanMiLCJ3ZWJwYWNrOi8vd2VkZGluZy13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL0BwaXhpL21lc2gtZXh0cmFzL2xpYi9nZW9tZXRyeS9QbGFuZUdlb21ldHJ5LmpzIiwid2VicGFjazovL3dlZGRpbmctd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9AcGl4aS9tZXNoLWV4dHJhcy9saWIvZ2VvbWV0cnkvUm9wZUdlb21ldHJ5LmpzIiwid2VicGFjazovL3dlZGRpbmctd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9AcGl4aS9tZXNoLWV4dHJhcy9saWIvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgY29yZSA9IHJlcXVpcmUoJ0BwaXhpL2NvcmUnKTtcbnZhciBTaW1wbGVQbGFuZSA9IHJlcXVpcmUoJy4vU2ltcGxlUGxhbmUuanMnKTtcblxuY29uc3QgREVGQVVMVF9CT1JERVJfU0laRSA9IDEwO1xuY2xhc3MgTmluZVNsaWNlUGxhbmUgZXh0ZW5kcyBTaW1wbGVQbGFuZS5TaW1wbGVQbGFuZSB7XG4gIGNvbnN0cnVjdG9yKHRleHR1cmUsIGxlZnRXaWR0aCwgdG9wSGVpZ2h0LCByaWdodFdpZHRoLCBib3R0b21IZWlnaHQpIHtcbiAgICBzdXBlcihjb3JlLlRleHR1cmUuV0hJVEUsIDQsIDQpO1xuICAgIHRoaXMuX29yaWdXaWR0aCA9IHRleHR1cmUub3JpZy53aWR0aDtcbiAgICB0aGlzLl9vcmlnSGVpZ2h0ID0gdGV4dHVyZS5vcmlnLmhlaWdodDtcbiAgICB0aGlzLl93aWR0aCA9IHRoaXMuX29yaWdXaWR0aDtcbiAgICB0aGlzLl9oZWlnaHQgPSB0aGlzLl9vcmlnSGVpZ2h0O1xuICAgIHRoaXMuX2xlZnRXaWR0aCA9IGxlZnRXaWR0aCA/PyB0ZXh0dXJlLmRlZmF1bHRCb3JkZXJzPy5sZWZ0ID8/IERFRkFVTFRfQk9SREVSX1NJWkU7XG4gICAgdGhpcy5fcmlnaHRXaWR0aCA9IHJpZ2h0V2lkdGggPz8gdGV4dHVyZS5kZWZhdWx0Qm9yZGVycz8ucmlnaHQgPz8gREVGQVVMVF9CT1JERVJfU0laRTtcbiAgICB0aGlzLl90b3BIZWlnaHQgPSB0b3BIZWlnaHQgPz8gdGV4dHVyZS5kZWZhdWx0Qm9yZGVycz8udG9wID8/IERFRkFVTFRfQk9SREVSX1NJWkU7XG4gICAgdGhpcy5fYm90dG9tSGVpZ2h0ID0gYm90dG9tSGVpZ2h0ID8/IHRleHR1cmUuZGVmYXVsdEJvcmRlcnM/LmJvdHRvbSA/PyBERUZBVUxUX0JPUkRFUl9TSVpFO1xuICAgIHRoaXMudGV4dHVyZSA9IHRleHR1cmU7XG4gIH1cbiAgdGV4dHVyZVVwZGF0ZWQoKSB7XG4gICAgdGhpcy5fdGV4dHVyZUlEID0gdGhpcy5zaGFkZXIudGV4dHVyZS5fdXBkYXRlSUQ7XG4gICAgdGhpcy5fcmVmcmVzaCgpO1xuICB9XG4gIGdldCB2ZXJ0aWNlcygpIHtcbiAgICByZXR1cm4gdGhpcy5nZW9tZXRyeS5nZXRCdWZmZXIoXCJhVmVydGV4UG9zaXRpb25cIikuZGF0YTtcbiAgfVxuICBzZXQgdmVydGljZXModmFsdWUpIHtcbiAgICB0aGlzLmdlb21ldHJ5LmdldEJ1ZmZlcihcImFWZXJ0ZXhQb3NpdGlvblwiKS5kYXRhID0gdmFsdWU7XG4gIH1cbiAgdXBkYXRlSG9yaXpvbnRhbFZlcnRpY2VzKCkge1xuICAgIGNvbnN0IHZlcnRpY2VzID0gdGhpcy52ZXJ0aWNlcztcbiAgICBjb25zdCBzY2FsZSA9IHRoaXMuX2dldE1pblNjYWxlKCk7XG4gICAgdmVydGljZXNbOV0gPSB2ZXJ0aWNlc1sxMV0gPSB2ZXJ0aWNlc1sxM10gPSB2ZXJ0aWNlc1sxNV0gPSB0aGlzLl90b3BIZWlnaHQgKiBzY2FsZTtcbiAgICB2ZXJ0aWNlc1sxN10gPSB2ZXJ0aWNlc1sxOV0gPSB2ZXJ0aWNlc1syMV0gPSB2ZXJ0aWNlc1syM10gPSB0aGlzLl9oZWlnaHQgLSB0aGlzLl9ib3R0b21IZWlnaHQgKiBzY2FsZTtcbiAgICB2ZXJ0aWNlc1syNV0gPSB2ZXJ0aWNlc1syN10gPSB2ZXJ0aWNlc1syOV0gPSB2ZXJ0aWNlc1szMV0gPSB0aGlzLl9oZWlnaHQ7XG4gIH1cbiAgdXBkYXRlVmVydGljYWxWZXJ0aWNlcygpIHtcbiAgICBjb25zdCB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXM7XG4gICAgY29uc3Qgc2NhbGUgPSB0aGlzLl9nZXRNaW5TY2FsZSgpO1xuICAgIHZlcnRpY2VzWzJdID0gdmVydGljZXNbMTBdID0gdmVydGljZXNbMThdID0gdmVydGljZXNbMjZdID0gdGhpcy5fbGVmdFdpZHRoICogc2NhbGU7XG4gICAgdmVydGljZXNbNF0gPSB2ZXJ0aWNlc1sxMl0gPSB2ZXJ0aWNlc1syMF0gPSB2ZXJ0aWNlc1syOF0gPSB0aGlzLl93aWR0aCAtIHRoaXMuX3JpZ2h0V2lkdGggKiBzY2FsZTtcbiAgICB2ZXJ0aWNlc1s2XSA9IHZlcnRpY2VzWzE0XSA9IHZlcnRpY2VzWzIyXSA9IHZlcnRpY2VzWzMwXSA9IHRoaXMuX3dpZHRoO1xuICB9XG4gIF9nZXRNaW5TY2FsZSgpIHtcbiAgICBjb25zdCB3ID0gdGhpcy5fbGVmdFdpZHRoICsgdGhpcy5fcmlnaHRXaWR0aDtcbiAgICBjb25zdCBzY2FsZVcgPSB0aGlzLl93aWR0aCA+IHcgPyAxIDogdGhpcy5fd2lkdGggLyB3O1xuICAgIGNvbnN0IGggPSB0aGlzLl90b3BIZWlnaHQgKyB0aGlzLl9ib3R0b21IZWlnaHQ7XG4gICAgY29uc3Qgc2NhbGVIID0gdGhpcy5faGVpZ2h0ID4gaCA/IDEgOiB0aGlzLl9oZWlnaHQgLyBoO1xuICAgIGNvbnN0IHNjYWxlID0gTWF0aC5taW4oc2NhbGVXLCBzY2FsZUgpO1xuICAgIHJldHVybiBzY2FsZTtcbiAgfVxuICBnZXQgd2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpZHRoO1xuICB9XG4gIHNldCB3aWR0aCh2YWx1ZSkge1xuICAgIHRoaXMuX3dpZHRoID0gdmFsdWU7XG4gICAgdGhpcy5fcmVmcmVzaCgpO1xuICB9XG4gIGdldCBoZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hlaWdodDtcbiAgfVxuICBzZXQgaGVpZ2h0KHZhbHVlKSB7XG4gICAgdGhpcy5faGVpZ2h0ID0gdmFsdWU7XG4gICAgdGhpcy5fcmVmcmVzaCgpO1xuICB9XG4gIGdldCBsZWZ0V2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xlZnRXaWR0aDtcbiAgfVxuICBzZXQgbGVmdFdpZHRoKHZhbHVlKSB7XG4gICAgdGhpcy5fbGVmdFdpZHRoID0gdmFsdWU7XG4gICAgdGhpcy5fcmVmcmVzaCgpO1xuICB9XG4gIGdldCByaWdodFdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLl9yaWdodFdpZHRoO1xuICB9XG4gIHNldCByaWdodFdpZHRoKHZhbHVlKSB7XG4gICAgdGhpcy5fcmlnaHRXaWR0aCA9IHZhbHVlO1xuICAgIHRoaXMuX3JlZnJlc2goKTtcbiAgfVxuICBnZXQgdG9wSGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLl90b3BIZWlnaHQ7XG4gIH1cbiAgc2V0IHRvcEhlaWdodCh2YWx1ZSkge1xuICAgIHRoaXMuX3RvcEhlaWdodCA9IHZhbHVlO1xuICAgIHRoaXMuX3JlZnJlc2goKTtcbiAgfVxuICBnZXQgYm90dG9tSGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLl9ib3R0b21IZWlnaHQ7XG4gIH1cbiAgc2V0IGJvdHRvbUhlaWdodCh2YWx1ZSkge1xuICAgIHRoaXMuX2JvdHRvbUhlaWdodCA9IHZhbHVlO1xuICAgIHRoaXMuX3JlZnJlc2goKTtcbiAgfVxuICBfcmVmcmVzaCgpIHtcbiAgICBjb25zdCB0ZXh0dXJlID0gdGhpcy50ZXh0dXJlO1xuICAgIGNvbnN0IHV2cyA9IHRoaXMuZ2VvbWV0cnkuYnVmZmVyc1sxXS5kYXRhO1xuICAgIHRoaXMuX29yaWdXaWR0aCA9IHRleHR1cmUub3JpZy53aWR0aDtcbiAgICB0aGlzLl9vcmlnSGVpZ2h0ID0gdGV4dHVyZS5vcmlnLmhlaWdodDtcbiAgICBjb25zdCBfdXZ3ID0gMSAvIHRoaXMuX29yaWdXaWR0aDtcbiAgICBjb25zdCBfdXZoID0gMSAvIHRoaXMuX29yaWdIZWlnaHQ7XG4gICAgdXZzWzBdID0gdXZzWzhdID0gdXZzWzE2XSA9IHV2c1syNF0gPSAwO1xuICAgIHV2c1sxXSA9IHV2c1szXSA9IHV2c1s1XSA9IHV2c1s3XSA9IDA7XG4gICAgdXZzWzZdID0gdXZzWzE0XSA9IHV2c1syMl0gPSB1dnNbMzBdID0gMTtcbiAgICB1dnNbMjVdID0gdXZzWzI3XSA9IHV2c1syOV0gPSB1dnNbMzFdID0gMTtcbiAgICB1dnNbMl0gPSB1dnNbMTBdID0gdXZzWzE4XSA9IHV2c1syNl0gPSBfdXZ3ICogdGhpcy5fbGVmdFdpZHRoO1xuICAgIHV2c1s0XSA9IHV2c1sxMl0gPSB1dnNbMjBdID0gdXZzWzI4XSA9IDEgLSBfdXZ3ICogdGhpcy5fcmlnaHRXaWR0aDtcbiAgICB1dnNbOV0gPSB1dnNbMTFdID0gdXZzWzEzXSA9IHV2c1sxNV0gPSBfdXZoICogdGhpcy5fdG9wSGVpZ2h0O1xuICAgIHV2c1sxN10gPSB1dnNbMTldID0gdXZzWzIxXSA9IHV2c1syM10gPSAxIC0gX3V2aCAqIHRoaXMuX2JvdHRvbUhlaWdodDtcbiAgICB0aGlzLnVwZGF0ZUhvcml6b250YWxWZXJ0aWNlcygpO1xuICAgIHRoaXMudXBkYXRlVmVydGljYWxWZXJ0aWNlcygpO1xuICAgIHRoaXMuZ2VvbWV0cnkuYnVmZmVyc1swXS51cGRhdGUoKTtcbiAgICB0aGlzLmdlb21ldHJ5LmJ1ZmZlcnNbMV0udXBkYXRlKCk7XG4gIH1cbn1cblxuZXhwb3J0cy5OaW5lU2xpY2VQbGFuZSA9IE5pbmVTbGljZVBsYW5lO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TmluZVNsaWNlUGxhbmUuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBjb3JlID0gcmVxdWlyZSgnQHBpeGkvY29yZScpO1xudmFyIG1lc2ggPSByZXF1aXJlKCdAcGl4aS9tZXNoJyk7XG5cbmNsYXNzIFNpbXBsZU1lc2ggZXh0ZW5kcyBtZXNoLk1lc2gge1xuICBjb25zdHJ1Y3Rvcih0ZXh0dXJlID0gY29yZS5UZXh0dXJlLkVNUFRZLCB2ZXJ0aWNlcywgdXZzLCBpbmRpY2VzLCBkcmF3TW9kZSkge1xuICAgIGNvbnN0IGdlb21ldHJ5ID0gbmV3IG1lc2guTWVzaEdlb21ldHJ5KHZlcnRpY2VzLCB1dnMsIGluZGljZXMpO1xuICAgIGdlb21ldHJ5LmdldEJ1ZmZlcihcImFWZXJ0ZXhQb3NpdGlvblwiKS5zdGF0aWMgPSBmYWxzZTtcbiAgICBjb25zdCBtZXNoTWF0ZXJpYWwgPSBuZXcgbWVzaC5NZXNoTWF0ZXJpYWwodGV4dHVyZSk7XG4gICAgc3VwZXIoZ2VvbWV0cnksIG1lc2hNYXRlcmlhbCwgbnVsbCwgZHJhd01vZGUpO1xuICAgIHRoaXMuYXV0b1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgZ2V0IHZlcnRpY2VzKCkge1xuICAgIHJldHVybiB0aGlzLmdlb21ldHJ5LmdldEJ1ZmZlcihcImFWZXJ0ZXhQb3NpdGlvblwiKS5kYXRhO1xuICB9XG4gIHNldCB2ZXJ0aWNlcyh2YWx1ZSkge1xuICAgIHRoaXMuZ2VvbWV0cnkuZ2V0QnVmZmVyKFwiYVZlcnRleFBvc2l0aW9uXCIpLmRhdGEgPSB2YWx1ZTtcbiAgfVxuICBfcmVuZGVyKHJlbmRlcmVyKSB7XG4gICAgaWYgKHRoaXMuYXV0b1VwZGF0ZSkge1xuICAgICAgdGhpcy5nZW9tZXRyeS5nZXRCdWZmZXIoXCJhVmVydGV4UG9zaXRpb25cIikudXBkYXRlKCk7XG4gICAgfVxuICAgIHN1cGVyLl9yZW5kZXIocmVuZGVyZXIpO1xuICB9XG59XG5cbmV4cG9ydHMuU2ltcGxlTWVzaCA9IFNpbXBsZU1lc2g7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TaW1wbGVNZXNoLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgY29yZSA9IHJlcXVpcmUoJ0BwaXhpL2NvcmUnKTtcbnZhciBtZXNoID0gcmVxdWlyZSgnQHBpeGkvbWVzaCcpO1xudmFyIFBsYW5lR2VvbWV0cnkgPSByZXF1aXJlKCcuL2dlb21ldHJ5L1BsYW5lR2VvbWV0cnkuanMnKTtcblxuY2xhc3MgU2ltcGxlUGxhbmUgZXh0ZW5kcyBtZXNoLk1lc2gge1xuICBjb25zdHJ1Y3Rvcih0ZXh0dXJlLCB2ZXJ0aWNlc1gsIHZlcnRpY2VzWSkge1xuICAgIGNvbnN0IHBsYW5lR2VvbWV0cnkgPSBuZXcgUGxhbmVHZW9tZXRyeS5QbGFuZUdlb21ldHJ5KHRleHR1cmUud2lkdGgsIHRleHR1cmUuaGVpZ2h0LCB2ZXJ0aWNlc1gsIHZlcnRpY2VzWSk7XG4gICAgY29uc3QgbWVzaE1hdGVyaWFsID0gbmV3IG1lc2guTWVzaE1hdGVyaWFsKGNvcmUuVGV4dHVyZS5XSElURSk7XG4gICAgc3VwZXIocGxhbmVHZW9tZXRyeSwgbWVzaE1hdGVyaWFsKTtcbiAgICB0aGlzLnRleHR1cmUgPSB0ZXh0dXJlO1xuICAgIHRoaXMuYXV0b1Jlc2l6ZSA9IHRydWU7XG4gIH1cbiAgdGV4dHVyZVVwZGF0ZWQoKSB7XG4gICAgdGhpcy5fdGV4dHVyZUlEID0gdGhpcy5zaGFkZXIudGV4dHVyZS5fdXBkYXRlSUQ7XG4gICAgY29uc3QgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gdGhpcy5zaGFkZXIudGV4dHVyZTtcbiAgICBpZiAodGhpcy5hdXRvUmVzaXplICYmIChnZW9tZXRyeS53aWR0aCAhPT0gd2lkdGggfHwgZ2VvbWV0cnkuaGVpZ2h0ICE9PSBoZWlnaHQpKSB7XG4gICAgICBnZW9tZXRyeS53aWR0aCA9IHRoaXMuc2hhZGVyLnRleHR1cmUud2lkdGg7XG4gICAgICBnZW9tZXRyeS5oZWlnaHQgPSB0aGlzLnNoYWRlci50ZXh0dXJlLmhlaWdodDtcbiAgICAgIGdlb21ldHJ5LmJ1aWxkKCk7XG4gICAgfVxuICB9XG4gIHNldCB0ZXh0dXJlKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuc2hhZGVyLnRleHR1cmUgPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc2hhZGVyLnRleHR1cmUgPSB2YWx1ZTtcbiAgICB0aGlzLl90ZXh0dXJlSUQgPSAtMTtcbiAgICBpZiAodmFsdWUuYmFzZVRleHR1cmUudmFsaWQpIHtcbiAgICAgIHRoaXMudGV4dHVyZVVwZGF0ZWQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUub25jZShcInVwZGF0ZVwiLCB0aGlzLnRleHR1cmVVcGRhdGVkLCB0aGlzKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHRleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2hhZGVyLnRleHR1cmU7XG4gIH1cbiAgX3JlbmRlcihyZW5kZXJlcikge1xuICAgIGlmICh0aGlzLl90ZXh0dXJlSUQgIT09IHRoaXMuc2hhZGVyLnRleHR1cmUuX3VwZGF0ZUlEKSB7XG4gICAgICB0aGlzLnRleHR1cmVVcGRhdGVkKCk7XG4gICAgfVxuICAgIHN1cGVyLl9yZW5kZXIocmVuZGVyZXIpO1xuICB9XG4gIGRlc3Ryb3kob3B0aW9ucykge1xuICAgIHRoaXMuc2hhZGVyLnRleHR1cmUub2ZmKFwidXBkYXRlXCIsIHRoaXMudGV4dHVyZVVwZGF0ZWQsIHRoaXMpO1xuICAgIHN1cGVyLmRlc3Ryb3kob3B0aW9ucyk7XG4gIH1cbn1cblxuZXhwb3J0cy5TaW1wbGVQbGFuZSA9IFNpbXBsZVBsYW5lO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2ltcGxlUGxhbmUuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBjb3JlID0gcmVxdWlyZSgnQHBpeGkvY29yZScpO1xudmFyIG1lc2ggPSByZXF1aXJlKCdAcGl4aS9tZXNoJyk7XG52YXIgUm9wZUdlb21ldHJ5ID0gcmVxdWlyZSgnLi9nZW9tZXRyeS9Sb3BlR2VvbWV0cnkuanMnKTtcblxuY2xhc3MgU2ltcGxlUm9wZSBleHRlbmRzIG1lc2guTWVzaCB7XG4gIGNvbnN0cnVjdG9yKHRleHR1cmUsIHBvaW50cywgdGV4dHVyZVNjYWxlID0gMCkge1xuICAgIGNvbnN0IHJvcGVHZW9tZXRyeSA9IG5ldyBSb3BlR2VvbWV0cnkuUm9wZUdlb21ldHJ5KHRleHR1cmUuaGVpZ2h0LCBwb2ludHMsIHRleHR1cmVTY2FsZSk7XG4gICAgY29uc3QgbWVzaE1hdGVyaWFsID0gbmV3IG1lc2guTWVzaE1hdGVyaWFsKHRleHR1cmUpO1xuICAgIGlmICh0ZXh0dXJlU2NhbGUgPiAwKSB7XG4gICAgICB0ZXh0dXJlLmJhc2VUZXh0dXJlLndyYXBNb2RlID0gY29yZS5XUkFQX01PREVTLlJFUEVBVDtcbiAgICB9XG4gICAgc3VwZXIocm9wZUdlb21ldHJ5LCBtZXNoTWF0ZXJpYWwpO1xuICAgIHRoaXMuYXV0b1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgX3JlbmRlcihyZW5kZXJlcikge1xuICAgIGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcbiAgICBpZiAodGhpcy5hdXRvVXBkYXRlIHx8IGdlb21ldHJ5Ll93aWR0aCAhPT0gdGhpcy5zaGFkZXIudGV4dHVyZS5oZWlnaHQpIHtcbiAgICAgIGdlb21ldHJ5Ll93aWR0aCA9IHRoaXMuc2hhZGVyLnRleHR1cmUuaGVpZ2h0O1xuICAgICAgZ2VvbWV0cnkudXBkYXRlKCk7XG4gICAgfVxuICAgIHN1cGVyLl9yZW5kZXIocmVuZGVyZXIpO1xuICB9XG59XG5cbmV4cG9ydHMuU2ltcGxlUm9wZSA9IFNpbXBsZVJvcGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TaW1wbGVSb3BlLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgbWVzaCA9IHJlcXVpcmUoJ0BwaXhpL21lc2gnKTtcblxuY2xhc3MgUGxhbmVHZW9tZXRyeSBleHRlbmRzIG1lc2guTWVzaEdlb21ldHJ5IHtcbiAgY29uc3RydWN0b3Iod2lkdGggPSAxMDAsIGhlaWdodCA9IDEwMCwgc2VnV2lkdGggPSAxMCwgc2VnSGVpZ2h0ID0gMTApIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuc2VnV2lkdGggPSBzZWdXaWR0aDtcbiAgICB0aGlzLnNlZ0hlaWdodCA9IHNlZ0hlaWdodDtcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy5idWlsZCgpO1xuICB9XG4gIGJ1aWxkKCkge1xuICAgIGNvbnN0IHRvdGFsID0gdGhpcy5zZWdXaWR0aCAqIHRoaXMuc2VnSGVpZ2h0O1xuICAgIGNvbnN0IHZlcnRzID0gW107XG4gICAgY29uc3QgdXZzID0gW107XG4gICAgY29uc3QgaW5kaWNlcyA9IFtdO1xuICAgIGNvbnN0IHNlZ21lbnRzWCA9IHRoaXMuc2VnV2lkdGggLSAxO1xuICAgIGNvbnN0IHNlZ21lbnRzWSA9IHRoaXMuc2VnSGVpZ2h0IC0gMTtcbiAgICBjb25zdCBzaXplWCA9IHRoaXMud2lkdGggLyBzZWdtZW50c1g7XG4gICAgY29uc3Qgc2l6ZVkgPSB0aGlzLmhlaWdodCAvIHNlZ21lbnRzWTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvdGFsOyBpKyspIHtcbiAgICAgIGNvbnN0IHggPSBpICUgdGhpcy5zZWdXaWR0aDtcbiAgICAgIGNvbnN0IHkgPSBpIC8gdGhpcy5zZWdXaWR0aCB8IDA7XG4gICAgICB2ZXJ0cy5wdXNoKHggKiBzaXplWCwgeSAqIHNpemVZKTtcbiAgICAgIHV2cy5wdXNoKHggLyBzZWdtZW50c1gsIHkgLyBzZWdtZW50c1kpO1xuICAgIH1cbiAgICBjb25zdCB0b3RhbFN1YiA9IHNlZ21lbnRzWCAqIHNlZ21lbnRzWTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvdGFsU3ViOyBpKyspIHtcbiAgICAgIGNvbnN0IHhwb3MgPSBpICUgc2VnbWVudHNYO1xuICAgICAgY29uc3QgeXBvcyA9IGkgLyBzZWdtZW50c1ggfCAwO1xuICAgICAgY29uc3QgdmFsdWUgPSB5cG9zICogdGhpcy5zZWdXaWR0aCArIHhwb3M7XG4gICAgICBjb25zdCB2YWx1ZTIgPSB5cG9zICogdGhpcy5zZWdXaWR0aCArIHhwb3MgKyAxO1xuICAgICAgY29uc3QgdmFsdWUzID0gKHlwb3MgKyAxKSAqIHRoaXMuc2VnV2lkdGggKyB4cG9zO1xuICAgICAgY29uc3QgdmFsdWU0ID0gKHlwb3MgKyAxKSAqIHRoaXMuc2VnV2lkdGggKyB4cG9zICsgMTtcbiAgICAgIGluZGljZXMucHVzaCh2YWx1ZSwgdmFsdWUyLCB2YWx1ZTMsIHZhbHVlMiwgdmFsdWU0LCB2YWx1ZTMpO1xuICAgIH1cbiAgICB0aGlzLmJ1ZmZlcnNbMF0uZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkodmVydHMpO1xuICAgIHRoaXMuYnVmZmVyc1sxXS5kYXRhID0gbmV3IEZsb2F0MzJBcnJheSh1dnMpO1xuICAgIHRoaXMuaW5kZXhCdWZmZXIuZGF0YSA9IG5ldyBVaW50MTZBcnJheShpbmRpY2VzKTtcbiAgICB0aGlzLmJ1ZmZlcnNbMF0udXBkYXRlKCk7XG4gICAgdGhpcy5idWZmZXJzWzFdLnVwZGF0ZSgpO1xuICAgIHRoaXMuaW5kZXhCdWZmZXIudXBkYXRlKCk7XG4gIH1cbn1cblxuZXhwb3J0cy5QbGFuZUdlb21ldHJ5ID0gUGxhbmVHZW9tZXRyeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBsYW5lR2VvbWV0cnkuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBtZXNoID0gcmVxdWlyZSgnQHBpeGkvbWVzaCcpO1xuXG5jbGFzcyBSb3BlR2VvbWV0cnkgZXh0ZW5kcyBtZXNoLk1lc2hHZW9tZXRyeSB7XG4gIGNvbnN0cnVjdG9yKHdpZHRoID0gMjAwLCBwb2ludHMsIHRleHR1cmVTY2FsZSA9IDApIHtcbiAgICBzdXBlcihuZXcgRmxvYXQzMkFycmF5KHBvaW50cy5sZW5ndGggKiA0KSwgbmV3IEZsb2F0MzJBcnJheShwb2ludHMubGVuZ3RoICogNCksIG5ldyBVaW50MTZBcnJheSgocG9pbnRzLmxlbmd0aCAtIDEpICogNikpO1xuICAgIHRoaXMucG9pbnRzID0gcG9pbnRzO1xuICAgIHRoaXMuX3dpZHRoID0gd2lkdGg7XG4gICAgdGhpcy50ZXh0dXJlU2NhbGUgPSB0ZXh0dXJlU2NhbGU7XG4gICAgdGhpcy5idWlsZCgpO1xuICB9XG4gIGdldCB3aWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd2lkdGg7XG4gIH1cbiAgYnVpbGQoKSB7XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5wb2ludHM7XG4gICAgaWYgKCFwb2ludHMpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdmVydGV4QnVmZmVyID0gdGhpcy5nZXRCdWZmZXIoXCJhVmVydGV4UG9zaXRpb25cIik7XG4gICAgY29uc3QgdXZCdWZmZXIgPSB0aGlzLmdldEJ1ZmZlcihcImFUZXh0dXJlQ29vcmRcIik7XG4gICAgY29uc3QgaW5kZXhCdWZmZXIgPSB0aGlzLmdldEluZGV4KCk7XG4gICAgaWYgKHBvaW50cy5sZW5ndGggPCAxKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh2ZXJ0ZXhCdWZmZXIuZGF0YS5sZW5ndGggLyA0ICE9PSBwb2ludHMubGVuZ3RoKSB7XG4gICAgICB2ZXJ0ZXhCdWZmZXIuZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkocG9pbnRzLmxlbmd0aCAqIDQpO1xuICAgICAgdXZCdWZmZXIuZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkocG9pbnRzLmxlbmd0aCAqIDQpO1xuICAgICAgaW5kZXhCdWZmZXIuZGF0YSA9IG5ldyBVaW50MTZBcnJheSgocG9pbnRzLmxlbmd0aCAtIDEpICogNik7XG4gICAgfVxuICAgIGNvbnN0IHV2cyA9IHV2QnVmZmVyLmRhdGE7XG4gICAgY29uc3QgaW5kaWNlcyA9IGluZGV4QnVmZmVyLmRhdGE7XG4gICAgdXZzWzBdID0gMDtcbiAgICB1dnNbMV0gPSAwO1xuICAgIHV2c1syXSA9IDA7XG4gICAgdXZzWzNdID0gMTtcbiAgICBsZXQgYW1vdW50ID0gMDtcbiAgICBsZXQgcHJldiA9IHBvaW50c1swXTtcbiAgICBjb25zdCB0ZXh0dXJlV2lkdGggPSB0aGlzLl93aWR0aCAqIHRoaXMudGV4dHVyZVNjYWxlO1xuICAgIGNvbnN0IHRvdGFsID0gcG9pbnRzLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvdGFsOyBpKyspIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gaSAqIDQ7XG4gICAgICBpZiAodGhpcy50ZXh0dXJlU2NhbGUgPiAwKSB7XG4gICAgICAgIGNvbnN0IGR4ID0gcHJldi54IC0gcG9pbnRzW2ldLng7XG4gICAgICAgIGNvbnN0IGR5ID0gcHJldi55IC0gcG9pbnRzW2ldLnk7XG4gICAgICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgICAgcHJldiA9IHBvaW50c1tpXTtcbiAgICAgICAgYW1vdW50ICs9IGRpc3RhbmNlIC8gdGV4dHVyZVdpZHRoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYW1vdW50ID0gaSAvICh0b3RhbCAtIDEpO1xuICAgICAgfVxuICAgICAgdXZzW2luZGV4XSA9IGFtb3VudDtcbiAgICAgIHV2c1tpbmRleCArIDFdID0gMDtcbiAgICAgIHV2c1tpbmRleCArIDJdID0gYW1vdW50O1xuICAgICAgdXZzW2luZGV4ICsgM10gPSAxO1xuICAgIH1cbiAgICBsZXQgaW5kZXhDb3VudCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3RhbCAtIDE7IGkrKykge1xuICAgICAgY29uc3QgaW5kZXggPSBpICogMjtcbiAgICAgIGluZGljZXNbaW5kZXhDb3VudCsrXSA9IGluZGV4O1xuICAgICAgaW5kaWNlc1tpbmRleENvdW50KytdID0gaW5kZXggKyAxO1xuICAgICAgaW5kaWNlc1tpbmRleENvdW50KytdID0gaW5kZXggKyAyO1xuICAgICAgaW5kaWNlc1tpbmRleENvdW50KytdID0gaW5kZXggKyAyO1xuICAgICAgaW5kaWNlc1tpbmRleENvdW50KytdID0gaW5kZXggKyAxO1xuICAgICAgaW5kaWNlc1tpbmRleENvdW50KytdID0gaW5kZXggKyAzO1xuICAgIH1cbiAgICB1dkJ1ZmZlci51cGRhdGUoKTtcbiAgICBpbmRleEJ1ZmZlci51cGRhdGUoKTtcbiAgICB0aGlzLnVwZGF0ZVZlcnRpY2VzKCk7XG4gIH1cbiAgdXBkYXRlVmVydGljZXMoKSB7XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5wb2ludHM7XG4gICAgaWYgKHBvaW50cy5sZW5ndGggPCAxKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBsYXN0UG9pbnQgPSBwb2ludHNbMF07XG4gICAgbGV0IG5leHRQb2ludDtcbiAgICBsZXQgcGVycFggPSAwO1xuICAgIGxldCBwZXJwWSA9IDA7XG4gICAgY29uc3QgdmVydGljZXMgPSB0aGlzLmJ1ZmZlcnNbMF0uZGF0YTtcbiAgICBjb25zdCB0b3RhbCA9IHBvaW50cy5sZW5ndGg7XG4gICAgY29uc3QgaGFsZldpZHRoID0gdGhpcy50ZXh0dXJlU2NhbGUgPiAwID8gdGhpcy50ZXh0dXJlU2NhbGUgKiB0aGlzLl93aWR0aCAvIDIgOiB0aGlzLl93aWR0aCAvIDI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3RhbDsgaSsrKSB7XG4gICAgICBjb25zdCBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgIGNvbnN0IGluZGV4ID0gaSAqIDQ7XG4gICAgICBpZiAoaSA8IHBvaW50cy5sZW5ndGggLSAxKSB7XG4gICAgICAgIG5leHRQb2ludCA9IHBvaW50c1tpICsgMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0UG9pbnQgPSBwb2ludDtcbiAgICAgIH1cbiAgICAgIHBlcnBZID0gLShuZXh0UG9pbnQueCAtIGxhc3RQb2ludC54KTtcbiAgICAgIHBlcnBYID0gbmV4dFBvaW50LnkgLSBsYXN0UG9pbnQueTtcbiAgICAgIGxldCByYXRpbyA9ICgxIC0gaSAvICh0b3RhbCAtIDEpKSAqIDEwO1xuICAgICAgaWYgKHJhdGlvID4gMSkge1xuICAgICAgICByYXRpbyA9IDE7XG4gICAgICB9XG4gICAgICBjb25zdCBwZXJwTGVuZ3RoID0gTWF0aC5zcXJ0KHBlcnBYICogcGVycFggKyBwZXJwWSAqIHBlcnBZKTtcbiAgICAgIGlmIChwZXJwTGVuZ3RoIDwgMWUtNikge1xuICAgICAgICBwZXJwWCA9IDA7XG4gICAgICAgIHBlcnBZID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlcnBYIC89IHBlcnBMZW5ndGg7XG4gICAgICAgIHBlcnBZIC89IHBlcnBMZW5ndGg7XG4gICAgICAgIHBlcnBYICo9IGhhbGZXaWR0aDtcbiAgICAgICAgcGVycFkgKj0gaGFsZldpZHRoO1xuICAgICAgfVxuICAgICAgdmVydGljZXNbaW5kZXhdID0gcG9pbnQueCArIHBlcnBYO1xuICAgICAgdmVydGljZXNbaW5kZXggKyAxXSA9IHBvaW50LnkgKyBwZXJwWTtcbiAgICAgIHZlcnRpY2VzW2luZGV4ICsgMl0gPSBwb2ludC54IC0gcGVycFg7XG4gICAgICB2ZXJ0aWNlc1tpbmRleCArIDNdID0gcG9pbnQueSAtIHBlcnBZO1xuICAgICAgbGFzdFBvaW50ID0gcG9pbnQ7XG4gICAgfVxuICAgIHRoaXMuYnVmZmVyc1swXS51cGRhdGUoKTtcbiAgfVxuICB1cGRhdGUoKSB7XG4gICAgaWYgKHRoaXMudGV4dHVyZVNjYWxlID4gMCkge1xuICAgICAgdGhpcy5idWlsZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVwZGF0ZVZlcnRpY2VzKCk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydHMuUm9wZUdlb21ldHJ5ID0gUm9wZUdlb21ldHJ5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Um9wZUdlb21ldHJ5LmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgUGxhbmVHZW9tZXRyeSA9IHJlcXVpcmUoJy4vZ2VvbWV0cnkvUGxhbmVHZW9tZXRyeS5qcycpO1xudmFyIFJvcGVHZW9tZXRyeSA9IHJlcXVpcmUoJy4vZ2VvbWV0cnkvUm9wZUdlb21ldHJ5LmpzJyk7XG52YXIgTmluZVNsaWNlUGxhbmUgPSByZXF1aXJlKCcuL05pbmVTbGljZVBsYW5lLmpzJyk7XG52YXIgU2ltcGxlTWVzaCA9IHJlcXVpcmUoJy4vU2ltcGxlTWVzaC5qcycpO1xudmFyIFNpbXBsZVBsYW5lID0gcmVxdWlyZSgnLi9TaW1wbGVQbGFuZS5qcycpO1xudmFyIFNpbXBsZVJvcGUgPSByZXF1aXJlKCcuL1NpbXBsZVJvcGUuanMnKTtcblxuXG5cbmV4cG9ydHMuUGxhbmVHZW9tZXRyeSA9IFBsYW5lR2VvbWV0cnkuUGxhbmVHZW9tZXRyeTtcbmV4cG9ydHMuUm9wZUdlb21ldHJ5ID0gUm9wZUdlb21ldHJ5LlJvcGVHZW9tZXRyeTtcbmV4cG9ydHMuTmluZVNsaWNlUGxhbmUgPSBOaW5lU2xpY2VQbGFuZS5OaW5lU2xpY2VQbGFuZTtcbmV4cG9ydHMuU2ltcGxlTWVzaCA9IFNpbXBsZU1lc2guU2ltcGxlTWVzaDtcbmV4cG9ydHMuU2ltcGxlUGxhbmUgPSBTaW1wbGVQbGFuZS5TaW1wbGVQbGFuZTtcbmV4cG9ydHMuU2ltcGxlUm9wZSA9IFNpbXBsZVJvcGUuU2ltcGxlUm9wZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9