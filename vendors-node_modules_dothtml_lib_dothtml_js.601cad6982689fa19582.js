"use strict";
(self["webpackChunkwedding_website"] = self["webpackChunkwedding_website"] || []).push([["vendors-node_modules_dothtml_lib_dothtml_js"],{

/***/ "./node_modules/dothtml/lib/arg-callback-obj.js":
/*!******************************************************!*\
  !*** ./node_modules/dothtml/lib/arg-callback-obj.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConditionalArgCallback = exports.ArrayArgCallback = exports.ContentArgCallback = exports.AttrArgCallback = exports.ArgCallback = void 0;
class ArgCallback {
    constructor(element, value) {
        this.el = element;
        this.f = value;
    }
}
exports.ArgCallback = ArgCallback;
class AttrArgCallback extends ArgCallback {
    constructor(element, attributeName, value) {
        super(element, value);
        this.attr = attributeName;
    }
    updateContent(dot) {
        this.el.setAttribute(this.attr, this.f());
    }
}
exports.AttrArgCallback = AttrArgCallback;
class ContentArgCallback extends ArgCallback {
    constructor(element, content) {
        super(element, content);
    }
    updateContent(dot, propVal) {
        dot(this.el).empty().h(this.f(propVal));
    }
}
exports.ContentArgCallback = ContentArgCallback;
class ArrayArgCallback extends ArgCallback {
    constructor(dotTarget, content) {
        super(null, content);
        this.dotTarget = dotTarget;
    }
    updateContent() { }
}
exports.ArrayArgCallback = ArrayArgCallback;
class ConditionalArgCallback extends ArgCallback {
    constructor(startNode, endNode, content, condition) {
        super(null, content);
        this.startNode = startNode;
        this.endNode = endNode;
        this.condition = condition;
        this.lastValue = undefined; // This will be set by the calling code - after the object is added to __currentArgCallback.
    }
    updateContent(dot) {
        if (this.lastValue != !!this.condition()) {
            this.lastValue = !this.lastValue;
            if (this.lastValue) {
                dot._appendOrCreateDocument(this.f, this.endNode.parentNode, this.endNode);
            }
            else {
                do {
                    var e = this.startNode.nextSibling;
                    if (e && e != this.endNode) {
                        e.parentNode.removeChild(e);
                    }
                } while (this.startNode.nextSibling && this.startNode.nextSibling != this.endNode);
            }
        }
    }
}
exports.ConditionalArgCallback = ConditionalArgCallback;
//# sourceMappingURL=arg-callback-obj.js.map

/***/ }),

/***/ "./node_modules/dothtml/lib/component.js":
/*!***********************************************!*\
  !*** ./node_modules/dothtml/lib/component.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const observable_array_1 = __importDefault(__webpack_require__(/*! ./observable-array */ "./node_modules/dothtml/lib/observable-array.js"));
const dot_1 = __importDefault(__webpack_require__(/*! ./dot */ "./node_modules/dothtml/lib/dot.js"));
const dot_util_1 = __webpack_require__(/*! ./dot-util */ "./node_modules/dothtml/lib/dot-util.js");
const err_1 = __importDefault(__webpack_require__(/*! ./err */ "./node_modules/dothtml/lib/err.js"));
const arg_callback_obj_1 = __webpack_require__(/*! ./arg-callback-obj */ "./node_modules/dothtml/lib/arg-callback-obj.js");
class Component {
    constructor(...args) {
        /**
         * Used internally to indicate the first time $updateStyles is called.
         * This method is called by the static component builder when the component is created.
         * If a prop is accessed within the style builder, the getter reads this field to mark $updateStyles as a dependency.
        */
        this.#initializingStyles = false;
        this.#initializingBuild = false;
        // A bit messy but gets us to MVP for this feature.
        // Ideally this should be made a singleton somehow, perhaps put in the property metadata.
        this.#rebuildStylesOnPropChange = {};
        this.#rebuildBuilderOnPropChange = {};
        this.__built = false;
        this.__stylesSet = false;
        this.__eventsInitialized = false;
        this.$refs = {};
        this.__args = args;
    }
    /**
     * Used internally to indicate the first time $updateStyles is called.
     * This method is called by the static component builder when the component is created.
     * If a prop is accessed within the style builder, the getter reads this field to mark $updateStyles as a dependency.
    */
    #initializingStyles;
    #initializingBuild;
    // A bit messy but gets us to MVP for this feature.
    // Ideally this should be made a singleton somehow, perhaps put in the property metadata.
    #rebuildStylesOnPropChange;
    #rebuildBuilderOnPropChange;
    /**
     * Called once per component, on the first build.
     * TODO: this shouldn't require an instance of the component. Please experiment with fixing this.
    */
    static initializeComponent(obj) {
        if (!obj.constructor.__dotComponentInitialized) {
            obj.constructor.__dotComponentInitialized = true;
            // Additional generic logic that should run once per component.
            obj.constructor.__dotClassNumb = dot_util_1.ClassPrefix.next;
            obj.constructor.__activePropContainer = function ActivePropContainer(obj) {
                this.__component = obj;
            };
            (0, dot_util_1.eachK)(obj.props, (k, v) => {
                Component.createProp(obj.constructor.__activePropContainer, k);
            });
        }
    }
    static build(obj) {
        Component.initializeComponent(obj);
        dot_util_1.GlobalComponentStack.push(obj);
        obj.created && obj.created(...obj.__args);
        if (obj.__built)
            (0, err_1.default)("CB");
        obj.__built = true;
        obj.__propContainer = {
            activePropConstructor: obj.constructor.__activePropContainer,
            rawProps: obj.props || {},
            activeProps: new obj.constructor.__activePropContainer(obj),
            propDependencies: {},
            bindings: {}
        };
        // eachK(obj.props, (k,v) => {
        // 	// Initialize it.
        // 	cc.__propContainer.activeProps[k] = cc.__propContainer.rawProps[k];
        // });
        obj.props = obj.__propContainer.activeProps;
        (0, dot_util_1.eachK)(obj.__propContainer.rawProps, (k, v) => {
            obj.__propContainer.bindings[k] = [];
            obj.props[k] = v;
        });
        // function ComputedContainer(){
        // };
        // let cc = new ComputedContainer();
        // eachK(obj.computed, function(k, v){
        // 	isF(v) ? v : ERR("XF", "computed")
        // 	//createProp(k, CC);
        // 	ComputedContainer.prototype[k] = v;
        // 	Object.defineProperty(ComputedContainer.prototype, k, {
        // 		enumerable: true,
        // 		get: function(){
        // 			// This was commented out pre-ts.
        // 			//configureDependency(v(), this, k);
        // 			return v.call(obj);
        // 		}
        // 	});
        // });
        // obj.computed = cc;
        Component.initializeEventHandlers(obj);
        Component.rebuild(obj);
        // TODO: would be great to do this without a timer, once the DOM is updated. 
        // May require some type of queueing system within dot.
        obj.ready && (0, dot_util_1.sT)(() => {
            dot_util_1.GlobalComponentStack.push(obj);
            obj.ready();
            dot_util_1.GlobalComponentStack.pop();
        }, 0);
        dot_util_1.GlobalComponentStack.pop();
        return obj.$el;
    }
    /**
     * Called any time the component needs to be completely rebuilt.
    */
    static rebuild(obj) {
        let oldEl = obj.$el;
        if (!obj.__eventsInitialized)
            obj.#initializingBuild = true;
        let ret = obj.builder(...obj.__args);
        obj.#initializingBuild = false;
        let lst = ret.getLast();
        (!lst || (lst.parentNode.childNodes.length > 1)) && (0, err_1.default)("C#", obj.name || obj.constructor.name || "(unnamed obj)");
        // Note: I don't know what the justification was for using $obj.el, but all tests pass without it.
        // It was removed to facilitate rebuilding the component (during a prop change).
        obj["__$el"] = /*obj.$el ||*/ lst;
        obj.$el["__dothtml_component"] = obj;
        if (oldEl) {
            // Clean it up and replace it with the new element!
        }
        // TODO: would there be a way to not have to create obj function for each instance?
        if (obj.style) {
            // obj will be the officially supported way to use dothtml.
            obj.$styleBuilder = function () {
                // dot.css.scopeToEl(obj.$el, !obj.__stylesSet);
                dot_1.default.css.scopeToEl(obj.$el);
                if (!obj.__stylesSet) {
                    dot_1.default.css.cacheScopedStaticStyles(obj.$el);
                    obj.__stylesSet = true;
                }
                dot_1.default.css.clearDynamicStyles(obj.$el);
                obj.style(dot_1.default.css);
                dot_1.default.css.unscope();
            };
            if (!obj.__eventsInitialized)
                obj.#initializingStyles = true;
            obj.$updateStyles();
            obj.#initializingStyles = false;
            //styler();
        }
        obj.built && obj.built();
    }
    static initializeEventHandlers(obj) {
        if (!obj.__eventsInitialized) {
            obj.__eventsInitialized = true;
            (0, dot_util_1.eachK)(obj.events, (k, v) => {
                obj.events[k] = function () {
                    for (let f of obj.events[k]["__handlers"]) {
                        f.apply(this, arguments);
                    }
                };
                obj.events[k]["__handlers"] = [];
            });
        }
    }
    static createProp(activePropContainer, name) {
        // var dependencies = [];
        Object.defineProperty(activePropContainer.prototype, name, {
            configurable: false,
            enumerable: false,
            get: function () {
                dot_1.default["__lastProp"] = name;
                dot_1.default["__lastIndex"] = null;
                dot_1.default["__lastComponent"] = this.__component;
                let rawProp = this.__component.__propContainer.rawProps[name];
                Component.configureDependency(this.__component, name);
                return rawProp;
            },
            set: function (value) {
                // TODO: if this value is set, get the list of dependencies, and update them by calling their dot argument callbacks.
                let propVal = value;
                if (value instanceof Array) {
                    propVal = new observable_array_1.default(value);
                    propVal.addEventListener("read", e => {
                        dot_1.default["__lastIndex"] = e.index;
                    });
                }
                this.__component.__propContainer.rawProps[name] = propVal;
                for (let b of this.__component.__propContainer.bindings[name]) {
                    (0, dot_1.default)(b.element).as(dot_1.default.input).setVal(propVal);
                }
                Component.updateProp(this.__component, name);
                return propVal;
            }
        });
    }
    static configureDependency(cc, name) {
        // TODO: verify that there is no memory leak!!
        var cb = dot_1.default["__currentArgCallback"][dot_1.default["__currentArgCallback"].length - 1];
        if (cb) {
            // This means this getter is being used during the invocation of an arg callback.
            // Add it to a collection so that when the value is set, the appropriate component will update.
            let rawProp = cc.__propContainer.rawProps[name];
            if (rawProp instanceof observable_array_1.default) {
                rawProp.addEventListener("itemadded", function (e) {
                    // TODO: More test cases to create:
                    // TODO: what about rendering the list length or something?
                    // TODO: what about a computed field based on length?
                    if (cb instanceof arg_callback_obj_1.ArrayArgCallback) {
                        cb.dotTarget._appendOrCreateDocument(cb.f(e.item, e.index), undefined, e.index);
                    }
                    else if (cb) {
                        Component.updateProp(cc, name);
                    }
                });
                rawProp.addEventListener("itemset", function (e) {
                    if (cb instanceof arg_callback_obj_1.ArrayArgCallback) {
                        var p = cb.dotTarget.__document;
                        var el = p.childNodes[e.index];
                        p.removeChild(el);
                        cb.dotTarget._appendOrCreateDocument(cb.f(e.item, e.index), undefined, e.index);
                    }
                    else if (cb) {
                        Component.updateProp(cc, name);
                    }
                });
                rawProp.addEventListener("itemremoved", function (e) {
                    if (cb instanceof arg_callback_obj_1.ArrayArgCallback) {
                        cb.dotTarget.__document.removeChild(cb.dotTarget.__document.childNodes[e.index]);
                    }
                    else if (cb) {
                        Component.updateProp(cc, name);
                    }
                });
            }
            else {
            }
            var ar = cc.__propContainer.propDependencies[name];
            if (!ar)
                ar = cc.__propContainer.propDependencies[name] = [];
            ar.push(cb);
        }
        // Again I find this a weird way to do it that kind of side-steps the above approach, but it gets the job done and is dead simple.
        if (cc.#initializingStyles) {
            cc.#rebuildStylesOnPropChange[name] = true;
        }
        if (cc.#initializingBuild) {
            cc.#rebuildBuilderOnPropChange[name] = true;
        }
    }
    static updateProp(obj, name) {
        let ar = obj.__propContainer.propDependencies[name];
        let value = obj.__propContainer.rawProps[name];
        // // {f:contentCallback,startNode:startNode, endNode:endNode,condition:condition}
        let updateStyles = false;
        if (false) {}
        else {
            // Maybe update specific areas.
            // This is admittedly more efficient.
            for (let i = 0; i < (ar || []).length; i++) {
                let arg = ar[i];
                // TODO: this could be used to update attributes.
                // But right now that relies exclusively on function setters. It's a bit weird.
                arg.updateContent(dot_1.default, value);
                if (obj.#rebuildStylesOnPropChange[name] || (arg instanceof arg_callback_obj_1.AttrArgCallback && arg.attr == "class")) {
                    updateStyles = true;
                }
            }
        }
        if (updateStyles)
            obj.$updateStyles();
    }
    /**
     * An optional function that gets called before the component is created, scoped to the new component object.
     */
    created(...args) { }
    /**
     * An optional function called after the element has been added. One parameter will be provided containing the added element.
     */
    ready() { }
    /**
     * An optional function called before the component is deleted.
     */
    deleting() { }
    /**
     * An optional function called after the component is deleted.
     */
    deleted() { }
    /**
     * An optional function called after the component is built.
     */
    built() { }
    on(event, handler) {
        Component.initializeEventHandlers(this);
        let e = this.events && this.events[event];
        if (!e)
            (0, err_1.default)("UE", event);
        let handlers = e["__handlers"];
        if (handlers.indexOf(handler) == -1) {
            handlers.push(handler);
        }
    }
    off(event, handler) {
        let e = this.events && this.events[event];
        if (!e)
            (0, err_1.default)("UE", event);
        let handlers = e["__handlers"];
        let i = handlers.indexOf(handler);
        if (i > -1) {
            handlers.splice(i, 1);
        }
    }
    /**
     * The main element of this component - automatically set after the builder is called.
    */
    get $el() {
        return this.__$el;
    }
    $updateStyles() {
        this.$styleBuilder && this.$styleBuilder();
    }
}
exports["default"] = Component;
// Eventually we'd like to set this up. Might be overkill.
// function component<T extends { new (...args: any[]): {} }>(constructor: T) {
// 	return class extends constructor {
// 	  
// 	};
// }
//# sourceMappingURL=component.js.map

/***/ }),

/***/ "./node_modules/dothtml/lib/dot-util.js":
/*!**********************************************!*\
  !*** ./node_modules/dothtml/lib/dot-util.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {


// Polyfill for Object.keys(...).forEach.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.numberStep = exports.floatRegex = exports.GlobalComponentStack = exports.ClassPrefix = exports.str = exports.sT = exports.isF = exports.eachK = void 0;
function eachK(obj, cb) {
    if (obj) {
        var lst = Object.keys(obj);
        for (var i = 0; i < lst.length; i++)
            cb(lst[i], obj[lst[i]]);
    }
}
exports.eachK = eachK;
function isF(v) {
    return v && v.constructor && v.call && v.apply;
}
exports.isF = isF;
exports.sT = setTimeout;
function str(s, v) { return (s || "").toString(v); } // This function seems really weird.
exports.str = str;
class _ClassPrefix {
    constructor() {
        this.current = 0x10000;
    }
    reset() {
        this.current = 0x10000;
    }
    get next() {
        return this.current++;
    }
}
exports.ClassPrefix = new _ClassPrefix();
exports.GlobalComponentStack = [];
exports.floatRegex = new RegExp("[-+]?[0-9]*\\.?[0-9]+(?:[eE][-+]?[0-9]+)?", "g");
/**
 * Function that takes in a bunch of parameters and steps the start value toward the target based on timeRemaining and style.
 * currentValue is the current value.
 * targetValue is the target valaue.
 * timeRemaining is the time remaining in ms.
 * stepProgress is the size of this step.
 * totalDuration is the duration of the entire animation from start to finish (not just this step).
 * style is the type of transition (geometric=exponential, ease, linear).
 * Returns the result.
*/
function numberStep(startValue, targetValue, currentTime, totalDuration, style) {
    startValue = Number(startValue);
    targetValue = Number(targetValue);
    var timeRemaining = totalDuration - currentTime;
    switch (style) {
        case "geometric":
        case "exponential": //This is kind of stupid now that we have ease. I might come back and add it in the future. For now assume ease.
        //	var m = Math.exp(-1 / timeRemaining);
        //	return  targetValue + m * (startValue - targetValue);
        case "ease":
            var m = (-Math.cos(Math.PI * (currentTime / totalDuration)) + 1) * 0.5;
            return startValue + m * (targetValue - startValue);
        case "linear":
        default:
            return startValue + (targetValue - startValue) * (currentTime / totalDuration);
    }
}
exports.numberStep = numberStep;
//# sourceMappingURL=dot-util.js.map

/***/ }),

/***/ "./node_modules/dothtml/lib/dothtml.js":
/*!*********************************************!*\
  !*** ./node_modules/dothtml/lib/dothtml.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DotComponent = exports.dot = void 0;
const dot_1 = __importDefault(__webpack_require__(/*! ./dot */ "./node_modules/dothtml/lib/dot.js"));
exports.dot = dot_1.default;
const component_1 = __importDefault(__webpack_require__(/*! ./component */ "./node_modules/dothtml/lib/component.js"));
dot_1.default.version = "5.2.10";
dot_1.default.Component = component_1.default;
var component_2 = __webpack_require__(/*! ./component */ "./node_modules/dothtml/lib/component.js");
Object.defineProperty(exports, "DotComponent", ({ enumerable: true, get: function () { return __importDefault(component_2).default; } }));
// https://www.youtube.com/JoshSideris
//# sourceMappingURL=dothtml.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfZG90aHRtbF9saWJfZG90aHRtbF9qcy42MDFjYWQ2OTgyNjg5ZmExOTU4Mi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw4QkFBOEIsR0FBRyx3QkFBd0IsR0FBRywwQkFBMEIsR0FBRyx1QkFBdUIsR0FBRyxtQkFBbUI7QUFDdEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5Qjs7Ozs7Ozs7OztBQy9EYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDJDQUEyQyxtQkFBTyxDQUFDLDBFQUFvQjtBQUN2RSw4QkFBOEIsbUJBQU8sQ0FBQyxnREFBTztBQUM3QyxtQkFBbUIsbUJBQU8sQ0FBQywwREFBWTtBQUN2Qyw4QkFBOEIsbUJBQU8sQ0FBQyxnREFBTztBQUM3QywyQkFBMkIsbUJBQU8sQ0FBQywwRUFBb0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsWUFBWSxLQUF5RSxFQUFFLEVBRTlFO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHVCQUF1QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWU7QUFDZjtBQUNBLGtDQUFrQywwQkFBMEI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQ3hVYTtBQUNiO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQixHQUFHLGtCQUFrQixHQUFHLDRCQUE0QixHQUFHLG1CQUFtQixHQUFHLFdBQVcsR0FBRyxVQUFVLEdBQUcsV0FBVyxHQUFHLGFBQWE7QUFDcko7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVixxQkFBcUIsZ0NBQWdDO0FBQ3JELFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLDRCQUE0QjtBQUM1QixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCOzs7Ozs7Ozs7O0FDN0RhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CLEdBQUcsV0FBVztBQUNsQyw4QkFBOEIsbUJBQU8sQ0FBQyxnREFBTztBQUM3QyxXQUFXO0FBQ1gsb0NBQW9DLG1CQUFPLENBQUMsNERBQWE7QUFDekQ7QUFDQTtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLDREQUFhO0FBQ3ZDLGdEQUErQyxFQUFFLHFDQUFxQyxnREFBZ0QsRUFBQztBQUN2STtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2VkZGluZy13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2RvdGh0bWwvbGliL2FyZy1jYWxsYmFjay1vYmouanMiLCJ3ZWJwYWNrOi8vd2VkZGluZy13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2RvdGh0bWwvbGliL2NvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly93ZWRkaW5nLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZG90aHRtbC9saWIvZG90LXV0aWwuanMiLCJ3ZWJwYWNrOi8vd2VkZGluZy13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2RvdGh0bWwvbGliL2RvdGh0bWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5Db25kaXRpb25hbEFyZ0NhbGxiYWNrID0gZXhwb3J0cy5BcnJheUFyZ0NhbGxiYWNrID0gZXhwb3J0cy5Db250ZW50QXJnQ2FsbGJhY2sgPSBleHBvcnRzLkF0dHJBcmdDYWxsYmFjayA9IGV4cG9ydHMuQXJnQ2FsbGJhY2sgPSB2b2lkIDA7XHJcbmNsYXNzIEFyZ0NhbGxiYWNrIHtcclxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5lbCA9IGVsZW1lbnQ7XHJcbiAgICAgICAgdGhpcy5mID0gdmFsdWU7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5BcmdDYWxsYmFjayA9IEFyZ0NhbGxiYWNrO1xyXG5jbGFzcyBBdHRyQXJnQ2FsbGJhY2sgZXh0ZW5kcyBBcmdDYWxsYmFjayB7XHJcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCBhdHRyaWJ1dGVOYW1lLCB2YWx1ZSkge1xyXG4gICAgICAgIHN1cGVyKGVsZW1lbnQsIHZhbHVlKTtcclxuICAgICAgICB0aGlzLmF0dHIgPSBhdHRyaWJ1dGVOYW1lO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlQ29udGVudChkb3QpIHtcclxuICAgICAgICB0aGlzLmVsLnNldEF0dHJpYnV0ZSh0aGlzLmF0dHIsIHRoaXMuZigpKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkF0dHJBcmdDYWxsYmFjayA9IEF0dHJBcmdDYWxsYmFjaztcclxuY2xhc3MgQ29udGVudEFyZ0NhbGxiYWNrIGV4dGVuZHMgQXJnQ2FsbGJhY2sge1xyXG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgY29udGVudCkge1xyXG4gICAgICAgIHN1cGVyKGVsZW1lbnQsIGNvbnRlbnQpO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlQ29udGVudChkb3QsIHByb3BWYWwpIHtcclxuICAgICAgICBkb3QodGhpcy5lbCkuZW1wdHkoKS5oKHRoaXMuZihwcm9wVmFsKSk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5Db250ZW50QXJnQ2FsbGJhY2sgPSBDb250ZW50QXJnQ2FsbGJhY2s7XHJcbmNsYXNzIEFycmF5QXJnQ2FsbGJhY2sgZXh0ZW5kcyBBcmdDYWxsYmFjayB7XHJcbiAgICBjb25zdHJ1Y3Rvcihkb3RUYXJnZXQsIGNvbnRlbnQpIHtcclxuICAgICAgICBzdXBlcihudWxsLCBjb250ZW50KTtcclxuICAgICAgICB0aGlzLmRvdFRhcmdldCA9IGRvdFRhcmdldDtcclxuICAgIH1cclxuICAgIHVwZGF0ZUNvbnRlbnQoKSB7IH1cclxufVxyXG5leHBvcnRzLkFycmF5QXJnQ2FsbGJhY2sgPSBBcnJheUFyZ0NhbGxiYWNrO1xyXG5jbGFzcyBDb25kaXRpb25hbEFyZ0NhbGxiYWNrIGV4dGVuZHMgQXJnQ2FsbGJhY2sge1xyXG4gICAgY29uc3RydWN0b3Ioc3RhcnROb2RlLCBlbmROb2RlLCBjb250ZW50LCBjb25kaXRpb24pIHtcclxuICAgICAgICBzdXBlcihudWxsLCBjb250ZW50KTtcclxuICAgICAgICB0aGlzLnN0YXJ0Tm9kZSA9IHN0YXJ0Tm9kZTtcclxuICAgICAgICB0aGlzLmVuZE5vZGUgPSBlbmROb2RlO1xyXG4gICAgICAgIHRoaXMuY29uZGl0aW9uID0gY29uZGl0aW9uO1xyXG4gICAgICAgIHRoaXMubGFzdFZhbHVlID0gdW5kZWZpbmVkOyAvLyBUaGlzIHdpbGwgYmUgc2V0IGJ5IHRoZSBjYWxsaW5nIGNvZGUgLSBhZnRlciB0aGUgb2JqZWN0IGlzIGFkZGVkIHRvIF9fY3VycmVudEFyZ0NhbGxiYWNrLlxyXG4gICAgfVxyXG4gICAgdXBkYXRlQ29udGVudChkb3QpIHtcclxuICAgICAgICBpZiAodGhpcy5sYXN0VmFsdWUgIT0gISF0aGlzLmNvbmRpdGlvbigpKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGFzdFZhbHVlID0gIXRoaXMubGFzdFZhbHVlO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5sYXN0VmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGRvdC5fYXBwZW5kT3JDcmVhdGVEb2N1bWVudCh0aGlzLmYsIHRoaXMuZW5kTm9kZS5wYXJlbnROb2RlLCB0aGlzLmVuZE5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlID0gdGhpcy5zdGFydE5vZGUubmV4dFNpYmxpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUgJiYgZSAhPSB0aGlzLmVuZE5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKHRoaXMuc3RhcnROb2RlLm5leHRTaWJsaW5nICYmIHRoaXMuc3RhcnROb2RlLm5leHRTaWJsaW5nICE9IHRoaXMuZW5kTm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5Db25kaXRpb25hbEFyZ0NhbGxiYWNrID0gQ29uZGl0aW9uYWxBcmdDYWxsYmFjaztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXJnLWNhbGxiYWNrLW9iai5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBvYnNlcnZhYmxlX2FycmF5XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vb2JzZXJ2YWJsZS1hcnJheVwiKSk7XHJcbmNvbnN0IGRvdF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2RvdFwiKSk7XHJcbmNvbnN0IGRvdF91dGlsXzEgPSByZXF1aXJlKFwiLi9kb3QtdXRpbFwiKTtcclxuY29uc3QgZXJyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vZXJyXCIpKTtcclxuY29uc3QgYXJnX2NhbGxiYWNrX29ial8xID0gcmVxdWlyZShcIi4vYXJnLWNhbGxiYWNrLW9ialwiKTtcclxuY2xhc3MgQ29tcG9uZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVc2VkIGludGVybmFsbHkgdG8gaW5kaWNhdGUgdGhlIGZpcnN0IHRpbWUgJHVwZGF0ZVN0eWxlcyBpcyBjYWxsZWQuXHJcbiAgICAgICAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIGJ5IHRoZSBzdGF0aWMgY29tcG9uZW50IGJ1aWxkZXIgd2hlbiB0aGUgY29tcG9uZW50IGlzIGNyZWF0ZWQuXHJcbiAgICAgICAgICogSWYgYSBwcm9wIGlzIGFjY2Vzc2VkIHdpdGhpbiB0aGUgc3R5bGUgYnVpbGRlciwgdGhlIGdldHRlciByZWFkcyB0aGlzIGZpZWxkIHRvIG1hcmsgJHVwZGF0ZVN0eWxlcyBhcyBhIGRlcGVuZGVuY3kuXHJcbiAgICAgICAgKi9cclxuICAgICAgICB0aGlzLiNpbml0aWFsaXppbmdTdHlsZXMgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLiNpbml0aWFsaXppbmdCdWlsZCA9IGZhbHNlO1xyXG4gICAgICAgIC8vIEEgYml0IG1lc3N5IGJ1dCBnZXRzIHVzIHRvIE1WUCBmb3IgdGhpcyBmZWF0dXJlLlxyXG4gICAgICAgIC8vIElkZWFsbHkgdGhpcyBzaG91bGQgYmUgbWFkZSBhIHNpbmdsZXRvbiBzb21laG93LCBwZXJoYXBzIHB1dCBpbiB0aGUgcHJvcGVydHkgbWV0YWRhdGEuXHJcbiAgICAgICAgdGhpcy4jcmVidWlsZFN0eWxlc09uUHJvcENoYW5nZSA9IHt9O1xyXG4gICAgICAgIHRoaXMuI3JlYnVpbGRCdWlsZGVyT25Qcm9wQ2hhbmdlID0ge307XHJcbiAgICAgICAgdGhpcy5fX2J1aWx0ID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fX3N0eWxlc1NldCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX19ldmVudHNJbml0aWFsaXplZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuJHJlZnMgPSB7fTtcclxuICAgICAgICB0aGlzLl9fYXJncyA9IGFyZ3M7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVzZWQgaW50ZXJuYWxseSB0byBpbmRpY2F0ZSB0aGUgZmlyc3QgdGltZSAkdXBkYXRlU3R5bGVzIGlzIGNhbGxlZC5cclxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBieSB0aGUgc3RhdGljIGNvbXBvbmVudCBidWlsZGVyIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBjcmVhdGVkLlxyXG4gICAgICogSWYgYSBwcm9wIGlzIGFjY2Vzc2VkIHdpdGhpbiB0aGUgc3R5bGUgYnVpbGRlciwgdGhlIGdldHRlciByZWFkcyB0aGlzIGZpZWxkIHRvIG1hcmsgJHVwZGF0ZVN0eWxlcyBhcyBhIGRlcGVuZGVuY3kuXHJcbiAgICAqL1xyXG4gICAgI2luaXRpYWxpemluZ1N0eWxlcztcclxuICAgICNpbml0aWFsaXppbmdCdWlsZDtcclxuICAgIC8vIEEgYml0IG1lc3N5IGJ1dCBnZXRzIHVzIHRvIE1WUCBmb3IgdGhpcyBmZWF0dXJlLlxyXG4gICAgLy8gSWRlYWxseSB0aGlzIHNob3VsZCBiZSBtYWRlIGEgc2luZ2xldG9uIHNvbWVob3csIHBlcmhhcHMgcHV0IGluIHRoZSBwcm9wZXJ0eSBtZXRhZGF0YS5cclxuICAgICNyZWJ1aWxkU3R5bGVzT25Qcm9wQ2hhbmdlO1xyXG4gICAgI3JlYnVpbGRCdWlsZGVyT25Qcm9wQ2hhbmdlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgb25jZSBwZXIgY29tcG9uZW50LCBvbiB0aGUgZmlyc3QgYnVpbGQuXHJcbiAgICAgKiBUT0RPOiB0aGlzIHNob3VsZG4ndCByZXF1aXJlIGFuIGluc3RhbmNlIG9mIHRoZSBjb21wb25lbnQuIFBsZWFzZSBleHBlcmltZW50IHdpdGggZml4aW5nIHRoaXMuXHJcbiAgICAqL1xyXG4gICAgc3RhdGljIGluaXRpYWxpemVDb21wb25lbnQob2JqKSB7XHJcbiAgICAgICAgaWYgKCFvYmouY29uc3RydWN0b3IuX19kb3RDb21wb25lbnRJbml0aWFsaXplZCkge1xyXG4gICAgICAgICAgICBvYmouY29uc3RydWN0b3IuX19kb3RDb21wb25lbnRJbml0aWFsaXplZCA9IHRydWU7XHJcbiAgICAgICAgICAgIC8vIEFkZGl0aW9uYWwgZ2VuZXJpYyBsb2dpYyB0aGF0IHNob3VsZCBydW4gb25jZSBwZXIgY29tcG9uZW50LlxyXG4gICAgICAgICAgICBvYmouY29uc3RydWN0b3IuX19kb3RDbGFzc051bWIgPSBkb3RfdXRpbF8xLkNsYXNzUHJlZml4Lm5leHQ7XHJcbiAgICAgICAgICAgIG9iai5jb25zdHJ1Y3Rvci5fX2FjdGl2ZVByb3BDb250YWluZXIgPSBmdW5jdGlvbiBBY3RpdmVQcm9wQ29udGFpbmVyKG9iaikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2NvbXBvbmVudCA9IG9iajtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgKDAsIGRvdF91dGlsXzEuZWFjaEspKG9iai5wcm9wcywgKGssIHYpID0+IHtcclxuICAgICAgICAgICAgICAgIENvbXBvbmVudC5jcmVhdGVQcm9wKG9iai5jb25zdHJ1Y3Rvci5fX2FjdGl2ZVByb3BDb250YWluZXIsIGspO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYnVpbGQob2JqKSB7XHJcbiAgICAgICAgQ29tcG9uZW50LmluaXRpYWxpemVDb21wb25lbnQob2JqKTtcclxuICAgICAgICBkb3RfdXRpbF8xLkdsb2JhbENvbXBvbmVudFN0YWNrLnB1c2gob2JqKTtcclxuICAgICAgICBvYmouY3JlYXRlZCAmJiBvYmouY3JlYXRlZCguLi5vYmouX19hcmdzKTtcclxuICAgICAgICBpZiAob2JqLl9fYnVpbHQpXHJcbiAgICAgICAgICAgICgwLCBlcnJfMS5kZWZhdWx0KShcIkNCXCIpO1xyXG4gICAgICAgIG9iai5fX2J1aWx0ID0gdHJ1ZTtcclxuICAgICAgICBvYmouX19wcm9wQ29udGFpbmVyID0ge1xyXG4gICAgICAgICAgICBhY3RpdmVQcm9wQ29uc3RydWN0b3I6IG9iai5jb25zdHJ1Y3Rvci5fX2FjdGl2ZVByb3BDb250YWluZXIsXHJcbiAgICAgICAgICAgIHJhd1Byb3BzOiBvYmoucHJvcHMgfHwge30sXHJcbiAgICAgICAgICAgIGFjdGl2ZVByb3BzOiBuZXcgb2JqLmNvbnN0cnVjdG9yLl9fYWN0aXZlUHJvcENvbnRhaW5lcihvYmopLFxyXG4gICAgICAgICAgICBwcm9wRGVwZW5kZW5jaWVzOiB7fSxcclxuICAgICAgICAgICAgYmluZGluZ3M6IHt9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBlYWNoSyhvYmoucHJvcHMsIChrLHYpID0+IHtcclxuICAgICAgICAvLyBcdC8vIEluaXRpYWxpemUgaXQuXHJcbiAgICAgICAgLy8gXHRjYy5fX3Byb3BDb250YWluZXIuYWN0aXZlUHJvcHNba10gPSBjYy5fX3Byb3BDb250YWluZXIucmF3UHJvcHNba107XHJcbiAgICAgICAgLy8gfSk7XHJcbiAgICAgICAgb2JqLnByb3BzID0gb2JqLl9fcHJvcENvbnRhaW5lci5hY3RpdmVQcm9wcztcclxuICAgICAgICAoMCwgZG90X3V0aWxfMS5lYWNoSykob2JqLl9fcHJvcENvbnRhaW5lci5yYXdQcm9wcywgKGssIHYpID0+IHtcclxuICAgICAgICAgICAgb2JqLl9fcHJvcENvbnRhaW5lci5iaW5kaW5nc1trXSA9IFtdO1xyXG4gICAgICAgICAgICBvYmoucHJvcHNba10gPSB2O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIGZ1bmN0aW9uIENvbXB1dGVkQ29udGFpbmVyKCl7XHJcbiAgICAgICAgLy8gfTtcclxuICAgICAgICAvLyBsZXQgY2MgPSBuZXcgQ29tcHV0ZWRDb250YWluZXIoKTtcclxuICAgICAgICAvLyBlYWNoSyhvYmouY29tcHV0ZWQsIGZ1bmN0aW9uKGssIHYpe1xyXG4gICAgICAgIC8vIFx0aXNGKHYpID8gdiA6IEVSUihcIlhGXCIsIFwiY29tcHV0ZWRcIilcclxuICAgICAgICAvLyBcdC8vY3JlYXRlUHJvcChrLCBDQyk7XHJcbiAgICAgICAgLy8gXHRDb21wdXRlZENvbnRhaW5lci5wcm90b3R5cGVba10gPSB2O1xyXG4gICAgICAgIC8vIFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXB1dGVkQ29udGFpbmVyLnByb3RvdHlwZSwgaywge1xyXG4gICAgICAgIC8vIFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIC8vIFx0XHRnZXQ6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgLy8gXHRcdFx0Ly8gVGhpcyB3YXMgY29tbWVudGVkIG91dCBwcmUtdHMuXHJcbiAgICAgICAgLy8gXHRcdFx0Ly9jb25maWd1cmVEZXBlbmRlbmN5KHYoKSwgdGhpcywgayk7XHJcbiAgICAgICAgLy8gXHRcdFx0cmV0dXJuIHYuY2FsbChvYmopO1xyXG4gICAgICAgIC8vIFx0XHR9XHJcbiAgICAgICAgLy8gXHR9KTtcclxuICAgICAgICAvLyB9KTtcclxuICAgICAgICAvLyBvYmouY29tcHV0ZWQgPSBjYztcclxuICAgICAgICBDb21wb25lbnQuaW5pdGlhbGl6ZUV2ZW50SGFuZGxlcnMob2JqKTtcclxuICAgICAgICBDb21wb25lbnQucmVidWlsZChvYmopO1xyXG4gICAgICAgIC8vIFRPRE86IHdvdWxkIGJlIGdyZWF0IHRvIGRvIHRoaXMgd2l0aG91dCBhIHRpbWVyLCBvbmNlIHRoZSBET00gaXMgdXBkYXRlZC4gXHJcbiAgICAgICAgLy8gTWF5IHJlcXVpcmUgc29tZSB0eXBlIG9mIHF1ZXVlaW5nIHN5c3RlbSB3aXRoaW4gZG90LlxyXG4gICAgICAgIG9iai5yZWFkeSAmJiAoMCwgZG90X3V0aWxfMS5zVCkoKCkgPT4ge1xyXG4gICAgICAgICAgICBkb3RfdXRpbF8xLkdsb2JhbENvbXBvbmVudFN0YWNrLnB1c2gob2JqKTtcclxuICAgICAgICAgICAgb2JqLnJlYWR5KCk7XHJcbiAgICAgICAgICAgIGRvdF91dGlsXzEuR2xvYmFsQ29tcG9uZW50U3RhY2sucG9wKCk7XHJcbiAgICAgICAgfSwgMCk7XHJcbiAgICAgICAgZG90X3V0aWxfMS5HbG9iYWxDb21wb25lbnRTdGFjay5wb3AoKTtcclxuICAgICAgICByZXR1cm4gb2JqLiRlbDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIGFueSB0aW1lIHRoZSBjb21wb25lbnQgbmVlZHMgdG8gYmUgY29tcGxldGVseSByZWJ1aWx0LlxyXG4gICAgKi9cclxuICAgIHN0YXRpYyByZWJ1aWxkKG9iaikge1xyXG4gICAgICAgIGxldCBvbGRFbCA9IG9iai4kZWw7XHJcbiAgICAgICAgaWYgKCFvYmouX19ldmVudHNJbml0aWFsaXplZClcclxuICAgICAgICAgICAgb2JqLiNpbml0aWFsaXppbmdCdWlsZCA9IHRydWU7XHJcbiAgICAgICAgbGV0IHJldCA9IG9iai5idWlsZGVyKC4uLm9iai5fX2FyZ3MpO1xyXG4gICAgICAgIG9iai4jaW5pdGlhbGl6aW5nQnVpbGQgPSBmYWxzZTtcclxuICAgICAgICBsZXQgbHN0ID0gcmV0LmdldExhc3QoKTtcclxuICAgICAgICAoIWxzdCB8fCAobHN0LnBhcmVudE5vZGUuY2hpbGROb2Rlcy5sZW5ndGggPiAxKSkgJiYgKDAsIGVycl8xLmRlZmF1bHQpKFwiQyNcIiwgb2JqLm5hbWUgfHwgb2JqLmNvbnN0cnVjdG9yLm5hbWUgfHwgXCIodW5uYW1lZCBvYmopXCIpO1xyXG4gICAgICAgIC8vIE5vdGU6IEkgZG9uJ3Qga25vdyB3aGF0IHRoZSBqdXN0aWZpY2F0aW9uIHdhcyBmb3IgdXNpbmcgJG9iai5lbCwgYnV0IGFsbCB0ZXN0cyBwYXNzIHdpdGhvdXQgaXQuXHJcbiAgICAgICAgLy8gSXQgd2FzIHJlbW92ZWQgdG8gZmFjaWxpdGF0ZSByZWJ1aWxkaW5nIHRoZSBjb21wb25lbnQgKGR1cmluZyBhIHByb3AgY2hhbmdlKS5cclxuICAgICAgICBvYmpbXCJfXyRlbFwiXSA9IC8qb2JqLiRlbCB8fCovIGxzdDtcclxuICAgICAgICBvYmouJGVsW1wiX19kb3RodG1sX2NvbXBvbmVudFwiXSA9IG9iajtcclxuICAgICAgICBpZiAob2xkRWwpIHtcclxuICAgICAgICAgICAgLy8gQ2xlYW4gaXQgdXAgYW5kIHJlcGxhY2UgaXQgd2l0aCB0aGUgbmV3IGVsZW1lbnQhXHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRPRE86IHdvdWxkIHRoZXJlIGJlIGEgd2F5IHRvIG5vdCBoYXZlIHRvIGNyZWF0ZSBvYmogZnVuY3Rpb24gZm9yIGVhY2ggaW5zdGFuY2U/XHJcbiAgICAgICAgaWYgKG9iai5zdHlsZSkge1xyXG4gICAgICAgICAgICAvLyBvYmogd2lsbCBiZSB0aGUgb2ZmaWNpYWxseSBzdXBwb3J0ZWQgd2F5IHRvIHVzZSBkb3RodG1sLlxyXG4gICAgICAgICAgICBvYmouJHN0eWxlQnVpbGRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIC8vIGRvdC5jc3Muc2NvcGVUb0VsKG9iai4kZWwsICFvYmouX19zdHlsZXNTZXQpO1xyXG4gICAgICAgICAgICAgICAgZG90XzEuZGVmYXVsdC5jc3Muc2NvcGVUb0VsKG9iai4kZWwpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFvYmouX19zdHlsZXNTZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICBkb3RfMS5kZWZhdWx0LmNzcy5jYWNoZVNjb3BlZFN0YXRpY1N0eWxlcyhvYmouJGVsKTtcclxuICAgICAgICAgICAgICAgICAgICBvYmouX19zdHlsZXNTZXQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZG90XzEuZGVmYXVsdC5jc3MuY2xlYXJEeW5hbWljU3R5bGVzKG9iai4kZWwpO1xyXG4gICAgICAgICAgICAgICAgb2JqLnN0eWxlKGRvdF8xLmRlZmF1bHQuY3NzKTtcclxuICAgICAgICAgICAgICAgIGRvdF8xLmRlZmF1bHQuY3NzLnVuc2NvcGUoKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYgKCFvYmouX19ldmVudHNJbml0aWFsaXplZClcclxuICAgICAgICAgICAgICAgIG9iai4jaW5pdGlhbGl6aW5nU3R5bGVzID0gdHJ1ZTtcclxuICAgICAgICAgICAgb2JqLiR1cGRhdGVTdHlsZXMoKTtcclxuICAgICAgICAgICAgb2JqLiNpbml0aWFsaXppbmdTdHlsZXMgPSBmYWxzZTtcclxuICAgICAgICAgICAgLy9zdHlsZXIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgb2JqLmJ1aWx0ICYmIG9iai5idWlsdCgpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGluaXRpYWxpemVFdmVudEhhbmRsZXJzKG9iaikge1xyXG4gICAgICAgIGlmICghb2JqLl9fZXZlbnRzSW5pdGlhbGl6ZWQpIHtcclxuICAgICAgICAgICAgb2JqLl9fZXZlbnRzSW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAoMCwgZG90X3V0aWxfMS5lYWNoSykob2JqLmV2ZW50cywgKGssIHYpID0+IHtcclxuICAgICAgICAgICAgICAgIG9iai5ldmVudHNba10gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgZiBvZiBvYmouZXZlbnRzW2tdW1wiX19oYW5kbGVyc1wiXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIG9iai5ldmVudHNba11bXCJfX2hhbmRsZXJzXCJdID0gW107XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBjcmVhdGVQcm9wKGFjdGl2ZVByb3BDb250YWluZXIsIG5hbWUpIHtcclxuICAgICAgICAvLyB2YXIgZGVwZW5kZW5jaWVzID0gW107XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFjdGl2ZVByb3BDb250YWluZXIucHJvdG90eXBlLCBuYW1lLCB7XHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGRvdF8xLmRlZmF1bHRbXCJfX2xhc3RQcm9wXCJdID0gbmFtZTtcclxuICAgICAgICAgICAgICAgIGRvdF8xLmRlZmF1bHRbXCJfX2xhc3RJbmRleFwiXSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBkb3RfMS5kZWZhdWx0W1wiX19sYXN0Q29tcG9uZW50XCJdID0gdGhpcy5fX2NvbXBvbmVudDtcclxuICAgICAgICAgICAgICAgIGxldCByYXdQcm9wID0gdGhpcy5fX2NvbXBvbmVudC5fX3Byb3BDb250YWluZXIucmF3UHJvcHNbbmFtZV07XHJcbiAgICAgICAgICAgICAgICBDb21wb25lbnQuY29uZmlndXJlRGVwZW5kZW5jeSh0aGlzLl9fY29tcG9uZW50LCBuYW1lKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByYXdQcm9wO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogaWYgdGhpcyB2YWx1ZSBpcyBzZXQsIGdldCB0aGUgbGlzdCBvZiBkZXBlbmRlbmNpZXMsIGFuZCB1cGRhdGUgdGhlbSBieSBjYWxsaW5nIHRoZWlyIGRvdCBhcmd1bWVudCBjYWxsYmFja3MuXHJcbiAgICAgICAgICAgICAgICBsZXQgcHJvcFZhbCA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9wVmFsID0gbmV3IG9ic2VydmFibGVfYXJyYXlfMS5kZWZhdWx0KHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICBwcm9wVmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJyZWFkXCIsIGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkb3RfMS5kZWZhdWx0W1wiX19sYXN0SW5kZXhcIl0gPSBlLmluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2NvbXBvbmVudC5fX3Byb3BDb250YWluZXIucmF3UHJvcHNbbmFtZV0gPSBwcm9wVmFsO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYiBvZiB0aGlzLl9fY29tcG9uZW50Ll9fcHJvcENvbnRhaW5lci5iaW5kaW5nc1tuYW1lXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICgwLCBkb3RfMS5kZWZhdWx0KShiLmVsZW1lbnQpLmFzKGRvdF8xLmRlZmF1bHQuaW5wdXQpLnNldFZhbChwcm9wVmFsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIENvbXBvbmVudC51cGRhdGVQcm9wKHRoaXMuX19jb21wb25lbnQsIG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3BWYWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBjb25maWd1cmVEZXBlbmRlbmN5KGNjLCBuYW1lKSB7XHJcbiAgICAgICAgLy8gVE9ETzogdmVyaWZ5IHRoYXQgdGhlcmUgaXMgbm8gbWVtb3J5IGxlYWshIVxyXG4gICAgICAgIHZhciBjYiA9IGRvdF8xLmRlZmF1bHRbXCJfX2N1cnJlbnRBcmdDYWxsYmFja1wiXVtkb3RfMS5kZWZhdWx0W1wiX19jdXJyZW50QXJnQ2FsbGJhY2tcIl0ubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgaWYgKGNiKSB7XHJcbiAgICAgICAgICAgIC8vIFRoaXMgbWVhbnMgdGhpcyBnZXR0ZXIgaXMgYmVpbmcgdXNlZCBkdXJpbmcgdGhlIGludm9jYXRpb24gb2YgYW4gYXJnIGNhbGxiYWNrLlxyXG4gICAgICAgICAgICAvLyBBZGQgaXQgdG8gYSBjb2xsZWN0aW9uIHNvIHRoYXQgd2hlbiB0aGUgdmFsdWUgaXMgc2V0LCB0aGUgYXBwcm9wcmlhdGUgY29tcG9uZW50IHdpbGwgdXBkYXRlLlxyXG4gICAgICAgICAgICBsZXQgcmF3UHJvcCA9IGNjLl9fcHJvcENvbnRhaW5lci5yYXdQcm9wc1tuYW1lXTtcclxuICAgICAgICAgICAgaWYgKHJhd1Byb3AgaW5zdGFuY2VvZiBvYnNlcnZhYmxlX2FycmF5XzEuZGVmYXVsdCkge1xyXG4gICAgICAgICAgICAgICAgcmF3UHJvcC5hZGRFdmVudExpc3RlbmVyKFwiaXRlbWFkZGVkXCIsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogTW9yZSB0ZXN0IGNhc2VzIHRvIGNyZWF0ZTpcclxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiB3aGF0IGFib3V0IHJlbmRlcmluZyB0aGUgbGlzdCBsZW5ndGggb3Igc29tZXRoaW5nP1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IHdoYXQgYWJvdXQgYSBjb21wdXRlZCBmaWVsZCBiYXNlZCBvbiBsZW5ndGg/XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNiIGluc3RhbmNlb2YgYXJnX2NhbGxiYWNrX29ial8xLkFycmF5QXJnQ2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2IuZG90VGFyZ2V0Ll9hcHBlbmRPckNyZWF0ZURvY3VtZW50KGNiLmYoZS5pdGVtLCBlLmluZGV4KSwgdW5kZWZpbmVkLCBlLmluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY2IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgQ29tcG9uZW50LnVwZGF0ZVByb3AoY2MsIG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmF3UHJvcC5hZGRFdmVudExpc3RlbmVyKFwiaXRlbXNldFwiLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjYiBpbnN0YW5jZW9mIGFyZ19jYWxsYmFja19vYmpfMS5BcnJheUFyZ0NhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwID0gY2IuZG90VGFyZ2V0Ll9fZG9jdW1lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbCA9IHAuY2hpbGROb2Rlc1tlLmluZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcC5yZW1vdmVDaGlsZChlbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNiLmRvdFRhcmdldC5fYXBwZW5kT3JDcmVhdGVEb2N1bWVudChjYi5mKGUuaXRlbSwgZS5pbmRleCksIHVuZGVmaW5lZCwgZS5pbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIENvbXBvbmVudC51cGRhdGVQcm9wKGNjLCBuYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHJhd1Byb3AuYWRkRXZlbnRMaXN0ZW5lcihcIml0ZW1yZW1vdmVkXCIsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNiIGluc3RhbmNlb2YgYXJnX2NhbGxiYWNrX29ial8xLkFycmF5QXJnQ2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2IuZG90VGFyZ2V0Ll9fZG9jdW1lbnQucmVtb3ZlQ2hpbGQoY2IuZG90VGFyZ2V0Ll9fZG9jdW1lbnQuY2hpbGROb2Rlc1tlLmluZGV4XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIENvbXBvbmVudC51cGRhdGVQcm9wKGNjLCBuYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgYXIgPSBjYy5fX3Byb3BDb250YWluZXIucHJvcERlcGVuZGVuY2llc1tuYW1lXTtcclxuICAgICAgICAgICAgaWYgKCFhcilcclxuICAgICAgICAgICAgICAgIGFyID0gY2MuX19wcm9wQ29udGFpbmVyLnByb3BEZXBlbmRlbmNpZXNbbmFtZV0gPSBbXTtcclxuICAgICAgICAgICAgYXIucHVzaChjYik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEFnYWluIEkgZmluZCB0aGlzIGEgd2VpcmQgd2F5IHRvIGRvIGl0IHRoYXQga2luZCBvZiBzaWRlLXN0ZXBzIHRoZSBhYm92ZSBhcHByb2FjaCwgYnV0IGl0IGdldHMgdGhlIGpvYiBkb25lIGFuZCBpcyBkZWFkIHNpbXBsZS5cclxuICAgICAgICBpZiAoY2MuI2luaXRpYWxpemluZ1N0eWxlcykge1xyXG4gICAgICAgICAgICBjYy4jcmVidWlsZFN0eWxlc09uUHJvcENoYW5nZVtuYW1lXSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjYy4jaW5pdGlhbGl6aW5nQnVpbGQpIHtcclxuICAgICAgICAgICAgY2MuI3JlYnVpbGRCdWlsZGVyT25Qcm9wQ2hhbmdlW25hbWVdID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgdXBkYXRlUHJvcChvYmosIG5hbWUpIHtcclxuICAgICAgICBsZXQgYXIgPSBvYmouX19wcm9wQ29udGFpbmVyLnByb3BEZXBlbmRlbmNpZXNbbmFtZV07XHJcbiAgICAgICAgbGV0IHZhbHVlID0gb2JqLl9fcHJvcENvbnRhaW5lci5yYXdQcm9wc1tuYW1lXTtcclxuICAgICAgICAvLyAvLyB7Zjpjb250ZW50Q2FsbGJhY2ssc3RhcnROb2RlOnN0YXJ0Tm9kZSwgZW5kTm9kZTplbmROb2RlLGNvbmRpdGlvbjpjb25kaXRpb259XHJcbiAgICAgICAgbGV0IHVwZGF0ZVN0eWxlcyA9IGZhbHNlO1xyXG4gICAgICAgIGlmIChmYWxzZSAmJiBvYmouI3JlYnVpbGRCdWlsZGVyT25Qcm9wQ2hhbmdlW25hbWVdICYmICFvYmouI2luaXRpYWxpemluZ0J1aWxkKSB7XHJcbiAgICAgICAgICAgIC8vIENhbGwgdGhlIGJ1aWxkZXIgYWdhaW4uXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBNYXliZSB1cGRhdGUgc3BlY2lmaWMgYXJlYXMuXHJcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYWRtaXR0ZWRseSBtb3JlIGVmZmljaWVudC5cclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAoYXIgfHwgW10pLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgYXJnID0gYXJbaV07XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiB0aGlzIGNvdWxkIGJlIHVzZWQgdG8gdXBkYXRlIGF0dHJpYnV0ZXMuXHJcbiAgICAgICAgICAgICAgICAvLyBCdXQgcmlnaHQgbm93IHRoYXQgcmVsaWVzIGV4Y2x1c2l2ZWx5IG9uIGZ1bmN0aW9uIHNldHRlcnMuIEl0J3MgYSBiaXQgd2VpcmQuXHJcbiAgICAgICAgICAgICAgICBhcmcudXBkYXRlQ29udGVudChkb3RfMS5kZWZhdWx0LCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAob2JqLiNyZWJ1aWxkU3R5bGVzT25Qcm9wQ2hhbmdlW25hbWVdIHx8IChhcmcgaW5zdGFuY2VvZiBhcmdfY2FsbGJhY2tfb2JqXzEuQXR0ckFyZ0NhbGxiYWNrICYmIGFyZy5hdHRyID09IFwiY2xhc3NcIikpIHtcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVTdHlsZXMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh1cGRhdGVTdHlsZXMpXHJcbiAgICAgICAgICAgIG9iai4kdXBkYXRlU3R5bGVzKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFuIG9wdGlvbmFsIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgYmVmb3JlIHRoZSBjb21wb25lbnQgaXMgY3JlYXRlZCwgc2NvcGVkIHRvIHRoZSBuZXcgY29tcG9uZW50IG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgY3JlYXRlZCguLi5hcmdzKSB7IH1cclxuICAgIC8qKlxyXG4gICAgICogQW4gb3B0aW9uYWwgZnVuY3Rpb24gY2FsbGVkIGFmdGVyIHRoZSBlbGVtZW50IGhhcyBiZWVuIGFkZGVkLiBPbmUgcGFyYW1ldGVyIHdpbGwgYmUgcHJvdmlkZWQgY29udGFpbmluZyB0aGUgYWRkZWQgZWxlbWVudC5cclxuICAgICAqL1xyXG4gICAgcmVhZHkoKSB7IH1cclxuICAgIC8qKlxyXG4gICAgICogQW4gb3B0aW9uYWwgZnVuY3Rpb24gY2FsbGVkIGJlZm9yZSB0aGUgY29tcG9uZW50IGlzIGRlbGV0ZWQuXHJcbiAgICAgKi9cclxuICAgIGRlbGV0aW5nKCkgeyB9XHJcbiAgICAvKipcclxuICAgICAqIEFuIG9wdGlvbmFsIGZ1bmN0aW9uIGNhbGxlZCBhZnRlciB0aGUgY29tcG9uZW50IGlzIGRlbGV0ZWQuXHJcbiAgICAgKi9cclxuICAgIGRlbGV0ZWQoKSB7IH1cclxuICAgIC8qKlxyXG4gICAgICogQW4gb3B0aW9uYWwgZnVuY3Rpb24gY2FsbGVkIGFmdGVyIHRoZSBjb21wb25lbnQgaXMgYnVpbHQuXHJcbiAgICAgKi9cclxuICAgIGJ1aWx0KCkgeyB9XHJcbiAgICBvbihldmVudCwgaGFuZGxlcikge1xyXG4gICAgICAgIENvbXBvbmVudC5pbml0aWFsaXplRXZlbnRIYW5kbGVycyh0aGlzKTtcclxuICAgICAgICBsZXQgZSA9IHRoaXMuZXZlbnRzICYmIHRoaXMuZXZlbnRzW2V2ZW50XTtcclxuICAgICAgICBpZiAoIWUpXHJcbiAgICAgICAgICAgICgwLCBlcnJfMS5kZWZhdWx0KShcIlVFXCIsIGV2ZW50KTtcclxuICAgICAgICBsZXQgaGFuZGxlcnMgPSBlW1wiX19oYW5kbGVyc1wiXTtcclxuICAgICAgICBpZiAoaGFuZGxlcnMuaW5kZXhPZihoYW5kbGVyKSA9PSAtMSkge1xyXG4gICAgICAgICAgICBoYW5kbGVycy5wdXNoKGhhbmRsZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9mZihldmVudCwgaGFuZGxlcikge1xyXG4gICAgICAgIGxldCBlID0gdGhpcy5ldmVudHMgJiYgdGhpcy5ldmVudHNbZXZlbnRdO1xyXG4gICAgICAgIGlmICghZSlcclxuICAgICAgICAgICAgKDAsIGVycl8xLmRlZmF1bHQpKFwiVUVcIiwgZXZlbnQpO1xyXG4gICAgICAgIGxldCBoYW5kbGVycyA9IGVbXCJfX2hhbmRsZXJzXCJdO1xyXG4gICAgICAgIGxldCBpID0gaGFuZGxlcnMuaW5kZXhPZihoYW5kbGVyKTtcclxuICAgICAgICBpZiAoaSA+IC0xKSB7XHJcbiAgICAgICAgICAgIGhhbmRsZXJzLnNwbGljZShpLCAxKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBtYWluIGVsZW1lbnQgb2YgdGhpcyBjb21wb25lbnQgLSBhdXRvbWF0aWNhbGx5IHNldCBhZnRlciB0aGUgYnVpbGRlciBpcyBjYWxsZWQuXHJcbiAgICAqL1xyXG4gICAgZ2V0ICRlbCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fXyRlbDtcclxuICAgIH1cclxuICAgICR1cGRhdGVTdHlsZXMoKSB7XHJcbiAgICAgICAgdGhpcy4kc3R5bGVCdWlsZGVyICYmIHRoaXMuJHN0eWxlQnVpbGRlcigpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuZGVmYXVsdCA9IENvbXBvbmVudDtcclxuLy8gRXZlbnR1YWxseSB3ZSdkIGxpa2UgdG8gc2V0IHRoaXMgdXAuIE1pZ2h0IGJlIG92ZXJraWxsLlxyXG4vLyBmdW5jdGlvbiBjb21wb25lbnQ8VCBleHRlbmRzIHsgbmV3ICguLi5hcmdzOiBhbnlbXSk6IHt9IH0+KGNvbnN0cnVjdG9yOiBUKSB7XHJcbi8vIFx0cmV0dXJuIGNsYXNzIGV4dGVuZHMgY29uc3RydWN0b3Ige1xyXG4vLyBcdCAgXHJcbi8vIFx0fTtcclxuLy8gfVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21wb25lbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8vIFBvbHlmaWxsIGZvciBPYmplY3Qua2V5cyguLi4pLmZvckVhY2guXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5udW1iZXJTdGVwID0gZXhwb3J0cy5mbG9hdFJlZ2V4ID0gZXhwb3J0cy5HbG9iYWxDb21wb25lbnRTdGFjayA9IGV4cG9ydHMuQ2xhc3NQcmVmaXggPSBleHBvcnRzLnN0ciA9IGV4cG9ydHMuc1QgPSBleHBvcnRzLmlzRiA9IGV4cG9ydHMuZWFjaEsgPSB2b2lkIDA7XHJcbmZ1bmN0aW9uIGVhY2hLKG9iaiwgY2IpIHtcclxuICAgIGlmIChvYmopIHtcclxuICAgICAgICB2YXIgbHN0ID0gT2JqZWN0LmtleXMob2JqKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxzdC5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgY2IobHN0W2ldLCBvYmpbbHN0W2ldXSk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5lYWNoSyA9IGVhY2hLO1xyXG5mdW5jdGlvbiBpc0Yodikge1xyXG4gICAgcmV0dXJuIHYgJiYgdi5jb25zdHJ1Y3RvciAmJiB2LmNhbGwgJiYgdi5hcHBseTtcclxufVxyXG5leHBvcnRzLmlzRiA9IGlzRjtcclxuZXhwb3J0cy5zVCA9IHNldFRpbWVvdXQ7XHJcbmZ1bmN0aW9uIHN0cihzLCB2KSB7IHJldHVybiAocyB8fCBcIlwiKS50b1N0cmluZyh2KTsgfSAvLyBUaGlzIGZ1bmN0aW9uIHNlZW1zIHJlYWxseSB3ZWlyZC5cclxuZXhwb3J0cy5zdHIgPSBzdHI7XHJcbmNsYXNzIF9DbGFzc1ByZWZpeCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmN1cnJlbnQgPSAweDEwMDAwO1xyXG4gICAgfVxyXG4gICAgcmVzZXQoKSB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gMHgxMDAwMDtcclxuICAgIH1cclxuICAgIGdldCBuZXh0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnQrKztcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkNsYXNzUHJlZml4ID0gbmV3IF9DbGFzc1ByZWZpeCgpO1xyXG5leHBvcnRzLkdsb2JhbENvbXBvbmVudFN0YWNrID0gW107XHJcbmV4cG9ydHMuZmxvYXRSZWdleCA9IG5ldyBSZWdFeHAoXCJbLStdP1swLTldKlxcXFwuP1swLTldKyg/OltlRV1bLStdP1swLTldKyk/XCIsIFwiZ1wiKTtcclxuLyoqXHJcbiAqIEZ1bmN0aW9uIHRoYXQgdGFrZXMgaW4gYSBidW5jaCBvZiBwYXJhbWV0ZXJzIGFuZCBzdGVwcyB0aGUgc3RhcnQgdmFsdWUgdG93YXJkIHRoZSB0YXJnZXQgYmFzZWQgb24gdGltZVJlbWFpbmluZyBhbmQgc3R5bGUuXHJcbiAqIGN1cnJlbnRWYWx1ZSBpcyB0aGUgY3VycmVudCB2YWx1ZS5cclxuICogdGFyZ2V0VmFsdWUgaXMgdGhlIHRhcmdldCB2YWxhdWUuXHJcbiAqIHRpbWVSZW1haW5pbmcgaXMgdGhlIHRpbWUgcmVtYWluaW5nIGluIG1zLlxyXG4gKiBzdGVwUHJvZ3Jlc3MgaXMgdGhlIHNpemUgb2YgdGhpcyBzdGVwLlxyXG4gKiB0b3RhbER1cmF0aW9uIGlzIHRoZSBkdXJhdGlvbiBvZiB0aGUgZW50aXJlIGFuaW1hdGlvbiBmcm9tIHN0YXJ0IHRvIGZpbmlzaCAobm90IGp1c3QgdGhpcyBzdGVwKS5cclxuICogc3R5bGUgaXMgdGhlIHR5cGUgb2YgdHJhbnNpdGlvbiAoZ2VvbWV0cmljPWV4cG9uZW50aWFsLCBlYXNlLCBsaW5lYXIpLlxyXG4gKiBSZXR1cm5zIHRoZSByZXN1bHQuXHJcbiovXHJcbmZ1bmN0aW9uIG51bWJlclN0ZXAoc3RhcnRWYWx1ZSwgdGFyZ2V0VmFsdWUsIGN1cnJlbnRUaW1lLCB0b3RhbER1cmF0aW9uLCBzdHlsZSkge1xyXG4gICAgc3RhcnRWYWx1ZSA9IE51bWJlcihzdGFydFZhbHVlKTtcclxuICAgIHRhcmdldFZhbHVlID0gTnVtYmVyKHRhcmdldFZhbHVlKTtcclxuICAgIHZhciB0aW1lUmVtYWluaW5nID0gdG90YWxEdXJhdGlvbiAtIGN1cnJlbnRUaW1lO1xyXG4gICAgc3dpdGNoIChzdHlsZSkge1xyXG4gICAgICAgIGNhc2UgXCJnZW9tZXRyaWNcIjpcclxuICAgICAgICBjYXNlIFwiZXhwb25lbnRpYWxcIjogLy9UaGlzIGlzIGtpbmQgb2Ygc3R1cGlkIG5vdyB0aGF0IHdlIGhhdmUgZWFzZS4gSSBtaWdodCBjb21lIGJhY2sgYW5kIGFkZCBpdCBpbiB0aGUgZnV0dXJlLiBGb3Igbm93IGFzc3VtZSBlYXNlLlxyXG4gICAgICAgIC8vXHR2YXIgbSA9IE1hdGguZXhwKC0xIC8gdGltZVJlbWFpbmluZyk7XHJcbiAgICAgICAgLy9cdHJldHVybiAgdGFyZ2V0VmFsdWUgKyBtICogKHN0YXJ0VmFsdWUgLSB0YXJnZXRWYWx1ZSk7XHJcbiAgICAgICAgY2FzZSBcImVhc2VcIjpcclxuICAgICAgICAgICAgdmFyIG0gPSAoLU1hdGguY29zKE1hdGguUEkgKiAoY3VycmVudFRpbWUgLyB0b3RhbER1cmF0aW9uKSkgKyAxKSAqIDAuNTtcclxuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0VmFsdWUgKyBtICogKHRhcmdldFZhbHVlIC0gc3RhcnRWYWx1ZSk7XHJcbiAgICAgICAgY2FzZSBcImxpbmVhclwiOlxyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldHVybiBzdGFydFZhbHVlICsgKHRhcmdldFZhbHVlIC0gc3RhcnRWYWx1ZSkgKiAoY3VycmVudFRpbWUgLyB0b3RhbER1cmF0aW9uKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLm51bWJlclN0ZXAgPSBudW1iZXJTdGVwO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kb3QtdXRpbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLkRvdENvbXBvbmVudCA9IGV4cG9ydHMuZG90ID0gdm9pZCAwO1xyXG5jb25zdCBkb3RfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9kb3RcIikpO1xyXG5leHBvcnRzLmRvdCA9IGRvdF8xLmRlZmF1bHQ7XHJcbmNvbnN0IGNvbXBvbmVudF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2NvbXBvbmVudFwiKSk7XHJcbmRvdF8xLmRlZmF1bHQudmVyc2lvbiA9IFwiNS4yLjEwXCI7XHJcbmRvdF8xLmRlZmF1bHQuQ29tcG9uZW50ID0gY29tcG9uZW50XzEuZGVmYXVsdDtcclxudmFyIGNvbXBvbmVudF8yID0gcmVxdWlyZShcIi4vY29tcG9uZW50XCIpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEb3RDb21wb25lbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9faW1wb3J0RGVmYXVsdChjb21wb25lbnRfMikuZGVmYXVsdDsgfSB9KTtcclxuLy8gaHR0cHM6Ly93d3cueW91dHViZS5jb20vSm9zaFNpZGVyaXNcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZG90aHRtbC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=