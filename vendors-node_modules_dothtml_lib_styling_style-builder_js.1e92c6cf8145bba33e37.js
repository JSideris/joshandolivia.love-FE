"use strict";
(self["webpackChunkwedding_website"] = self["webpackChunkwedding_website"] || []).push([["vendors-node_modules_dothtml_lib_styling_style-builder_js"],{

/***/ "./node_modules/dothtml/lib/styling/style-builder.js":
/*!***********************************************************!*\
  !*** ./node_modules/dothtml/lib/styling/style-builder.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._Builder = void 0;
const unit_function_tables_1 = __webpack_require__(/*! ./unit-function-tables */ "./node_modules/dothtml/lib/styling/unit-function-tables.js");
const css_angle_1 = __importDefault(__webpack_require__(/*! ./css-types.ts/css-angle */ "./node_modules/dothtml/lib/styling/css-types.ts/css-angle.js"));
const css_color_1 = __importDefault(__webpack_require__(/*! ./css-types.ts/css-color */ "./node_modules/dothtml/lib/styling/css-types.ts/css-color.js"));
const css_complex_1 = __importDefault(__webpack_require__(/*! ./css-types.ts/css-complex */ "./node_modules/dothtml/lib/styling/css-types.ts/css-complex.js"));
const css_length_1 = __importDefault(__webpack_require__(/*! ./css-types.ts/css-length */ "./node_modules/dothtml/lib/styling/css-types.ts/css-length.js"));
const css_number_1 = __importDefault(__webpack_require__(/*! ./css-types.ts/css-number */ "./node_modules/dothtml/lib/styling/css-types.ts/css-number.js"));
const css_transform_1 = __importDefault(__webpack_require__(/*! ./css-types.ts/css-transform */ "./node_modules/dothtml/lib/styling/css-types.ts/css-transform.js"));
const css_unknown_1 = __importDefault(__webpack_require__(/*! ./css-types.ts/css-unknown */ "./node_modules/dothtml/lib/styling/css-types.ts/css-unknown.js"));
const css_url_1 = __importDefault(__webpack_require__(/*! ./css-types.ts/css-url */ "./node_modules/dothtml/lib/styling/css-types.ts/css-url.js"));
const dot_util_1 = __webpack_require__(/*! ../dot-util */ "./node_modules/dothtml/lib/dot-util.js");
const css_filter_1 = __importDefault(__webpack_require__(/*! ./css-types.ts/css-filter */ "./node_modules/dothtml/lib/styling/css-types.ts/css-filter.js"));
//Latest Update.
/*
* - Wrapped code in anonymous function.
* - Hid _Builder and _StyleProperty.
* - Increased compatibility with IE 8, 9, and 10.
* - Allowed 0-length animations.
* 5.1
* - Typified style builder.
* - Fixed up transformations and redid transform builder.
* - Removed some old junk.
*/
const STATIC_SYLES_ATTR = "data-dot-static-styles";
// Rename this to DotcssHelpers.
// The name Dotcss2 comes from a time when this was a clone of dotcss with "private" members.
class Dotcss2 {
    constructor() {
        //Inverse of framerate in ms/frame.
        // Used for old browsers that don't support requestAnimationFrameframe.
        this.fxInterval = 1000 / 60;
        this.lastBuilder = null;
        this.scopeStack = [];
        this.globalStyleElement = null;
    }
    animateFull(element, jsFriendlyProp, propType, startValue, targetValue, finalValue, currentTime, totalDuration, animationStyle, callback, lastValue) {
        if (lastValue && element.style[jsFriendlyProp] != lastValue)
            return; //Animation can be cancelled any time by setting the value directly.
        if (totalDuration - currentTime > 0) {
            switch (propType) {
                case "color":
                    var r = Math.round((0, dot_util_1.numberStep)(startValue.r, targetValue.r, currentTime, totalDuration, animationStyle));
                    var g = Math.round((0, dot_util_1.numberStep)(startValue.g, targetValue.g, currentTime, totalDuration, animationStyle));
                    var b = Math.round((0, dot_util_1.numberStep)(startValue.b, targetValue.b, currentTime, totalDuration, animationStyle));
                    var a = dotcss.formatNumberValue((0, dot_util_1.numberStep)(startValue.a, targetValue.a, currentTime, totalDuration, animationStyle)); //TODO: make sure this doesn't need to be rounded or something.
                    dotcss(element)[jsFriendlyProp](r, g, b, a);
                    break;
                case "length":
                    dotcss(element)[jsFriendlyProp](dotcss.formatNumberValue((0, dot_util_1.numberStep)(startValue.length, targetValue.length, currentTime, totalDuration, animationStyle), startValue.units) + startValue.units);
                    break;
                case "transformation":
                    var newTransform = "";
                    //startValue and targetValue are guaranteed to have the same template.
                    for (var i = 0; i < startValue.transformations.length; i++) {
                        var t1 = startValue.transformations[i];
                        var t2 = targetValue.transformations[i];
                        newTransform += t1.transformation + "(";
                        for (var k = 0; k < t1.args.length; k++) {
                            var v1 = t1.args[k];
                            var v2 = t2.args[k];
                            var actualV1 = isNaN(v1) ? v1.length || v1.angle || v1.value || 0 : v1;
                            var actualV2 = isNaN(v2) ? v2.length || v2.angle || v2.value || 0 : v2;
                            var units = isNaN(v1) ? v1.units : "";
                            newTransform += dotcss.formatNumberValue((0, dot_util_1.numberStep)(actualV1, actualV2, currentTime, totalDuration, animationStyle), units) + units + ",";
                        }
                        newTransform = newTransform.substring(0, newTransform.length - 1);
                        newTransform += ") ";
                    }
                    dotcss(element)[jsFriendlyProp](newTransform);
                    break;
                default:
                    switch (startValue.type) {
                        case "number":
                            dotcss(element)[jsFriendlyProp](dotcss.formatNumberValue((0, dot_util_1.numberStep)(startValue.value, targetValue.value, currentTime, totalDuration, animationStyle)));
                            break;
                        case "complex":
                            var newVal = "";
                            for (var i = 0; i < startValue.numbers.length; i++) {
                                newVal += startValue.parts[i];
                                newVal += dotcss.formatNumberValue((0, dot_util_1.numberStep)(startValue.numbers[i], targetValue.numbers[i], currentTime, totalDuration, animationStyle));
                            }
                            newVal += startValue.parts[startValue.parts.length - 1];
                            dotcss(element)[jsFriendlyProp](newVal);
                            break;
                        default:
                            console.warn("Unexpected data type for animation.");
                    }
            }
            var now = (window.performance && window.performance.now) ? window.performance.now() : null;
            //var reachedAnimFrame = false;
            //TODO: there could be a memory leak here. Need to investigate.
            //Because we're creating a lot of new functions. Are they being released?
            var last = element.style[jsFriendlyProp];
            var nextStep = function (timestamp) {
                var change = (now ? (window.performance.now() - now) : dotcss2.fxInterval);
                dotcss2.animateFull(element, jsFriendlyProp, propType, startValue, targetValue, finalValue, currentTime + change, totalDuration, animationStyle, callback, last);
            };
            if (window.requestAnimationFrame) {
                window.requestAnimationFrame(nextStep);
                //setTimeout(function(){if(!reachedAnimFrame) console.log("ERROR");}, 100);
            }
            else
                window.setTimeout(nextStep, dotcss2.fxInterval);
        }
        else {
            //TODO: verify that decimal values are properly handled here.
            dotcss(element)[jsFriendlyProp](finalValue);
            if (callback)
                callback();
        }
    }
    //Takes the property and generates all the dotcss and builder functions.
    extendDothtml(prop, jsFriendlyProp, type) {
        //Create the new function by extending the builder.
        let _b = _Builder.prototype;
        _b[jsFriendlyProp] = function () {
            if (arguments.length == 0)
                return this;
            var args = [];
            for (var i = 0; i < arguments.length; i++)
                args.push(arguments[i]);
            // TODO: Why can't I just pass arguments directly into this function?
            // Try it.
            var value = dotcss2.convertStyleIntoDotCssObject(args, type).toString();
            var newCss = prop + ":" + value + ";";
            this.currentCss += newCss;
            // console.log(`SETTING ${jsFriendlyProp}:`, this.toString());
            // this.toString()
            if (this.targets) {
                for (var q = 0; q < this.targets.length; q++) {
                    //this.targets[q].style += newCss;
                    var t = this.targets[q];
                    if (t.tagName == "STYLE")
                        t.innerHTML = t.innerHTML.substring(0, t.innerHTML.length - 1) + prop + ":" + value + ";}";
                    else
                        t.style[jsFriendlyProp] = value;
                }
            }
            return this;
        };
        //Add the new function to the dotcss object so that it can be accessed without doing dotcss().
        dotcss2.addPropFunctionToDotCssObject(jsFriendlyProp);
        //Each unit of length will also have its own version of this function (assuming this is a length property).
        if (type == "length") {
            for (var u = 0; u < unit_function_tables_1.AllLengthUnits.length; u++) {
                var uu = unit_function_tables_1.AllLengthUnits[u];
                (function (uu) {
                    _b[jsFriendlyProp + (uu.jsName || uu.unit)] = function () {
                        for (var i = 0; i < arguments.length; i++)
                            arguments[i] = arguments[i] + uu.unit.toLowerCase();
                        return _b[jsFriendlyProp].apply(this, arguments);
                    };
                })(uu);
                dotcss2.addPropFunctionToDotCssObject(jsFriendlyProp + (uu.jsName || uu.unit));
            }
        }
        //_b[jsFriendlyProp].__proto__ = Object.create(_StyleProperty.prototype);
        _b[jsFriendlyProp].type = type;
        _b[jsFriendlyProp].jsFriendlyProp = jsFriendlyProp;
        // This is weird. It looks like I was trying to implement some form of multilpe inheritance.
        // This should really be upgraded.
        for (var k in _StyleProperty.prototype) {
            if (_b[jsFriendlyProp][k] === undefined)
                _b[jsFriendlyProp][k] = _StyleProperty.prototype[k];
        }
    }
    //Returns a JSON object representation of value specific to the cssDataType passed in.
    convertStyleIntoDotCssObject(value, cssDataType) {
        //if(!value) return null;
        if (!(value instanceof Array))
            value = [value];
        if (cssDataType == "color")
            return new css_color_1.default(value);
        else if (cssDataType == "url")
            return new css_url_1.default(value);
        else if (cssDataType == "length" && (!isNaN(value[0]) || (value[0].indexOf(" ") == -1 && value[0].replace(dot_util_1.floatRegex, "") != value[0])))
            return new css_length_1.default(value[0]);
        else if (cssDataType == "transformation")
            return (new css_transform_1.default(value[0])).toString();
        else if (cssDataType == "filter")
            return (new css_filter_1.default(value[0])).toString();
        else {
            if (value[0] === ""
                || ((isNaN(value[0]))
                    && ("" + value[0]).replace(dot_util_1.floatRegex, "") == value[0]))
                return new css_unknown_1.default(value[0]); //No numbers.
            if (isNaN(value[0]))
                return new css_complex_1.default(value[0]); //Numbers
            else
                return new css_number_1.default(value[0]); //Just a number.
        }
    }
    ;
    //Ensures that two complex values match.
    compareComplexDataTypes(value1, value2) {
        if (value1.type != "complex" || value2.type != "complex")
            return false;
        if (value1.numbers.length != value2.numbers.length)
            return false;
        if (value1.parts.length != value2.parts.length)
            return false;
        for (var i = 0; i < value1.parts.length; i++) {
            if (value1.parts[i] != value2.parts[i])
                return false;
        }
        return true;
    }
    ;
    //Adds a builder function directly to the dotcss object so that dotcss doesn't
    //have to be used as a function when a target doesn't need to be specified.
    addPropFunctionToDotCssObject(funcName) {
        dotcss[funcName] = function () {
            var n = new _Builder();
            return n[funcName].apply(n, arguments);
        };
    }
    ;
    // Might remove this.
    // I think this doesn't work. Removing now. Not sure what it was supposed to do.
    // makeTransformFunction(fn){
    // 	dotcss[fn] = function(){
    // 		var n = new Transform();
    // 		return n[fn].apply(n, arguments);
    // 	};
    // }
    computedStyleOrActualStyle(element, property) {
        return window.getComputedStyle(element)[property] || element.style[property];
    }
    ;
    modDeg(a) {
        if (a < 0)
            a = 360 - ((-a) % 360);
        return a % 360;
    }
    ;
}
const dotcss2 = new Dotcss2();
const dotcss = function (query) {
    //this.currentCss = "";
    var target = null;
    if (query) {
        // console.log(query, "?");
        if (typeof query == "string") {
            // Creating a style tag. Might not be supported forever.
            if (query.length > 2 && query.indexOf("{}") == query.length - 2) {
                // TODO: this needs further testing, particularly when mulitple sytles are set on the same page.
                // Be sure to set up some tests.
                query = query.substring(0, query.length - 2);
                if (!dotcss2.globalStyleElement) {
                    dotcss2.globalStyleElement = document.createElement("style");
                    document.head.appendChild(dotcss2.globalStyleElement);
                }
                target = [dotcss2.globalStyleElement];
                target[0].innerHTML += query + "{}\r\n";
            }
            else {
                // This is overly complicated, but here is the spiel.
                // If there's an element on the scopeStack, it should be used with the querySelectorAll.
                // BUT, querySelectorAll doesn't actually select the element it's currently on, which is a requirement for dothtml.
                // To make matters worse, if we do querySelectorAll on the element's parents, we may accidentally select its siblings!!
                // To fix this, we get a list from querySelectorAll on the element, then push the element itself to that list
                // iff it is in the list of elements queried from its parent.
                // In addition to all of that, we don't want scoped styles to be applied to child components.
                var s0 = dotcss2.scopeStack[0];
                // if(s0 instanceof Component){
                // 	s0 = s0.$el;
                // }
                // If we're doing scoped, and it's an element.
                if (s0 && s0.parentNode && s0.querySelectorAll) {
                    // console.log(s0);
                    target = getScopedNodeList(query, s0);
                }
                else {
                    target = document.querySelectorAll(query);
                }
                // target = referencePt.querySelectorAll(query);
            }
        }
        if ((query instanceof NodeList) || (query instanceof Array))
            target = query;
        if (query instanceof Node)
            target = [query]; //Doesn't need to be a NodeList. Just iterable.
    }
    dotcss2.lastBuilder = new _Builder(target);
    return dotcss2.lastBuilder;
}; // We do this because many of the dotcss methods are generated at runtime. Greatly reduces build size.
dotcss.version = "0.16.0";
function getScopedNodeList(query, s0) {
    // Get all of the matching child elements of the component. This will not include s0 itself, but it does include nested components.
    // So we will need to manipulate this collection.
    // querySelectorAll returns a NodeList, which we need to convert into an Array.
    var target = Array.from(s0.querySelectorAll(query));
    // console.log(query, s0.className);
    // Exclude nested components.
    for (var t = 0; t < target.length; t++) {
        var T = target[t];
        // Is it a nested component??
        if (T["__dothtml_component"]) {
            // It's a component. Remove it, and all of it's descendants.
            target.splice(t, 1);
            t--;
            var subTargets = T.querySelectorAll(query);
            for (var s = 0; s < subTargets.length; s++) {
                let S = subTargets[s];
                target.splice(target.indexOf(S, t + 1), 1);
            }
        }
    }
    // Loop through all the sibling nodes until we find s0.
    var parentTargets = Array.from(s0.parentNode.querySelectorAll(query));
    var p = parentTargets.indexOf(s0);
    if (p != -1) {
        target.unshift(parentTargets[p]);
    }
    return target;
}
/**
 * The dotcss builder gets extended with all of the css functions at runtime.
*/
class _Builder {
    constructor(targets) {
        this.currentCss = "";
        this.targets = targets ?? null;
    }
    toString() {
        // console.log("CALLED TOSTRING!", this.currentCss);
        return this.currentCss;
    }
    // These methods are a bit strange to have here.
    // They should probably be a part of the dotcss core object or something.
    // Also, they're the only items that are explicitly part of the builder rather than generated.
    //Usage:
    //hide()
    //hide(duration, complete)
    //hide(options)
    //Options
    //	display: inline-block, block, etc.
    //	duration: duration in ms.
    //	complete: on-complete callback.
    //	hideStyle: fade, shrink, or normal
    //	animationStyle: linear or exponential
    hide(style) {
        if (this.targets) {
            var arg0 = arguments[0] || {};
            var arg0N = arg0;
            var arg0O = arg0;
            var ops = {};
            ops.duration = arg0O.duration || (isNaN(arg0N) ? 0 : arg0N) || 0;
            //ops.display = arg0.display || "none";
            //ops.opacity = arg0.opacity || null;
            //ops.width = arg0.width || null;
            //ops.height = arg0.height || null;
            ops.complete = arg0O.complete || (typeof arguments[1] == "function" ? arguments[1] : (typeof arguments[2] == "function" ? arguments[2] : function () { }));
            ops.hideStyle = arg0O.hideStyle || "normal";
            ops.animationStyle = arg0O.animationStyle || (typeof arguments[1] == "string" ? arguments[1] : "ease");
            if (ops.duration > 0) {
                let doneCnt = 0;
                let m = 0;
                let q = this.targets.length;
                for (let i = 0; i < this.targets.length; i++) {
                    let w = this.targets[i].style.width;
                    let h = this.targets[i].style.height;
                    let oStr = this.targets[i].style.opacity;
                    let o;
                    if (!oStr || oStr === "")
                        o = 1;
                    else
                        o = Number(oStr);
                    let ov = this.targets[i].style.overflow;
                    if (ops.hideStyle != "fade") {
                        this.targets[i].style.overflow = "hidden";
                        m += 2;
                        (function (that, t, w, h, ov) {
                            dotcss(t).width.animate(0, ops.duration, ops.animationStyle, function () {
                                dotcss(t).display("none").width(w).overflow(ov); //Restore original overflow value. Only needs to be done once.
                                doneCnt++;
                                if (doneCnt >= m * q)
                                    ops.complete(that);
                            });
                            dotcss(t).height.animate(0, ops.duration, ops.animationStyle, function () {
                                dotcss(t).display("none").height(h);
                                doneCnt++;
                                if (doneCnt >= m * q)
                                    ops.complete(that);
                            });
                        })(this, this.targets[i], w, h, ov);
                    }
                    if (ops.hideStyle != "shrink") {
                        m++;
                        (function (that, t, o) {
                            return dotcss(t).opacity.animate(0, ops.duration, ops.animationStyle, function () {
                                dotcss(t).display("none").opacity(o);
                                doneCnt++;
                                if (doneCnt >= m * q)
                                    ops.complete(that);
                            });
                        })(this, this.targets[i], o);
                    }
                }
            }
            else {
                dotcss(this.targets).display("none");
                ops.complete(this); //This sets the display to none.
            }
        }
        return this;
    }
    //Usage:
    //show()
    //show(duration, complete)
    //show(options)
    //Options
    //	display: inline-block, block, etc.
    //	opacity: final opacity.
    //	width: final width.
    //	height: final height.
    //	duration: duration in ms.
    //	complete: on-complete callback.
    //	showStyle: fade, grow, or normal
    //	animationStyle: linear or exponential
    show(style) {
        if (this.targets) {
            let arg0 = arguments[0] || {};
            let arg0N = arg0;
            let arg0O = arg0;
            let ops = {};
            ops.duration = arg0O.duration || (isNaN(arg0N) ? 0 : arg0N) || 0;
            ops.display = arg0O.display || "block";
            ops.opacity = arg0O.opacity;
            ops.width = arg0O.width || null;
            ops.height = arg0O.height || null;
            ops.complete = arg0O.complete || (typeof arguments[1] == "function" ? arguments[1] : (typeof arguments[2] == "function" ? arguments[2] : function () { }));
            ops.showStyle = arg0O.showStyle || "normal";
            ops.animationStyle = arg0O.animationStyle || (typeof arguments[1] == "string" ? arguments[1] : "ease");
            if (ops.duration > 0) {
                let doneCnt = 0;
                let q = this.targets.length;
                let m = 0;
                for (let i = 0; i < this.targets.length; i++) {
                    let o = ops.opacity;
                    if (ops.opacity === undefined) {
                        o = parseFloat(this.targets[i].style.opacity) || 1;
                    }
                    if (ops.showStyle != "fade") {
                        m += 2;
                        let w = ops.width || this.targets[i].style.width;
                        let h = ops.height || this.targets[i].style.height;
                        dotcss(this.targets[i]).width(0);
                        dotcss(this.targets[i]).height(0);
                        // console.log(doneCnt + " " + q*m);
                        dotcss(this.targets[i]).width.animate(w, ops.duration, ops.animationStyle, function () { doneCnt++; if (doneCnt >= q * m)
                            ops.complete(); });
                        dotcss(this.targets[i]).height.animate(h, ops.duration, ops.animationStyle, function () { doneCnt++; if (doneCnt >= q * m)
                            ops.complete(); });
                    }
                    //let o = this.targets[i].style.opacity; //Guess I should fade to 1?
                    dotcss(this.targets[i]).opacity(0);
                    dotcss(this.targets[i]).display(ops.display);
                    if (ops.showStyle != "grow") {
                        m++;
                        dotcss(this.targets[i]).opacity.animate(o, ops.duration, ops.animationStyle, function () { doneCnt++; if (doneCnt == q * m)
                            ops.complete(); });
                    }
                }
            }
            else {
                return dotcss(this.targets).display(ops.display);
            }
        }
        return this;
    }
    fadeOut(duration, complete) {
        return this.hide({
            duration: isNaN(duration) ? 400 : Number(duration),
            hideStyle: "fade",
            complete: complete
        });
    }
    ;
    fadeIn(duration, complete) {
        return this.show({
            duration: isNaN(duration) ? 400 : Number(duration),
            showStyle: "fade",
            complete: complete
        });
    }
    ;
}
exports._Builder = _Builder;
// This could be better handeld. Consider putting it inside the dotcss class.
dotcss.prototype.toString = _Builder.prototype.toString;
// Why do we need this?
class _StyleProperty {
    constructor() {
        //Have to add these back since we're going to replace the __proto__ of a function with this new prototype.
        this.apply = Function.apply;
        this.call = Function.call;
        this.type = null;
        this.jsFriendlyProp = null;
    }
    //toString override gets the value.
    toString() {
        if (dotcss2.lastBuilder.targets) {
            // TODO: this doesn't make sense. Please figure it out.
            let ret = null;
            if (dotcss2.lastBuilder.targets.length > 1) {
                ret = [];
                for (let i = 0; i < dotcss2.lastBuilder.targets.length; i++) {
                    ret.push(dotcss2.lastBuilder.targets[i].style[this.jsFriendlyProp]);
                }
            }
            else
                ret = dotcss2.lastBuilder.targets[0].style[this.jsFriendlyProp];
            return ret;
        }
        else
            return null;
    }
    //val is another special function that breaks the value into a special object.
    val() {
        if (dotcss2.lastBuilder.targets) {
            let ret = null;
            // TODO: something wrong with this. Types don't check out.
            if (dotcss2.lastBuilder.targets.length > 1) {
                ret = null;
                for (let i = 0; i < dotcss2.lastBuilder.targets.length; i++) {
                    if (dotcss2.lastBuilder.targets[0].style[this.jsFriendlyProp]) {
                        ret.push(dotcss2.convertStyleIntoDotCssObject(dotcss2.lastBuilder.targets[i].style[this.jsFriendlyProp], this.type));
                    }
                    else
                        ret.push(null);
                }
            }
            else {
                if (dotcss2.lastBuilder.targets[0].style[this.jsFriendlyProp]) {
                    ret = dotcss2.convertStyleIntoDotCssObject(dotcss2.lastBuilder.targets[0].style[this.jsFriendlyProp], this.type);
                }
                else
                    ret = null;
            }
            return ret;
        }
        else
            return null;
    }
    //Ability to animate just like jquery.
    //complete does not get called if the animation was cancelled.
    animate(value, duration, style, complete) {
        duration = isNaN(duration) ? 400 : (duration || 0);
        if (dotcss2.lastBuilder && dotcss2.lastBuilder.targets) {
            if (!complete && style && style.call && style.apply) { //Fix params.
                complete = style;
                style = undefined;
            }
            for (let i = 0; i < dotcss2.lastBuilder.targets.length; i++) {
                let target = dotcss2.lastBuilder.targets[i];
                let oldValue = null;
                let newValue = null;
                let finalValue = null; //newValue might be in different units from the final value...
                //Get the old and new values.
                newValue = dotcss2.convertStyleIntoDotCssObject(value, this.type);
                //If it's a transformation, a little extra work is required.
                //Need to frame all the rotations properly, and combine both the new and the old transformations.
                if (this.type == "transformation") {
                    //Special handling. We'd like to consider the transformation as a complex data type first, then if that's not possible, convert it into a matrix data type.
                    //Reason being: linear transformations on matrices are inaccurate. Rotations end up scaling the target.
                    //Don't want to get the computed value for transformations.
                    oldValue = dotcss2.convertStyleIntoDotCssObject(target.style[this.jsFriendlyProp], this.type);
                }
                if (!oldValue) { //Standard. Happens when the type is not a transformation.
                    oldValue = dotcss2.convertStyleIntoDotCssObject(dotcss2.computedStyleOrActualStyle(target, this.jsFriendlyProp), this.type);
                }
                finalValue = newValue.toString();
                //Do a little type/unit checking.
                if (this.type == "length") {
                    if (oldValue.units != newValue.units) {
                        //Need to rectify this.
                        //This can get messy. If one of the lengths is zero, it would minimize the likelihood of an error.
                        if (oldValue.length == 0) {
                            oldValue.units = newValue.units;
                            oldValue.length = 0;
                        }
                        else if (newValue.length == 0) {
                            newValue.units = oldValue.units;
                            newValue.length = 0;
                        }
                        else {
                            //Things are messy. Try to mitigate. Convert the old value into the new units, as best we can.
                            let currentLengthPx = dotcss.lengthToPx(oldValue.toString(), this.jsFriendlyProp, target);
                            let newLengthPx = dotcss.lengthToPx(newValue.toString(), this.jsFriendlyProp, target);
                            oldValue.length = currentLengthPx;
                            oldValue.units = "px";
                            newValue.length = newLengthPx;
                            newValue.units = "px";
                            //Won't need this anymore.
                            //console.warn("Couldn't animate " + this.jsFriendlyProp + ". Inconsistent units.");
                            //return dotcss2._lastBuilder;
                        }
                    }
                }
                else if (this.type == "color") { } //OK
                else if (this.type == "transformation") {
                    //Couple things to do here.
                    //1. The old and new values must contain the exact same transformation template.
                    //2. Angles in the old transformation should be reframed so that they are close to the new angles (or should they)
                    let startTransform = "";
                    let desiredTransform = "";
                    let oldIndex = oldValue.transformations.length - 1;
                    let newIndex = newValue.transformations.length - 1;
                    while (oldIndex >= 0 || newIndex >= 0) {
                        let transformToAdd = "";
                        let oldTransformValues = null;
                        let newTransformValues = null;
                        if (oldIndex >= 0 && newIndex >= 0 && oldValue.transformations[oldIndex].transformation == newValue.transformations[newIndex].transformation) {
                            let currentOldT = oldValue.transformations[oldIndex];
                            let currentNewT = newValue.transformations[newIndex];
                            transformToAdd = currentOldT.transformation;
                            oldTransformValues = currentOldT.args;
                            newTransformValues = currentNewT.args;
                            oldIndex--;
                            newIndex--;
                        }
                        else if (oldIndex >= newIndex) {
                            let currentOldT = oldValue.transformations[oldIndex];
                            transformToAdd = currentOldT.transformation;
                            oldTransformValues = currentOldT.args;
                            if (transformToAdd == "matrix") {
                                newTransformValues = [1, 0, 0, 1, 0, 0];
                            }
                            else if (transformToAdd == "matrix3d") {
                                newTransformValues = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
                            }
                            else {
                                let filler = (transformToAdd.indexOf("scale") == -1) ? 0 : 1;
                                newTransformValues = [];
                                for (let j = 0; j < oldTransformValues.length; j++)
                                    newTransformValues.push(!isNaN(oldTransformValues[j]) ? filler : (!isNaN(oldTransformValues[j].angle) ? new css_angle_1.default(0) : (!isNaN(oldTransformValues[j].length) ? new css_length_1.default(0) : (0))));
                            }
                            oldIndex--;
                        }
                        else {
                            let currentNewT = newValue.transformations[newIndex];
                            transformToAdd = currentNewT.transformation;
                            newTransformValues = currentNewT.args;
                            if (transformToAdd == "matrix") {
                                oldTransformValues = [1, 0, 0, 1, 0, 0];
                            }
                            else if (transformToAdd == "matrix3d") {
                                oldTransformValues = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
                            }
                            else {
                                let filler = (transformToAdd.indexOf("scale") == -1) ? 0 : 1;
                                oldTransformValues = [];
                                for (let j = 0; j < newTransformValues.length; j++)
                                    oldTransformValues.push(!isNaN(newTransformValues[j]) ? filler : (!isNaN(newTransformValues[j].angle) ? new css_angle_1.default(0) : (!isNaN(newTransformValues[j].length) ? new css_length_1.default(0) : (0))));
                            }
                            newIndex--;
                        }
                        startTransform = ") " + startTransform;
                        desiredTransform = ") " + desiredTransform;
                        //Handle special values here.
                        if (transformToAdd.indexOf("rotate") != -1) {
                            let oldAngle = oldTransformValues[oldTransformValues.length - 1].angle;
                            let newAngle = newTransformValues[newTransformValues.length - 1].angle;
                            let sep = dotcss.angleSubtract(newAngle, oldAngle);
                            oldTransformValues[oldTransformValues.length - 1].angle = newAngle - sep;
                        }
                        for (let j = oldTransformValues.length - 1; j >= 0; j--) {
                            startTransform = "," + oldTransformValues[i] + startTransform;
                            desiredTransform = "," + newTransformValues[i] + desiredTransform;
                        }
                        startTransform = transformToAdd + "(" + startTransform.substring(1);
                        desiredTransform = transformToAdd + "(" + desiredTransform.substring(1);
                    }
                    oldValue = dotcss2.convertStyleIntoDotCssObject(startTransform, "transformation");
                    newValue = dotcss2.convertStyleIntoDotCssObject(desiredTransform, "transformation");
                }
                else if (oldValue.type == "number" && newValue.type == "number") { } //OK
                else if (oldValue.type == "complex" && newValue.type == "complex") {
                    if (!dotcss2.compareComplexDataTypes(oldValue, newValue)) {
                        console.warn("Couldn't animate " + this.jsFriendlyProp + ". Value mismatch.");
                        continue;
                    }
                }
                else {
                    console.warn("Couldn't animate " + this.jsFriendlyProp + ". Not a recognizable length, color, or number.");
                    continue;
                }
                dotcss2.animateFull(target, this.jsFriendlyProp, oldValue.type || this.type, oldValue, newValue, finalValue, dotcss2.fxInterval, duration, style || "ease", complete);
            }
        }
        return dotcss2.lastBuilder;
    }
}
;
dotcss.formatNumberValue = function (value, unit) {
    switch (unit) {
        case "px": return Math.round(value);
        default: return Math.round(value * 100) / 100;
    }
};
// TODO: figure out a way to add vMargin, hMargin, vPadding, etc.
const _allProps = {
    color: "color|background-Color|border-Bottom-Color|border-Color|border-Left-Color|border-Right-Color|border-Top-Color|text-Decoration-Color|outline-Color|column-Rule-Color",
    length: "background-Size|block-Size|border-Bottom-Left-Radius|border-Bottom-Right-Radius|border-Bottom-Width|border-Image-Width|border-Left-Width|border-Radius|border-Right-Width|border-Top-Left-Radius|border-Top-Right-Radius|border-Top-Width|border-Width|bottom|gap|height|left|margin|margin-Bottom|margin-Left|margin-Right|margin-Top|max-Height|max-Width|min-Height|min-Width|padding|padding-Bottom|padding-Left|padding-Right|padding-Top|right|top|width|line-Height|flex-Basis|font-Size|text-Indent",
    url: "background-Image|border-Image|list-Style-Image|content|image-Orientation",
    transformation: "transform",
    filter: "filter|backdrop-Filter",
    misc: "appearance|aspect-Ratio|opacity|background|background-Attachment|background-Blend-Mode|background-Position|background-Repeat|background-Clip|background-Origin|border|border-Bottom|border-Bottom-Style|border-Image-Outset|border-Image-Repeat|border-Image-Slice|border-Image-Source|border-Left|border-Left-Style|border-Right|border-Right-Style|border-Style|border-Top|border-Top-Style|box-Decoration-Break|box-Shadow|clear|clip|display|float|overflow|box|overflow-X|overflow-Y|position|visibility|vertical-Align|z-Index|align-Content|align-Items|align-Self|flex|flex-Basis|flex-Direction|flex-Flow|flex-Grow|flex-Shrink|flex-Wrap|grid|grid-Area|grid-Auto-Columns|grid-auto-Rows|grid-Column|grid-Column-End|grid-Column-Gap|grid-Column-Start|grid-Gap|grid-Row|grid-Row-End|grid-Row-Gap|grid-Row-Start|grid-Template|grid-Template-Areas|grid-Template-Columns|grid-Template-Rows|justify-Content|order|hanging-Punctuation|hyphens|letter-Spacing|line-Break|overflow-Wrap|tab-Size|text-Align|text-Align-Last|text-Combine-Upright|text-Justify|text-Transform|white-Space|word-Break|word-Spacing|word-Wrap|text-Decoration|text-Decoration-Line|text-Decoration-Style|text-Shadow|text-Underline-Position|font|font-Family|font-Feature-Settings|font-Kerning|font-Language-Override|font-Size-Adjust|font-Stretch|font-Style|font-Synthesis|font-Variant|font-Variant-Alternates|font-Variant-Caps|font-Variant-East-Asian|font-Variant-Ligatures|font-Variant-Numeric|font-Variant-Position|font-Weight|direction|text-Orientation|text-Combine-Upright|unicode-Bidi|user-Select|writing-Mode|border-Collapse|border-Spacing|caption-Side|empty-Cells|table-Layout|counter-Increment|counter-Reset|list-Style|list-Style-Position|list-Style-Type|animation|animation-Delay|animation-Direction|animation-Duration|animation-Fill-Mode|animation-Iteration-Count|animation-Name|animation-Play-State|animation-Timing-Function|backface-Visibility|perspective2d|perspective-Origin|transform-Origin|transform-Style|transition|transition-Property|transition-Duration|transition-Timing-Function|transition-Delay|box-Sizing|cursor|ime-Mode|nav-Down|nav-Index|nav-Left|nav-Right|nav-Up|outline|outline-Offset|outline-Style|outline-Width|resize|text-Overflow|break-After|break-Before|break-Inside|column-Count|column-Fill|column-Gap|column-Rule|column-Rule-Style|column-Rule-Width|column-Span|column-Width|columns|widows|orphans|page-Break-After|page-Break-Before|page-Break-Inside|marks|quotes|image-Rendering|image-Resolution|object-Fit|object-Position|mask|mask-Type|mark|mark-After|mark-Before|phonemes|rest|rest-After|rest-Before|voice-Balance|voice-Duration|voice-Pitch|voice-Pitch-Range|voice-Rate|voice-Stress|voice-Volume|marquee-Direction|marquee-Play-Count|marquee-Speed|marquee-Style|pointer-Events"
};
// const _allTransforms = [
// 	"matrix",
// 	"matrix3d",
// 	"translate",
// 	"translate3d",
// 	"translateX",
// 	"translateY",
// 	"translateZ",
// 	"scale",
// 	"scale3d",
// 	"scaleX",
// 	"scaleY",
// 	"scaleZ",
// 	"rotate",
// 	"rotate3d",
// 	"rotateX",
// 	"rotateY",
// 	"rotateZ",
// 	"skew",
// 	"skewX",
// 	"skewY",
// 	"perspective"
// ]
// TODO: this may have been intended to be private.
dotcss.matrixMultiply3D = function (A, B) {
    if (A.length != 16 || B.length != 16)
        throw "3D matrices must be arrays of 16 length.";
    var ret = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    for (var y = 0; y < 4; y++)
        for (var x = 0; x < 4; x++)
            for (var i = 0; i < 4; i++)
                ret[y + x * 4] += Number(A[y + i * 4]) * Number(B[i + x * 4]);
    return ret;
};
//Public functions.
// TODO: this doesn't really belong in here. This is like a math lib.
// // TODO: I don't think these are really needed. The css types take care of these.
// dotcss.angleSubtract = function(a: number, b: number):number{
// 	if(a < 0) a = 360 - ((-a) % 360); else a = a % 360;
// 	if(b < 0) b = 360 - ((-b) % 360); else b = b % 360;
// 	var phi = Math.abs(b - a) % 360;
// 	var d = phi > 180 ? 360 - phi : phi;
// 	var sign = (a - b >= 0 && a - b <= 180) || (a - b <=-180 && a- b>= -360) ? 1 : -1;
// 	return d * sign;
// };
// //Special handler for building urls.
// dotcss.url = function(url: string): string{
// 	return `url('${url}')`;
// };
// //Special handler for building rgb colors.
// dotcss.rgb = function(r: number, g: number, b: number): string{
// 	return `rgb(${r},${g},${b})`;
// };
// //Special handler for building rgba colors.
// dotcss.rgba = function(r: number, g: number, b: number, a: number): string{
// 	return `rgba(${r},${g},${b},${a})`;
// };
// We don't do this anymore.
// dotcss.buildTransform = function(){
// 	return new dotcss2._Transform();
// };
dotcss["cacheScopedStaticStyles"] = function (el) {
    let elements = getScopedNodeList("*", el);
    for (let element of elements) {
        if (element.hasAttribute("style")) {
            element.setAttribute(STATIC_SYLES_ATTR, element.getAttribute("style"));
        }
    }
};
dotcss["clearDynamicStyles"] = function (el) {
    let elements = getScopedNodeList("*", el);
    for (let element of elements) {
        element.removeAttribute("style");
        if (element.hasAttribute(STATIC_SYLES_ATTR)) {
            element.setAttribute("style", element.getAttribute(STATIC_SYLES_ATTR));
        }
    }
};
dotcss.scopeToEl = function (el) {
    dotcss2.scopeStack.unshift(el);
    return this;
};
dotcss.unscope = function () {
    dotcss2.scopeStack.shift();
    return this;
};
//Build dotcss.
for (var k in _allProps) {
    let P = _allProps[k].split("|");
    for (var i in P) {
        dotcss2.extendDothtml(P[i].toLowerCase(), P[i].replace(new RegExp("-", "g"), ""), k);
    }
}
// for(let i: number = 0; i < _allLengthUnits.length; i++) dotcss2.makeTransformFunction(_allLengthUnits[i]);
//dotcss = new dotcss();
// for (var k in _b) {
// 	if(_Builder[k] === undefined) dotcss[k] = _p[k];
// }
exports["default"] = dotcss;
//# sourceMappingURL=style-builder.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfZG90aHRtbF9saWJfc3R5bGluZ19zdHlsZS1idWlsZGVyX2pzLjFlOTJjNmNmODE0NWJiYTMzZTM3LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0JBQWdCO0FBQ2hCLCtCQUErQixtQkFBTyxDQUFDLDBGQUF3QjtBQUMvRCxvQ0FBb0MsbUJBQU8sQ0FBQyw4RkFBMEI7QUFDdEUsb0NBQW9DLG1CQUFPLENBQUMsOEZBQTBCO0FBQ3RFLHNDQUFzQyxtQkFBTyxDQUFDLGtHQUE0QjtBQUMxRSxxQ0FBcUMsbUJBQU8sQ0FBQyxnR0FBMkI7QUFDeEUscUNBQXFDLG1CQUFPLENBQUMsZ0dBQTJCO0FBQ3hFLHdDQUF3QyxtQkFBTyxDQUFDLHNHQUE4QjtBQUM5RSxzQ0FBc0MsbUJBQU8sQ0FBQyxrR0FBNEI7QUFDMUUsa0NBQWtDLG1CQUFPLENBQUMsMEZBQXdCO0FBQ2xFLG1CQUFtQixtQkFBTyxDQUFDLDJEQUFhO0FBQ3hDLHFDQUFxQyxtQkFBTyxDQUFDLGdHQUEyQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwySkFBMko7QUFDM0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx1Q0FBdUM7QUFDM0U7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLG9CQUFvQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCLHdCQUF3QixPQUFPO0FBQy9CLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixJQUFJO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUU7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsNEJBQTRCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL3dlZGRpbmctd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9kb3RodG1sL2xpYi9zdHlsaW5nL3N0eWxlLWJ1aWxkZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5fQnVpbGRlciA9IHZvaWQgMDtcclxuY29uc3QgdW5pdF9mdW5jdGlvbl90YWJsZXNfMSA9IHJlcXVpcmUoXCIuL3VuaXQtZnVuY3Rpb24tdGFibGVzXCIpO1xyXG5jb25zdCBjc3NfYW5nbGVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9jc3MtdHlwZXMudHMvY3NzLWFuZ2xlXCIpKTtcclxuY29uc3QgY3NzX2NvbG9yXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vY3NzLXR5cGVzLnRzL2Nzcy1jb2xvclwiKSk7XHJcbmNvbnN0IGNzc19jb21wbGV4XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vY3NzLXR5cGVzLnRzL2Nzcy1jb21wbGV4XCIpKTtcclxuY29uc3QgY3NzX2xlbmd0aF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2Nzcy10eXBlcy50cy9jc3MtbGVuZ3RoXCIpKTtcclxuY29uc3QgY3NzX251bWJlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2Nzcy10eXBlcy50cy9jc3MtbnVtYmVyXCIpKTtcclxuY29uc3QgY3NzX3RyYW5zZm9ybV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2Nzcy10eXBlcy50cy9jc3MtdHJhbnNmb3JtXCIpKTtcclxuY29uc3QgY3NzX3Vua25vd25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9jc3MtdHlwZXMudHMvY3NzLXVua25vd25cIikpO1xyXG5jb25zdCBjc3NfdXJsXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vY3NzLXR5cGVzLnRzL2Nzcy11cmxcIikpO1xyXG5jb25zdCBkb3RfdXRpbF8xID0gcmVxdWlyZShcIi4uL2RvdC11dGlsXCIpO1xyXG5jb25zdCBjc3NfZmlsdGVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vY3NzLXR5cGVzLnRzL2Nzcy1maWx0ZXJcIikpO1xyXG4vL0xhdGVzdCBVcGRhdGUuXHJcbi8qXHJcbiogLSBXcmFwcGVkIGNvZGUgaW4gYW5vbnltb3VzIGZ1bmN0aW9uLlxyXG4qIC0gSGlkIF9CdWlsZGVyIGFuZCBfU3R5bGVQcm9wZXJ0eS5cclxuKiAtIEluY3JlYXNlZCBjb21wYXRpYmlsaXR5IHdpdGggSUUgOCwgOSwgYW5kIDEwLlxyXG4qIC0gQWxsb3dlZCAwLWxlbmd0aCBhbmltYXRpb25zLlxyXG4qIDUuMVxyXG4qIC0gVHlwaWZpZWQgc3R5bGUgYnVpbGRlci5cclxuKiAtIEZpeGVkIHVwIHRyYW5zZm9ybWF0aW9ucyBhbmQgcmVkaWQgdHJhbnNmb3JtIGJ1aWxkZXIuXHJcbiogLSBSZW1vdmVkIHNvbWUgb2xkIGp1bmsuXHJcbiovXHJcbmNvbnN0IFNUQVRJQ19TWUxFU19BVFRSID0gXCJkYXRhLWRvdC1zdGF0aWMtc3R5bGVzXCI7XHJcbi8vIFJlbmFtZSB0aGlzIHRvIERvdGNzc0hlbHBlcnMuXHJcbi8vIFRoZSBuYW1lIERvdGNzczIgY29tZXMgZnJvbSBhIHRpbWUgd2hlbiB0aGlzIHdhcyBhIGNsb25lIG9mIGRvdGNzcyB3aXRoIFwicHJpdmF0ZVwiIG1lbWJlcnMuXHJcbmNsYXNzIERvdGNzczIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgLy9JbnZlcnNlIG9mIGZyYW1lcmF0ZSBpbiBtcy9mcmFtZS5cclxuICAgICAgICAvLyBVc2VkIGZvciBvbGQgYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IHJlcXVlc3RBbmltYXRpb25GcmFtZWZyYW1lLlxyXG4gICAgICAgIHRoaXMuZnhJbnRlcnZhbCA9IDEwMDAgLyA2MDtcclxuICAgICAgICB0aGlzLmxhc3RCdWlsZGVyID0gbnVsbDtcclxuICAgICAgICB0aGlzLnNjb3BlU3RhY2sgPSBbXTtcclxuICAgICAgICB0aGlzLmdsb2JhbFN0eWxlRWxlbWVudCA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBhbmltYXRlRnVsbChlbGVtZW50LCBqc0ZyaWVuZGx5UHJvcCwgcHJvcFR5cGUsIHN0YXJ0VmFsdWUsIHRhcmdldFZhbHVlLCBmaW5hbFZhbHVlLCBjdXJyZW50VGltZSwgdG90YWxEdXJhdGlvbiwgYW5pbWF0aW9uU3R5bGUsIGNhbGxiYWNrLCBsYXN0VmFsdWUpIHtcclxuICAgICAgICBpZiAobGFzdFZhbHVlICYmIGVsZW1lbnQuc3R5bGVbanNGcmllbmRseVByb3BdICE9IGxhc3RWYWx1ZSlcclxuICAgICAgICAgICAgcmV0dXJuOyAvL0FuaW1hdGlvbiBjYW4gYmUgY2FuY2VsbGVkIGFueSB0aW1lIGJ5IHNldHRpbmcgdGhlIHZhbHVlIGRpcmVjdGx5LlxyXG4gICAgICAgIGlmICh0b3RhbER1cmF0aW9uIC0gY3VycmVudFRpbWUgPiAwKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAocHJvcFR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJjb2xvclwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciByID0gTWF0aC5yb3VuZCgoMCwgZG90X3V0aWxfMS5udW1iZXJTdGVwKShzdGFydFZhbHVlLnIsIHRhcmdldFZhbHVlLnIsIGN1cnJlbnRUaW1lLCB0b3RhbER1cmF0aW9uLCBhbmltYXRpb25TdHlsZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBnID0gTWF0aC5yb3VuZCgoMCwgZG90X3V0aWxfMS5udW1iZXJTdGVwKShzdGFydFZhbHVlLmcsIHRhcmdldFZhbHVlLmcsIGN1cnJlbnRUaW1lLCB0b3RhbER1cmF0aW9uLCBhbmltYXRpb25TdHlsZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBiID0gTWF0aC5yb3VuZCgoMCwgZG90X3V0aWxfMS5udW1iZXJTdGVwKShzdGFydFZhbHVlLmIsIHRhcmdldFZhbHVlLmIsIGN1cnJlbnRUaW1lLCB0b3RhbER1cmF0aW9uLCBhbmltYXRpb25TdHlsZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gZG90Y3NzLmZvcm1hdE51bWJlclZhbHVlKCgwLCBkb3RfdXRpbF8xLm51bWJlclN0ZXApKHN0YXJ0VmFsdWUuYSwgdGFyZ2V0VmFsdWUuYSwgY3VycmVudFRpbWUsIHRvdGFsRHVyYXRpb24sIGFuaW1hdGlvblN0eWxlKSk7IC8vVE9ETzogbWFrZSBzdXJlIHRoaXMgZG9lc24ndCBuZWVkIHRvIGJlIHJvdW5kZWQgb3Igc29tZXRoaW5nLlxyXG4gICAgICAgICAgICAgICAgICAgIGRvdGNzcyhlbGVtZW50KVtqc0ZyaWVuZGx5UHJvcF0ociwgZywgYiwgYSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwibGVuZ3RoXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgZG90Y3NzKGVsZW1lbnQpW2pzRnJpZW5kbHlQcm9wXShkb3Rjc3MuZm9ybWF0TnVtYmVyVmFsdWUoKDAsIGRvdF91dGlsXzEubnVtYmVyU3RlcCkoc3RhcnRWYWx1ZS5sZW5ndGgsIHRhcmdldFZhbHVlLmxlbmd0aCwgY3VycmVudFRpbWUsIHRvdGFsRHVyYXRpb24sIGFuaW1hdGlvblN0eWxlKSwgc3RhcnRWYWx1ZS51bml0cykgKyBzdGFydFZhbHVlLnVuaXRzKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJ0cmFuc2Zvcm1hdGlvblwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdUcmFuc2Zvcm0gPSBcIlwiO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vc3RhcnRWYWx1ZSBhbmQgdGFyZ2V0VmFsdWUgYXJlIGd1YXJhbnRlZWQgdG8gaGF2ZSB0aGUgc2FtZSB0ZW1wbGF0ZS5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXJ0VmFsdWUudHJhbnNmb3JtYXRpb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0MSA9IHN0YXJ0VmFsdWUudHJhbnNmb3JtYXRpb25zW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdDIgPSB0YXJnZXRWYWx1ZS50cmFuc2Zvcm1hdGlvbnNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1RyYW5zZm9ybSArPSB0MS50cmFuc2Zvcm1hdGlvbiArIFwiKFwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHQxLmFyZ3MubGVuZ3RoOyBrKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2MSA9IHQxLmFyZ3Nba107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdjIgPSB0Mi5hcmdzW2tdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFjdHVhbFYxID0gaXNOYU4odjEpID8gdjEubGVuZ3RoIHx8IHYxLmFuZ2xlIHx8IHYxLnZhbHVlIHx8IDAgOiB2MTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhY3R1YWxWMiA9IGlzTmFOKHYyKSA/IHYyLmxlbmd0aCB8fCB2Mi5hbmdsZSB8fCB2Mi52YWx1ZSB8fCAwIDogdjI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdW5pdHMgPSBpc05hTih2MSkgPyB2MS51bml0cyA6IFwiXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdUcmFuc2Zvcm0gKz0gZG90Y3NzLmZvcm1hdE51bWJlclZhbHVlKCgwLCBkb3RfdXRpbF8xLm51bWJlclN0ZXApKGFjdHVhbFYxLCBhY3R1YWxWMiwgY3VycmVudFRpbWUsIHRvdGFsRHVyYXRpb24sIGFuaW1hdGlvblN0eWxlKSwgdW5pdHMpICsgdW5pdHMgKyBcIixcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdUcmFuc2Zvcm0gPSBuZXdUcmFuc2Zvcm0uc3Vic3RyaW5nKDAsIG5ld1RyYW5zZm9ybS5sZW5ndGggLSAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3VHJhbnNmb3JtICs9IFwiKSBcIjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZG90Y3NzKGVsZW1lbnQpW2pzRnJpZW5kbHlQcm9wXShuZXdUcmFuc2Zvcm0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHN0YXJ0VmFsdWUudHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibnVtYmVyXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3Rjc3MoZWxlbWVudClbanNGcmllbmRseVByb3BdKGRvdGNzcy5mb3JtYXROdW1iZXJWYWx1ZSgoMCwgZG90X3V0aWxfMS5udW1iZXJTdGVwKShzdGFydFZhbHVlLnZhbHVlLCB0YXJnZXRWYWx1ZS52YWx1ZSwgY3VycmVudFRpbWUsIHRvdGFsRHVyYXRpb24sIGFuaW1hdGlvblN0eWxlKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjb21wbGV4XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3VmFsID0gXCJcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhcnRWYWx1ZS5udW1iZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsICs9IHN0YXJ0VmFsdWUucGFydHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsICs9IGRvdGNzcy5mb3JtYXROdW1iZXJWYWx1ZSgoMCwgZG90X3V0aWxfMS5udW1iZXJTdGVwKShzdGFydFZhbHVlLm51bWJlcnNbaV0sIHRhcmdldFZhbHVlLm51bWJlcnNbaV0sIGN1cnJlbnRUaW1lLCB0b3RhbER1cmF0aW9uLCBhbmltYXRpb25TdHlsZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsICs9IHN0YXJ0VmFsdWUucGFydHNbc3RhcnRWYWx1ZS5wYXJ0cy5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdGNzcyhlbGVtZW50KVtqc0ZyaWVuZGx5UHJvcF0obmV3VmFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVW5leHBlY3RlZCBkYXRhIHR5cGUgZm9yIGFuaW1hdGlvbi5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBub3cgPSAod2luZG93LnBlcmZvcm1hbmNlICYmIHdpbmRvdy5wZXJmb3JtYW5jZS5ub3cpID8gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpIDogbnVsbDtcclxuICAgICAgICAgICAgLy92YXIgcmVhY2hlZEFuaW1GcmFtZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvL1RPRE86IHRoZXJlIGNvdWxkIGJlIGEgbWVtb3J5IGxlYWsgaGVyZS4gTmVlZCB0byBpbnZlc3RpZ2F0ZS5cclxuICAgICAgICAgICAgLy9CZWNhdXNlIHdlJ3JlIGNyZWF0aW5nIGEgbG90IG9mIG5ldyBmdW5jdGlvbnMuIEFyZSB0aGV5IGJlaW5nIHJlbGVhc2VkP1xyXG4gICAgICAgICAgICB2YXIgbGFzdCA9IGVsZW1lbnQuc3R5bGVbanNGcmllbmRseVByb3BdO1xyXG4gICAgICAgICAgICB2YXIgbmV4dFN0ZXAgPSBmdW5jdGlvbiAodGltZXN0YW1wKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2hhbmdlID0gKG5vdyA/ICh3aW5kb3cucGVyZm9ybWFuY2Uubm93KCkgLSBub3cpIDogZG90Y3NzMi5meEludGVydmFsKTtcclxuICAgICAgICAgICAgICAgIGRvdGNzczIuYW5pbWF0ZUZ1bGwoZWxlbWVudCwganNGcmllbmRseVByb3AsIHByb3BUeXBlLCBzdGFydFZhbHVlLCB0YXJnZXRWYWx1ZSwgZmluYWxWYWx1ZSwgY3VycmVudFRpbWUgKyBjaGFuZ2UsIHRvdGFsRHVyYXRpb24sIGFuaW1hdGlvblN0eWxlLCBjYWxsYmFjaywgbGFzdCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGlmICh3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XHJcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKG5leHRTdGVwKTtcclxuICAgICAgICAgICAgICAgIC8vc2V0VGltZW91dChmdW5jdGlvbigpe2lmKCFyZWFjaGVkQW5pbUZyYW1lKSBjb25zb2xlLmxvZyhcIkVSUk9SXCIpO30sIDEwMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQobmV4dFN0ZXAsIGRvdGNzczIuZnhJbnRlcnZhbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvL1RPRE86IHZlcmlmeSB0aGF0IGRlY2ltYWwgdmFsdWVzIGFyZSBwcm9wZXJseSBoYW5kbGVkIGhlcmUuXHJcbiAgICAgICAgICAgIGRvdGNzcyhlbGVtZW50KVtqc0ZyaWVuZGx5UHJvcF0oZmluYWxWYWx1ZSk7XHJcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaylcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy9UYWtlcyB0aGUgcHJvcGVydHkgYW5kIGdlbmVyYXRlcyBhbGwgdGhlIGRvdGNzcyBhbmQgYnVpbGRlciBmdW5jdGlvbnMuXHJcbiAgICBleHRlbmREb3RodG1sKHByb3AsIGpzRnJpZW5kbHlQcm9wLCB0eXBlKSB7XHJcbiAgICAgICAgLy9DcmVhdGUgdGhlIG5ldyBmdW5jdGlvbiBieSBleHRlbmRpbmcgdGhlIGJ1aWxkZXIuXHJcbiAgICAgICAgbGV0IF9iID0gX0J1aWxkZXIucHJvdG90eXBlO1xyXG4gICAgICAgIF9iW2pzRnJpZW5kbHlQcm9wXSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMClcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xyXG4gICAgICAgICAgICAvLyBUT0RPOiBXaHkgY2FuJ3QgSSBqdXN0IHBhc3MgYXJndW1lbnRzIGRpcmVjdGx5IGludG8gdGhpcyBmdW5jdGlvbj9cclxuICAgICAgICAgICAgLy8gVHJ5IGl0LlxyXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBkb3Rjc3MyLmNvbnZlcnRTdHlsZUludG9Eb3RDc3NPYmplY3QoYXJncywgdHlwZSkudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgdmFyIG5ld0NzcyA9IHByb3AgKyBcIjpcIiArIHZhbHVlICsgXCI7XCI7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudENzcyArPSBuZXdDc3M7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGBTRVRUSU5HICR7anNGcmllbmRseVByb3B9OmAsIHRoaXMudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgIC8vIHRoaXMudG9TdHJpbmcoKVxyXG4gICAgICAgICAgICBpZiAodGhpcy50YXJnZXRzKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBxID0gMDsgcSA8IHRoaXMudGFyZ2V0cy5sZW5ndGg7IHErKykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vdGhpcy50YXJnZXRzW3FdLnN0eWxlICs9IG5ld0NzcztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IHRoaXMudGFyZ2V0c1txXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodC50YWdOYW1lID09IFwiU1RZTEVcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgdC5pbm5lckhUTUwgPSB0LmlubmVySFRNTC5zdWJzdHJpbmcoMCwgdC5pbm5lckhUTUwubGVuZ3RoIC0gMSkgKyBwcm9wICsgXCI6XCIgKyB2YWx1ZSArIFwiO31cIjtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHQuc3R5bGVbanNGcmllbmRseVByb3BdID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvL0FkZCB0aGUgbmV3IGZ1bmN0aW9uIHRvIHRoZSBkb3Rjc3Mgb2JqZWN0IHNvIHRoYXQgaXQgY2FuIGJlIGFjY2Vzc2VkIHdpdGhvdXQgZG9pbmcgZG90Y3NzKCkuXHJcbiAgICAgICAgZG90Y3NzMi5hZGRQcm9wRnVuY3Rpb25Ub0RvdENzc09iamVjdChqc0ZyaWVuZGx5UHJvcCk7XHJcbiAgICAgICAgLy9FYWNoIHVuaXQgb2YgbGVuZ3RoIHdpbGwgYWxzbyBoYXZlIGl0cyBvd24gdmVyc2lvbiBvZiB0aGlzIGZ1bmN0aW9uIChhc3N1bWluZyB0aGlzIGlzIGEgbGVuZ3RoIHByb3BlcnR5KS5cclxuICAgICAgICBpZiAodHlwZSA9PSBcImxlbmd0aFwiKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIHUgPSAwOyB1IDwgdW5pdF9mdW5jdGlvbl90YWJsZXNfMS5BbGxMZW5ndGhVbml0cy5sZW5ndGg7IHUrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHV1ID0gdW5pdF9mdW5jdGlvbl90YWJsZXNfMS5BbGxMZW5ndGhVbml0c1t1XTtcclxuICAgICAgICAgICAgICAgIChmdW5jdGlvbiAodXUpIHtcclxuICAgICAgICAgICAgICAgICAgICBfYltqc0ZyaWVuZGx5UHJvcCArICh1dS5qc05hbWUgfHwgdXUudW5pdCldID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50c1tpXSA9IGFyZ3VtZW50c1tpXSArIHV1LnVuaXQudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9iW2pzRnJpZW5kbHlQcm9wXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9KSh1dSk7XHJcbiAgICAgICAgICAgICAgICBkb3Rjc3MyLmFkZFByb3BGdW5jdGlvblRvRG90Q3NzT2JqZWN0KGpzRnJpZW5kbHlQcm9wICsgKHV1LmpzTmFtZSB8fCB1dS51bml0KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy9fYltqc0ZyaWVuZGx5UHJvcF0uX19wcm90b19fID0gT2JqZWN0LmNyZWF0ZShfU3R5bGVQcm9wZXJ0eS5wcm90b3R5cGUpO1xyXG4gICAgICAgIF9iW2pzRnJpZW5kbHlQcm9wXS50eXBlID0gdHlwZTtcclxuICAgICAgICBfYltqc0ZyaWVuZGx5UHJvcF0uanNGcmllbmRseVByb3AgPSBqc0ZyaWVuZGx5UHJvcDtcclxuICAgICAgICAvLyBUaGlzIGlzIHdlaXJkLiBJdCBsb29rcyBsaWtlIEkgd2FzIHRyeWluZyB0byBpbXBsZW1lbnQgc29tZSBmb3JtIG9mIG11bHRpbHBlIGluaGVyaXRhbmNlLlxyXG4gICAgICAgIC8vIFRoaXMgc2hvdWxkIHJlYWxseSBiZSB1cGdyYWRlZC5cclxuICAgICAgICBmb3IgKHZhciBrIGluIF9TdHlsZVByb3BlcnR5LnByb3RvdHlwZSkge1xyXG4gICAgICAgICAgICBpZiAoX2JbanNGcmllbmRseVByb3BdW2tdID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICBfYltqc0ZyaWVuZGx5UHJvcF1ba10gPSBfU3R5bGVQcm9wZXJ0eS5wcm90b3R5cGVba107XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy9SZXR1cm5zIGEgSlNPTiBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgdmFsdWUgc3BlY2lmaWMgdG8gdGhlIGNzc0RhdGFUeXBlIHBhc3NlZCBpbi5cclxuICAgIGNvbnZlcnRTdHlsZUludG9Eb3RDc3NPYmplY3QodmFsdWUsIGNzc0RhdGFUeXBlKSB7XHJcbiAgICAgICAgLy9pZighdmFsdWUpIHJldHVybiBudWxsO1xyXG4gICAgICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpKVxyXG4gICAgICAgICAgICB2YWx1ZSA9IFt2YWx1ZV07XHJcbiAgICAgICAgaWYgKGNzc0RhdGFUeXBlID09IFwiY29sb3JcIilcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBjc3NfY29sb3JfMS5kZWZhdWx0KHZhbHVlKTtcclxuICAgICAgICBlbHNlIGlmIChjc3NEYXRhVHlwZSA9PSBcInVybFwiKVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IGNzc191cmxfMS5kZWZhdWx0KHZhbHVlKTtcclxuICAgICAgICBlbHNlIGlmIChjc3NEYXRhVHlwZSA9PSBcImxlbmd0aFwiICYmICghaXNOYU4odmFsdWVbMF0pIHx8ICh2YWx1ZVswXS5pbmRleE9mKFwiIFwiKSA9PSAtMSAmJiB2YWx1ZVswXS5yZXBsYWNlKGRvdF91dGlsXzEuZmxvYXRSZWdleCwgXCJcIikgIT0gdmFsdWVbMF0pKSlcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBjc3NfbGVuZ3RoXzEuZGVmYXVsdCh2YWx1ZVswXSk7XHJcbiAgICAgICAgZWxzZSBpZiAoY3NzRGF0YVR5cGUgPT0gXCJ0cmFuc2Zvcm1hdGlvblwiKVxyXG4gICAgICAgICAgICByZXR1cm4gKG5ldyBjc3NfdHJhbnNmb3JtXzEuZGVmYXVsdCh2YWx1ZVswXSkpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgZWxzZSBpZiAoY3NzRGF0YVR5cGUgPT0gXCJmaWx0ZXJcIilcclxuICAgICAgICAgICAgcmV0dXJuIChuZXcgY3NzX2ZpbHRlcl8xLmRlZmF1bHQodmFsdWVbMF0pKS50b1N0cmluZygpO1xyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodmFsdWVbMF0gPT09IFwiXCJcclxuICAgICAgICAgICAgICAgIHx8ICgoaXNOYU4odmFsdWVbMF0pKVxyXG4gICAgICAgICAgICAgICAgICAgICYmIChcIlwiICsgdmFsdWVbMF0pLnJlcGxhY2UoZG90X3V0aWxfMS5mbG9hdFJlZ2V4LCBcIlwiKSA9PSB2YWx1ZVswXSkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGNzc191bmtub3duXzEuZGVmYXVsdCh2YWx1ZVswXSk7IC8vTm8gbnVtYmVycy5cclxuICAgICAgICAgICAgaWYgKGlzTmFOKHZhbHVlWzBdKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgY3NzX2NvbXBsZXhfMS5kZWZhdWx0KHZhbHVlWzBdKTsgLy9OdW1iZXJzXHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgY3NzX251bWJlcl8xLmRlZmF1bHQodmFsdWVbMF0pOyAvL0p1c3QgYSBudW1iZXIuXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLy9FbnN1cmVzIHRoYXQgdHdvIGNvbXBsZXggdmFsdWVzIG1hdGNoLlxyXG4gICAgY29tcGFyZUNvbXBsZXhEYXRhVHlwZXModmFsdWUxLCB2YWx1ZTIpIHtcclxuICAgICAgICBpZiAodmFsdWUxLnR5cGUgIT0gXCJjb21wbGV4XCIgfHwgdmFsdWUyLnR5cGUgIT0gXCJjb21wbGV4XCIpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICBpZiAodmFsdWUxLm51bWJlcnMubGVuZ3RoICE9IHZhbHVlMi5udW1iZXJzLmxlbmd0aClcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGlmICh2YWx1ZTEucGFydHMubGVuZ3RoICE9IHZhbHVlMi5wYXJ0cy5sZW5ndGgpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlMS5wYXJ0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUxLnBhcnRzW2ldICE9IHZhbHVlMi5wYXJ0c1tpXSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvL0FkZHMgYSBidWlsZGVyIGZ1bmN0aW9uIGRpcmVjdGx5IHRvIHRoZSBkb3Rjc3Mgb2JqZWN0IHNvIHRoYXQgZG90Y3NzIGRvZXNuJ3RcclxuICAgIC8vaGF2ZSB0byBiZSB1c2VkIGFzIGEgZnVuY3Rpb24gd2hlbiBhIHRhcmdldCBkb2Vzbid0IG5lZWQgdG8gYmUgc3BlY2lmaWVkLlxyXG4gICAgYWRkUHJvcEZ1bmN0aW9uVG9Eb3RDc3NPYmplY3QoZnVuY05hbWUpIHtcclxuICAgICAgICBkb3Rjc3NbZnVuY05hbWVdID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgbiA9IG5ldyBfQnVpbGRlcigpO1xyXG4gICAgICAgICAgICByZXR1cm4gbltmdW5jTmFtZV0uYXBwbHkobiwgYXJndW1lbnRzKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLy8gTWlnaHQgcmVtb3ZlIHRoaXMuXHJcbiAgICAvLyBJIHRoaW5rIHRoaXMgZG9lc24ndCB3b3JrLiBSZW1vdmluZyBub3cuIE5vdCBzdXJlIHdoYXQgaXQgd2FzIHN1cHBvc2VkIHRvIGRvLlxyXG4gICAgLy8gbWFrZVRyYW5zZm9ybUZ1bmN0aW9uKGZuKXtcclxuICAgIC8vIFx0ZG90Y3NzW2ZuXSA9IGZ1bmN0aW9uKCl7XHJcbiAgICAvLyBcdFx0dmFyIG4gPSBuZXcgVHJhbnNmb3JtKCk7XHJcbiAgICAvLyBcdFx0cmV0dXJuIG5bZm5dLmFwcGx5KG4sIGFyZ3VtZW50cyk7XHJcbiAgICAvLyBcdH07XHJcbiAgICAvLyB9XHJcbiAgICBjb21wdXRlZFN0eWxlT3JBY3R1YWxTdHlsZShlbGVtZW50LCBwcm9wZXJ0eSkge1xyXG4gICAgICAgIHJldHVybiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KVtwcm9wZXJ0eV0gfHwgZWxlbWVudC5zdHlsZVtwcm9wZXJ0eV07XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBtb2REZWcoYSkge1xyXG4gICAgICAgIGlmIChhIDwgMClcclxuICAgICAgICAgICAgYSA9IDM2MCAtICgoLWEpICUgMzYwKTtcclxuICAgICAgICByZXR1cm4gYSAlIDM2MDtcclxuICAgIH1cclxuICAgIDtcclxufVxyXG5jb25zdCBkb3Rjc3MyID0gbmV3IERvdGNzczIoKTtcclxuY29uc3QgZG90Y3NzID0gZnVuY3Rpb24gKHF1ZXJ5KSB7XHJcbiAgICAvL3RoaXMuY3VycmVudENzcyA9IFwiXCI7XHJcbiAgICB2YXIgdGFyZ2V0ID0gbnVsbDtcclxuICAgIGlmIChxdWVyeSkge1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHF1ZXJ5LCBcIj9cIik7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyeSA9PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgIC8vIENyZWF0aW5nIGEgc3R5bGUgdGFnLiBNaWdodCBub3QgYmUgc3VwcG9ydGVkIGZvcmV2ZXIuXHJcbiAgICAgICAgICAgIGlmIChxdWVyeS5sZW5ndGggPiAyICYmIHF1ZXJ5LmluZGV4T2YoXCJ7fVwiKSA9PSBxdWVyeS5sZW5ndGggLSAyKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiB0aGlzIG5lZWRzIGZ1cnRoZXIgdGVzdGluZywgcGFydGljdWxhcmx5IHdoZW4gbXVsaXRwbGUgc3l0bGVzIGFyZSBzZXQgb24gdGhlIHNhbWUgcGFnZS5cclxuICAgICAgICAgICAgICAgIC8vIEJlIHN1cmUgdG8gc2V0IHVwIHNvbWUgdGVzdHMuXHJcbiAgICAgICAgICAgICAgICBxdWVyeSA9IHF1ZXJ5LnN1YnN0cmluZygwLCBxdWVyeS5sZW5ndGggLSAyKTtcclxuICAgICAgICAgICAgICAgIGlmICghZG90Y3NzMi5nbG9iYWxTdHlsZUVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBkb3Rjc3MyLmdsb2JhbFN0eWxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcclxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGRvdGNzczIuZ2xvYmFsU3R5bGVFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRhcmdldCA9IFtkb3Rjc3MyLmdsb2JhbFN0eWxlRWxlbWVudF07XHJcbiAgICAgICAgICAgICAgICB0YXJnZXRbMF0uaW5uZXJIVE1MICs9IHF1ZXJ5ICsgXCJ7fVxcclxcblwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBvdmVybHkgY29tcGxpY2F0ZWQsIGJ1dCBoZXJlIGlzIHRoZSBzcGllbC5cclxuICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlJ3MgYW4gZWxlbWVudCBvbiB0aGUgc2NvcGVTdGFjaywgaXQgc2hvdWxkIGJlIHVzZWQgd2l0aCB0aGUgcXVlcnlTZWxlY3RvckFsbC5cclxuICAgICAgICAgICAgICAgIC8vIEJVVCwgcXVlcnlTZWxlY3RvckFsbCBkb2Vzbid0IGFjdHVhbGx5IHNlbGVjdCB0aGUgZWxlbWVudCBpdCdzIGN1cnJlbnRseSBvbiwgd2hpY2ggaXMgYSByZXF1aXJlbWVudCBmb3IgZG90aHRtbC5cclxuICAgICAgICAgICAgICAgIC8vIFRvIG1ha2UgbWF0dGVycyB3b3JzZSwgaWYgd2UgZG8gcXVlcnlTZWxlY3RvckFsbCBvbiB0aGUgZWxlbWVudCdzIHBhcmVudHMsIHdlIG1heSBhY2NpZGVudGFsbHkgc2VsZWN0IGl0cyBzaWJsaW5ncyEhXHJcbiAgICAgICAgICAgICAgICAvLyBUbyBmaXggdGhpcywgd2UgZ2V0IGEgbGlzdCBmcm9tIHF1ZXJ5U2VsZWN0b3JBbGwgb24gdGhlIGVsZW1lbnQsIHRoZW4gcHVzaCB0aGUgZWxlbWVudCBpdHNlbGYgdG8gdGhhdCBsaXN0XHJcbiAgICAgICAgICAgICAgICAvLyBpZmYgaXQgaXMgaW4gdGhlIGxpc3Qgb2YgZWxlbWVudHMgcXVlcmllZCBmcm9tIGl0cyBwYXJlbnQuXHJcbiAgICAgICAgICAgICAgICAvLyBJbiBhZGRpdGlvbiB0byBhbGwgb2YgdGhhdCwgd2UgZG9uJ3Qgd2FudCBzY29wZWQgc3R5bGVzIHRvIGJlIGFwcGxpZWQgdG8gY2hpbGQgY29tcG9uZW50cy5cclxuICAgICAgICAgICAgICAgIHZhciBzMCA9IGRvdGNzczIuc2NvcGVTdGFja1swXTtcclxuICAgICAgICAgICAgICAgIC8vIGlmKHMwIGluc3RhbmNlb2YgQ29tcG9uZW50KXtcclxuICAgICAgICAgICAgICAgIC8vIFx0czAgPSBzMC4kZWw7XHJcbiAgICAgICAgICAgICAgICAvLyB9XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSdyZSBkb2luZyBzY29wZWQsIGFuZCBpdCdzIGFuIGVsZW1lbnQuXHJcbiAgICAgICAgICAgICAgICBpZiAoczAgJiYgczAucGFyZW50Tm9kZSAmJiBzMC5xdWVyeVNlbGVjdG9yQWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coczApO1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IGdldFNjb3BlZE5vZGVMaXN0KHF1ZXJ5LCBzMCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHF1ZXJ5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIHRhcmdldCA9IHJlZmVyZW5jZVB0LnF1ZXJ5U2VsZWN0b3JBbGwocXVlcnkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgocXVlcnkgaW5zdGFuY2VvZiBOb2RlTGlzdCkgfHwgKHF1ZXJ5IGluc3RhbmNlb2YgQXJyYXkpKVxyXG4gICAgICAgICAgICB0YXJnZXQgPSBxdWVyeTtcclxuICAgICAgICBpZiAocXVlcnkgaW5zdGFuY2VvZiBOb2RlKVxyXG4gICAgICAgICAgICB0YXJnZXQgPSBbcXVlcnldOyAvL0RvZXNuJ3QgbmVlZCB0byBiZSBhIE5vZGVMaXN0LiBKdXN0IGl0ZXJhYmxlLlxyXG4gICAgfVxyXG4gICAgZG90Y3NzMi5sYXN0QnVpbGRlciA9IG5ldyBfQnVpbGRlcih0YXJnZXQpO1xyXG4gICAgcmV0dXJuIGRvdGNzczIubGFzdEJ1aWxkZXI7XHJcbn07IC8vIFdlIGRvIHRoaXMgYmVjYXVzZSBtYW55IG9mIHRoZSBkb3Rjc3MgbWV0aG9kcyBhcmUgZ2VuZXJhdGVkIGF0IHJ1bnRpbWUuIEdyZWF0bHkgcmVkdWNlcyBidWlsZCBzaXplLlxyXG5kb3Rjc3MudmVyc2lvbiA9IFwiMC4xNi4wXCI7XHJcbmZ1bmN0aW9uIGdldFNjb3BlZE5vZGVMaXN0KHF1ZXJ5LCBzMCkge1xyXG4gICAgLy8gR2V0IGFsbCBvZiB0aGUgbWF0Y2hpbmcgY2hpbGQgZWxlbWVudHMgb2YgdGhlIGNvbXBvbmVudC4gVGhpcyB3aWxsIG5vdCBpbmNsdWRlIHMwIGl0c2VsZiwgYnV0IGl0IGRvZXMgaW5jbHVkZSBuZXN0ZWQgY29tcG9uZW50cy5cclxuICAgIC8vIFNvIHdlIHdpbGwgbmVlZCB0byBtYW5pcHVsYXRlIHRoaXMgY29sbGVjdGlvbi5cclxuICAgIC8vIHF1ZXJ5U2VsZWN0b3JBbGwgcmV0dXJucyBhIE5vZGVMaXN0LCB3aGljaCB3ZSBuZWVkIHRvIGNvbnZlcnQgaW50byBhbiBBcnJheS5cclxuICAgIHZhciB0YXJnZXQgPSBBcnJheS5mcm9tKHMwLnF1ZXJ5U2VsZWN0b3JBbGwocXVlcnkpKTtcclxuICAgIC8vIGNvbnNvbGUubG9nKHF1ZXJ5LCBzMC5jbGFzc05hbWUpO1xyXG4gICAgLy8gRXhjbHVkZSBuZXN0ZWQgY29tcG9uZW50cy5cclxuICAgIGZvciAodmFyIHQgPSAwOyB0IDwgdGFyZ2V0Lmxlbmd0aDsgdCsrKSB7XHJcbiAgICAgICAgdmFyIFQgPSB0YXJnZXRbdF07XHJcbiAgICAgICAgLy8gSXMgaXQgYSBuZXN0ZWQgY29tcG9uZW50Pz9cclxuICAgICAgICBpZiAoVFtcIl9fZG90aHRtbF9jb21wb25lbnRcIl0pIHtcclxuICAgICAgICAgICAgLy8gSXQncyBhIGNvbXBvbmVudC4gUmVtb3ZlIGl0LCBhbmQgYWxsIG9mIGl0J3MgZGVzY2VuZGFudHMuXHJcbiAgICAgICAgICAgIHRhcmdldC5zcGxpY2UodCwgMSk7XHJcbiAgICAgICAgICAgIHQtLTtcclxuICAgICAgICAgICAgdmFyIHN1YlRhcmdldHMgPSBULnF1ZXJ5U2VsZWN0b3JBbGwocXVlcnkpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBzID0gMDsgcyA8IHN1YlRhcmdldHMubGVuZ3RoOyBzKyspIHtcclxuICAgICAgICAgICAgICAgIGxldCBTID0gc3ViVGFyZ2V0c1tzXTtcclxuICAgICAgICAgICAgICAgIHRhcmdldC5zcGxpY2UodGFyZ2V0LmluZGV4T2YoUywgdCArIDEpLCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIExvb3AgdGhyb3VnaCBhbGwgdGhlIHNpYmxpbmcgbm9kZXMgdW50aWwgd2UgZmluZCBzMC5cclxuICAgIHZhciBwYXJlbnRUYXJnZXRzID0gQXJyYXkuZnJvbShzMC5wYXJlbnROb2RlLnF1ZXJ5U2VsZWN0b3JBbGwocXVlcnkpKTtcclxuICAgIHZhciBwID0gcGFyZW50VGFyZ2V0cy5pbmRleE9mKHMwKTtcclxuICAgIGlmIChwICE9IC0xKSB7XHJcbiAgICAgICAgdGFyZ2V0LnVuc2hpZnQocGFyZW50VGFyZ2V0c1twXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGFyZ2V0O1xyXG59XHJcbi8qKlxyXG4gKiBUaGUgZG90Y3NzIGJ1aWxkZXIgZ2V0cyBleHRlbmRlZCB3aXRoIGFsbCBvZiB0aGUgY3NzIGZ1bmN0aW9ucyBhdCBydW50aW1lLlxyXG4qL1xyXG5jbGFzcyBfQnVpbGRlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXRzKSB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50Q3NzID0gXCJcIjtcclxuICAgICAgICB0aGlzLnRhcmdldHMgPSB0YXJnZXRzID8/IG51bGw7XHJcbiAgICB9XHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIkNBTExFRCBUT1NUUklORyFcIiwgdGhpcy5jdXJyZW50Q3NzKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50Q3NzO1xyXG4gICAgfVxyXG4gICAgLy8gVGhlc2UgbWV0aG9kcyBhcmUgYSBiaXQgc3RyYW5nZSB0byBoYXZlIGhlcmUuXHJcbiAgICAvLyBUaGV5IHNob3VsZCBwcm9iYWJseSBiZSBhIHBhcnQgb2YgdGhlIGRvdGNzcyBjb3JlIG9iamVjdCBvciBzb21ldGhpbmcuXHJcbiAgICAvLyBBbHNvLCB0aGV5J3JlIHRoZSBvbmx5IGl0ZW1zIHRoYXQgYXJlIGV4cGxpY2l0bHkgcGFydCBvZiB0aGUgYnVpbGRlciByYXRoZXIgdGhhbiBnZW5lcmF0ZWQuXHJcbiAgICAvL1VzYWdlOlxyXG4gICAgLy9oaWRlKClcclxuICAgIC8vaGlkZShkdXJhdGlvbiwgY29tcGxldGUpXHJcbiAgICAvL2hpZGUob3B0aW9ucylcclxuICAgIC8vT3B0aW9uc1xyXG4gICAgLy9cdGRpc3BsYXk6IGlubGluZS1ibG9jaywgYmxvY2ssIGV0Yy5cclxuICAgIC8vXHRkdXJhdGlvbjogZHVyYXRpb24gaW4gbXMuXHJcbiAgICAvL1x0Y29tcGxldGU6IG9uLWNvbXBsZXRlIGNhbGxiYWNrLlxyXG4gICAgLy9cdGhpZGVTdHlsZTogZmFkZSwgc2hyaW5rLCBvciBub3JtYWxcclxuICAgIC8vXHRhbmltYXRpb25TdHlsZTogbGluZWFyIG9yIGV4cG9uZW50aWFsXHJcbiAgICBoaWRlKHN0eWxlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudGFyZ2V0cykge1xyXG4gICAgICAgICAgICB2YXIgYXJnMCA9IGFyZ3VtZW50c1swXSB8fCB7fTtcclxuICAgICAgICAgICAgdmFyIGFyZzBOID0gYXJnMDtcclxuICAgICAgICAgICAgdmFyIGFyZzBPID0gYXJnMDtcclxuICAgICAgICAgICAgdmFyIG9wcyA9IHt9O1xyXG4gICAgICAgICAgICBvcHMuZHVyYXRpb24gPSBhcmcwTy5kdXJhdGlvbiB8fCAoaXNOYU4oYXJnME4pID8gMCA6IGFyZzBOKSB8fCAwO1xyXG4gICAgICAgICAgICAvL29wcy5kaXNwbGF5ID0gYXJnMC5kaXNwbGF5IHx8IFwibm9uZVwiO1xyXG4gICAgICAgICAgICAvL29wcy5vcGFjaXR5ID0gYXJnMC5vcGFjaXR5IHx8IG51bGw7XHJcbiAgICAgICAgICAgIC8vb3BzLndpZHRoID0gYXJnMC53aWR0aCB8fCBudWxsO1xyXG4gICAgICAgICAgICAvL29wcy5oZWlnaHQgPSBhcmcwLmhlaWdodCB8fCBudWxsO1xyXG4gICAgICAgICAgICBvcHMuY29tcGxldGUgPSBhcmcwTy5jb21wbGV0ZSB8fCAodHlwZW9mIGFyZ3VtZW50c1sxXSA9PSBcImZ1bmN0aW9uXCIgPyBhcmd1bWVudHNbMV0gOiAodHlwZW9mIGFyZ3VtZW50c1syXSA9PSBcImZ1bmN0aW9uXCIgPyBhcmd1bWVudHNbMl0gOiBmdW5jdGlvbiAoKSB7IH0pKTtcclxuICAgICAgICAgICAgb3BzLmhpZGVTdHlsZSA9IGFyZzBPLmhpZGVTdHlsZSB8fCBcIm5vcm1hbFwiO1xyXG4gICAgICAgICAgICBvcHMuYW5pbWF0aW9uU3R5bGUgPSBhcmcwTy5hbmltYXRpb25TdHlsZSB8fCAodHlwZW9mIGFyZ3VtZW50c1sxXSA9PSBcInN0cmluZ1wiID8gYXJndW1lbnRzWzFdIDogXCJlYXNlXCIpO1xyXG4gICAgICAgICAgICBpZiAob3BzLmR1cmF0aW9uID4gMCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGRvbmVDbnQgPSAwO1xyXG4gICAgICAgICAgICAgICAgbGV0IG0gPSAwO1xyXG4gICAgICAgICAgICAgICAgbGV0IHEgPSB0aGlzLnRhcmdldHMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnRhcmdldHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgdyA9IHRoaXMudGFyZ2V0c1tpXS5zdHlsZS53aWR0aDtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgaCA9IHRoaXMudGFyZ2V0c1tpXS5zdHlsZS5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9TdHIgPSB0aGlzLnRhcmdldHNbaV0uc3R5bGUub3BhY2l0eTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIW9TdHIgfHwgb1N0ciA9PT0gXCJcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgbyA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvID0gTnVtYmVyKG9TdHIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBvdiA9IHRoaXMudGFyZ2V0c1tpXS5zdHlsZS5vdmVyZmxvdztcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BzLmhpZGVTdHlsZSAhPSBcImZhZGVcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRhcmdldHNbaV0uc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtICs9IDI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChmdW5jdGlvbiAodGhhdCwgdCwgdywgaCwgb3YpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdGNzcyh0KS53aWR0aC5hbmltYXRlKDAsIG9wcy5kdXJhdGlvbiwgb3BzLmFuaW1hdGlvblN0eWxlLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90Y3NzKHQpLmRpc3BsYXkoXCJub25lXCIpLndpZHRoKHcpLm92ZXJmbG93KG92KTsgLy9SZXN0b3JlIG9yaWdpbmFsIG92ZXJmbG93IHZhbHVlLiBPbmx5IG5lZWRzIHRvIGJlIGRvbmUgb25jZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lQ250Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmVDbnQgPj0gbSAqIHEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wcy5jb21wbGV0ZSh0aGF0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90Y3NzKHQpLmhlaWdodC5hbmltYXRlKDAsIG9wcy5kdXJhdGlvbiwgb3BzLmFuaW1hdGlvblN0eWxlLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90Y3NzKHQpLmRpc3BsYXkoXCJub25lXCIpLmhlaWdodChoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lQ250Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmVDbnQgPj0gbSAqIHEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wcy5jb21wbGV0ZSh0aGF0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSh0aGlzLCB0aGlzLnRhcmdldHNbaV0sIHcsIGgsIG92KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wcy5oaWRlU3R5bGUgIT0gXCJzaHJpbmtcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChmdW5jdGlvbiAodGhhdCwgdCwgbykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvdGNzcyh0KS5vcGFjaXR5LmFuaW1hdGUoMCwgb3BzLmR1cmF0aW9uLCBvcHMuYW5pbWF0aW9uU3R5bGUsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3Rjc3ModCkuZGlzcGxheShcIm5vbmVcIikub3BhY2l0eShvKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lQ250Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmVDbnQgPj0gbSAqIHEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wcy5jb21wbGV0ZSh0aGF0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSh0aGlzLCB0aGlzLnRhcmdldHNbaV0sIG8pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRvdGNzcyh0aGlzLnRhcmdldHMpLmRpc3BsYXkoXCJub25lXCIpO1xyXG4gICAgICAgICAgICAgICAgb3BzLmNvbXBsZXRlKHRoaXMpOyAvL1RoaXMgc2V0cyB0aGUgZGlzcGxheSB0byBub25lLlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLy9Vc2FnZTpcclxuICAgIC8vc2hvdygpXHJcbiAgICAvL3Nob3coZHVyYXRpb24sIGNvbXBsZXRlKVxyXG4gICAgLy9zaG93KG9wdGlvbnMpXHJcbiAgICAvL09wdGlvbnNcclxuICAgIC8vXHRkaXNwbGF5OiBpbmxpbmUtYmxvY2ssIGJsb2NrLCBldGMuXHJcbiAgICAvL1x0b3BhY2l0eTogZmluYWwgb3BhY2l0eS5cclxuICAgIC8vXHR3aWR0aDogZmluYWwgd2lkdGguXHJcbiAgICAvL1x0aGVpZ2h0OiBmaW5hbCBoZWlnaHQuXHJcbiAgICAvL1x0ZHVyYXRpb246IGR1cmF0aW9uIGluIG1zLlxyXG4gICAgLy9cdGNvbXBsZXRlOiBvbi1jb21wbGV0ZSBjYWxsYmFjay5cclxuICAgIC8vXHRzaG93U3R5bGU6IGZhZGUsIGdyb3csIG9yIG5vcm1hbFxyXG4gICAgLy9cdGFuaW1hdGlvblN0eWxlOiBsaW5lYXIgb3IgZXhwb25lbnRpYWxcclxuICAgIHNob3coc3R5bGUpIHtcclxuICAgICAgICBpZiAodGhpcy50YXJnZXRzKSB7XHJcbiAgICAgICAgICAgIGxldCBhcmcwID0gYXJndW1lbnRzWzBdIHx8IHt9O1xyXG4gICAgICAgICAgICBsZXQgYXJnME4gPSBhcmcwO1xyXG4gICAgICAgICAgICBsZXQgYXJnME8gPSBhcmcwO1xyXG4gICAgICAgICAgICBsZXQgb3BzID0ge307XHJcbiAgICAgICAgICAgIG9wcy5kdXJhdGlvbiA9IGFyZzBPLmR1cmF0aW9uIHx8IChpc05hTihhcmcwTikgPyAwIDogYXJnME4pIHx8IDA7XHJcbiAgICAgICAgICAgIG9wcy5kaXNwbGF5ID0gYXJnME8uZGlzcGxheSB8fCBcImJsb2NrXCI7XHJcbiAgICAgICAgICAgIG9wcy5vcGFjaXR5ID0gYXJnME8ub3BhY2l0eTtcclxuICAgICAgICAgICAgb3BzLndpZHRoID0gYXJnME8ud2lkdGggfHwgbnVsbDtcclxuICAgICAgICAgICAgb3BzLmhlaWdodCA9IGFyZzBPLmhlaWdodCB8fCBudWxsO1xyXG4gICAgICAgICAgICBvcHMuY29tcGxldGUgPSBhcmcwTy5jb21wbGV0ZSB8fCAodHlwZW9mIGFyZ3VtZW50c1sxXSA9PSBcImZ1bmN0aW9uXCIgPyBhcmd1bWVudHNbMV0gOiAodHlwZW9mIGFyZ3VtZW50c1syXSA9PSBcImZ1bmN0aW9uXCIgPyBhcmd1bWVudHNbMl0gOiBmdW5jdGlvbiAoKSB7IH0pKTtcclxuICAgICAgICAgICAgb3BzLnNob3dTdHlsZSA9IGFyZzBPLnNob3dTdHlsZSB8fCBcIm5vcm1hbFwiO1xyXG4gICAgICAgICAgICBvcHMuYW5pbWF0aW9uU3R5bGUgPSBhcmcwTy5hbmltYXRpb25TdHlsZSB8fCAodHlwZW9mIGFyZ3VtZW50c1sxXSA9PSBcInN0cmluZ1wiID8gYXJndW1lbnRzWzFdIDogXCJlYXNlXCIpO1xyXG4gICAgICAgICAgICBpZiAob3BzLmR1cmF0aW9uID4gMCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGRvbmVDbnQgPSAwO1xyXG4gICAgICAgICAgICAgICAgbGV0IHEgPSB0aGlzLnRhcmdldHMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgbGV0IG0gPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnRhcmdldHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbyA9IG9wcy5vcGFjaXR5O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHMub3BhY2l0eSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG8gPSBwYXJzZUZsb2F0KHRoaXMudGFyZ2V0c1tpXS5zdHlsZS5vcGFjaXR5KSB8fCAxO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BzLnNob3dTdHlsZSAhPSBcImZhZGVcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtICs9IDI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB3ID0gb3BzLndpZHRoIHx8IHRoaXMudGFyZ2V0c1tpXS5zdHlsZS53aWR0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGggPSBvcHMuaGVpZ2h0IHx8IHRoaXMudGFyZ2V0c1tpXS5zdHlsZS5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvdGNzcyh0aGlzLnRhcmdldHNbaV0pLndpZHRoKDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkb3Rjc3ModGhpcy50YXJnZXRzW2ldKS5oZWlnaHQoMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGRvbmVDbnQgKyBcIiBcIiArIHEqbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvdGNzcyh0aGlzLnRhcmdldHNbaV0pLndpZHRoLmFuaW1hdGUodywgb3BzLmR1cmF0aW9uLCBvcHMuYW5pbWF0aW9uU3R5bGUsIGZ1bmN0aW9uICgpIHsgZG9uZUNudCsrOyBpZiAoZG9uZUNudCA+PSBxICogbSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wcy5jb21wbGV0ZSgpOyB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZG90Y3NzKHRoaXMudGFyZ2V0c1tpXSkuaGVpZ2h0LmFuaW1hdGUoaCwgb3BzLmR1cmF0aW9uLCBvcHMuYW5pbWF0aW9uU3R5bGUsIGZ1bmN0aW9uICgpIHsgZG9uZUNudCsrOyBpZiAoZG9uZUNudCA+PSBxICogbSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wcy5jb21wbGV0ZSgpOyB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy9sZXQgbyA9IHRoaXMudGFyZ2V0c1tpXS5zdHlsZS5vcGFjaXR5OyAvL0d1ZXNzIEkgc2hvdWxkIGZhZGUgdG8gMT9cclxuICAgICAgICAgICAgICAgICAgICBkb3Rjc3ModGhpcy50YXJnZXRzW2ldKS5vcGFjaXR5KDApO1xyXG4gICAgICAgICAgICAgICAgICAgIGRvdGNzcyh0aGlzLnRhcmdldHNbaV0pLmRpc3BsYXkob3BzLmRpc3BsYXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHMuc2hvd1N0eWxlICE9IFwiZ3Jvd1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG0rKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgZG90Y3NzKHRoaXMudGFyZ2V0c1tpXSkub3BhY2l0eS5hbmltYXRlKG8sIG9wcy5kdXJhdGlvbiwgb3BzLmFuaW1hdGlvblN0eWxlLCBmdW5jdGlvbiAoKSB7IGRvbmVDbnQrKzsgaWYgKGRvbmVDbnQgPT0gcSAqIG0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHMuY29tcGxldGUoKTsgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvdGNzcyh0aGlzLnRhcmdldHMpLmRpc3BsYXkob3BzLmRpc3BsYXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgZmFkZU91dChkdXJhdGlvbiwgY29tcGxldGUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5oaWRlKHtcclxuICAgICAgICAgICAgZHVyYXRpb246IGlzTmFOKGR1cmF0aW9uKSA/IDQwMCA6IE51bWJlcihkdXJhdGlvbiksXHJcbiAgICAgICAgICAgIGhpZGVTdHlsZTogXCJmYWRlXCIsXHJcbiAgICAgICAgICAgIGNvbXBsZXRlOiBjb21wbGV0ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgZmFkZUluKGR1cmF0aW9uLCBjb21wbGV0ZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNob3coe1xyXG4gICAgICAgICAgICBkdXJhdGlvbjogaXNOYU4oZHVyYXRpb24pID8gNDAwIDogTnVtYmVyKGR1cmF0aW9uKSxcclxuICAgICAgICAgICAgc2hvd1N0eWxlOiBcImZhZGVcIixcclxuICAgICAgICAgICAgY29tcGxldGU6IGNvbXBsZXRlXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICA7XHJcbn1cclxuZXhwb3J0cy5fQnVpbGRlciA9IF9CdWlsZGVyO1xyXG4vLyBUaGlzIGNvdWxkIGJlIGJldHRlciBoYW5kZWxkLiBDb25zaWRlciBwdXR0aW5nIGl0IGluc2lkZSB0aGUgZG90Y3NzIGNsYXNzLlxyXG5kb3Rjc3MucHJvdG90eXBlLnRvU3RyaW5nID0gX0J1aWxkZXIucHJvdG90eXBlLnRvU3RyaW5nO1xyXG4vLyBXaHkgZG8gd2UgbmVlZCB0aGlzP1xyXG5jbGFzcyBfU3R5bGVQcm9wZXJ0eSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAvL0hhdmUgdG8gYWRkIHRoZXNlIGJhY2sgc2luY2Ugd2UncmUgZ29pbmcgdG8gcmVwbGFjZSB0aGUgX19wcm90b19fIG9mIGEgZnVuY3Rpb24gd2l0aCB0aGlzIG5ldyBwcm90b3R5cGUuXHJcbiAgICAgICAgdGhpcy5hcHBseSA9IEZ1bmN0aW9uLmFwcGx5O1xyXG4gICAgICAgIHRoaXMuY2FsbCA9IEZ1bmN0aW9uLmNhbGw7XHJcbiAgICAgICAgdGhpcy50eXBlID0gbnVsbDtcclxuICAgICAgICB0aGlzLmpzRnJpZW5kbHlQcm9wID0gbnVsbDtcclxuICAgIH1cclxuICAgIC8vdG9TdHJpbmcgb3ZlcnJpZGUgZ2V0cyB0aGUgdmFsdWUuXHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICBpZiAoZG90Y3NzMi5sYXN0QnVpbGRlci50YXJnZXRzKSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IHRoaXMgZG9lc24ndCBtYWtlIHNlbnNlLiBQbGVhc2UgZmlndXJlIGl0IG91dC5cclxuICAgICAgICAgICAgbGV0IHJldCA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmIChkb3Rjc3MyLmxhc3RCdWlsZGVyLnRhcmdldHMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0ID0gW107XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRvdGNzczIubGFzdEJ1aWxkZXIudGFyZ2V0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKGRvdGNzczIubGFzdEJ1aWxkZXIudGFyZ2V0c1tpXS5zdHlsZVt0aGlzLmpzRnJpZW5kbHlQcm9wXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgcmV0ID0gZG90Y3NzMi5sYXN0QnVpbGRlci50YXJnZXRzWzBdLnN0eWxlW3RoaXMuanNGcmllbmRseVByb3BdO1xyXG4gICAgICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgLy92YWwgaXMgYW5vdGhlciBzcGVjaWFsIGZ1bmN0aW9uIHRoYXQgYnJlYWtzIHRoZSB2YWx1ZSBpbnRvIGEgc3BlY2lhbCBvYmplY3QuXHJcbiAgICB2YWwoKSB7XHJcbiAgICAgICAgaWYgKGRvdGNzczIubGFzdEJ1aWxkZXIudGFyZ2V0cykge1xyXG4gICAgICAgICAgICBsZXQgcmV0ID0gbnVsbDtcclxuICAgICAgICAgICAgLy8gVE9ETzogc29tZXRoaW5nIHdyb25nIHdpdGggdGhpcy4gVHlwZXMgZG9uJ3QgY2hlY2sgb3V0LlxyXG4gICAgICAgICAgICBpZiAoZG90Y3NzMi5sYXN0QnVpbGRlci50YXJnZXRzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgIHJldCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRvdGNzczIubGFzdEJ1aWxkZXIudGFyZ2V0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkb3Rjc3MyLmxhc3RCdWlsZGVyLnRhcmdldHNbMF0uc3R5bGVbdGhpcy5qc0ZyaWVuZGx5UHJvcF0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2goZG90Y3NzMi5jb252ZXJ0U3R5bGVJbnRvRG90Q3NzT2JqZWN0KGRvdGNzczIubGFzdEJ1aWxkZXIudGFyZ2V0c1tpXS5zdHlsZVt0aGlzLmpzRnJpZW5kbHlQcm9wXSwgdGhpcy50eXBlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2gobnVsbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZG90Y3NzMi5sYXN0QnVpbGRlci50YXJnZXRzWzBdLnN0eWxlW3RoaXMuanNGcmllbmRseVByb3BdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0ID0gZG90Y3NzMi5jb252ZXJ0U3R5bGVJbnRvRG90Q3NzT2JqZWN0KGRvdGNzczIubGFzdEJ1aWxkZXIudGFyZ2V0c1swXS5zdHlsZVt0aGlzLmpzRnJpZW5kbHlQcm9wXSwgdGhpcy50eXBlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICByZXQgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICAvL0FiaWxpdHkgdG8gYW5pbWF0ZSBqdXN0IGxpa2UganF1ZXJ5LlxyXG4gICAgLy9jb21wbGV0ZSBkb2VzIG5vdCBnZXQgY2FsbGVkIGlmIHRoZSBhbmltYXRpb24gd2FzIGNhbmNlbGxlZC5cclxuICAgIGFuaW1hdGUodmFsdWUsIGR1cmF0aW9uLCBzdHlsZSwgY29tcGxldGUpIHtcclxuICAgICAgICBkdXJhdGlvbiA9IGlzTmFOKGR1cmF0aW9uKSA/IDQwMCA6IChkdXJhdGlvbiB8fCAwKTtcclxuICAgICAgICBpZiAoZG90Y3NzMi5sYXN0QnVpbGRlciAmJiBkb3Rjc3MyLmxhc3RCdWlsZGVyLnRhcmdldHMpIHtcclxuICAgICAgICAgICAgaWYgKCFjb21wbGV0ZSAmJiBzdHlsZSAmJiBzdHlsZS5jYWxsICYmIHN0eWxlLmFwcGx5KSB7IC8vRml4IHBhcmFtcy5cclxuICAgICAgICAgICAgICAgIGNvbXBsZXRlID0gc3R5bGU7XHJcbiAgICAgICAgICAgICAgICBzdHlsZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRvdGNzczIubGFzdEJ1aWxkZXIudGFyZ2V0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgbGV0IHRhcmdldCA9IGRvdGNzczIubGFzdEJ1aWxkZXIudGFyZ2V0c1tpXTtcclxuICAgICAgICAgICAgICAgIGxldCBvbGRWYWx1ZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBsZXQgbmV3VmFsdWUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgbGV0IGZpbmFsVmFsdWUgPSBudWxsOyAvL25ld1ZhbHVlIG1pZ2h0IGJlIGluIGRpZmZlcmVudCB1bml0cyBmcm9tIHRoZSBmaW5hbCB2YWx1ZS4uLlxyXG4gICAgICAgICAgICAgICAgLy9HZXQgdGhlIG9sZCBhbmQgbmV3IHZhbHVlcy5cclxuICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gZG90Y3NzMi5jb252ZXJ0U3R5bGVJbnRvRG90Q3NzT2JqZWN0KHZhbHVlLCB0aGlzLnR5cGUpO1xyXG4gICAgICAgICAgICAgICAgLy9JZiBpdCdzIGEgdHJhbnNmb3JtYXRpb24sIGEgbGl0dGxlIGV4dHJhIHdvcmsgaXMgcmVxdWlyZWQuXHJcbiAgICAgICAgICAgICAgICAvL05lZWQgdG8gZnJhbWUgYWxsIHRoZSByb3RhdGlvbnMgcHJvcGVybHksIGFuZCBjb21iaW5lIGJvdGggdGhlIG5ldyBhbmQgdGhlIG9sZCB0cmFuc2Zvcm1hdGlvbnMuXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50eXBlID09IFwidHJhbnNmb3JtYXRpb25cIikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vU3BlY2lhbCBoYW5kbGluZy4gV2UnZCBsaWtlIHRvIGNvbnNpZGVyIHRoZSB0cmFuc2Zvcm1hdGlvbiBhcyBhIGNvbXBsZXggZGF0YSB0eXBlIGZpcnN0LCB0aGVuIGlmIHRoYXQncyBub3QgcG9zc2libGUsIGNvbnZlcnQgaXQgaW50byBhIG1hdHJpeCBkYXRhIHR5cGUuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9SZWFzb24gYmVpbmc6IGxpbmVhciB0cmFuc2Zvcm1hdGlvbnMgb24gbWF0cmljZXMgYXJlIGluYWNjdXJhdGUuIFJvdGF0aW9ucyBlbmQgdXAgc2NhbGluZyB0aGUgdGFyZ2V0LlxyXG4gICAgICAgICAgICAgICAgICAgIC8vRG9uJ3Qgd2FudCB0byBnZXQgdGhlIGNvbXB1dGVkIHZhbHVlIGZvciB0cmFuc2Zvcm1hdGlvbnMuXHJcbiAgICAgICAgICAgICAgICAgICAgb2xkVmFsdWUgPSBkb3Rjc3MyLmNvbnZlcnRTdHlsZUludG9Eb3RDc3NPYmplY3QodGFyZ2V0LnN0eWxlW3RoaXMuanNGcmllbmRseVByb3BdLCB0aGlzLnR5cGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFvbGRWYWx1ZSkgeyAvL1N0YW5kYXJkLiBIYXBwZW5zIHdoZW4gdGhlIHR5cGUgaXMgbm90IGEgdHJhbnNmb3JtYXRpb24uXHJcbiAgICAgICAgICAgICAgICAgICAgb2xkVmFsdWUgPSBkb3Rjc3MyLmNvbnZlcnRTdHlsZUludG9Eb3RDc3NPYmplY3QoZG90Y3NzMi5jb21wdXRlZFN0eWxlT3JBY3R1YWxTdHlsZSh0YXJnZXQsIHRoaXMuanNGcmllbmRseVByb3ApLCB0aGlzLnR5cGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZmluYWxWYWx1ZSA9IG5ld1ZhbHVlLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAvL0RvIGEgbGl0dGxlIHR5cGUvdW5pdCBjaGVja2luZy5cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT0gXCJsZW5ndGhcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvbGRWYWx1ZS51bml0cyAhPSBuZXdWYWx1ZS51bml0cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL05lZWQgdG8gcmVjdGlmeSB0aGlzLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL1RoaXMgY2FuIGdldCBtZXNzeS4gSWYgb25lIG9mIHRoZSBsZW5ndGhzIGlzIHplcm8sIGl0IHdvdWxkIG1pbmltaXplIHRoZSBsaWtlbGlob29kIG9mIGFuIGVycm9yLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob2xkVmFsdWUubGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZFZhbHVlLnVuaXRzID0gbmV3VmFsdWUudW5pdHM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGRWYWx1ZS5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5ld1ZhbHVlLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZS51bml0cyA9IG9sZFZhbHVlLnVuaXRzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vVGhpbmdzIGFyZSBtZXNzeS4gVHJ5IHRvIG1pdGlnYXRlLiBDb252ZXJ0IHRoZSBvbGQgdmFsdWUgaW50byB0aGUgbmV3IHVuaXRzLCBhcyBiZXN0IHdlIGNhbi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjdXJyZW50TGVuZ3RoUHggPSBkb3Rjc3MubGVuZ3RoVG9QeChvbGRWYWx1ZS50b1N0cmluZygpLCB0aGlzLmpzRnJpZW5kbHlQcm9wLCB0YXJnZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5ld0xlbmd0aFB4ID0gZG90Y3NzLmxlbmd0aFRvUHgobmV3VmFsdWUudG9TdHJpbmcoKSwgdGhpcy5qc0ZyaWVuZGx5UHJvcCwgdGFyZ2V0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZFZhbHVlLmxlbmd0aCA9IGN1cnJlbnRMZW5ndGhQeDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZFZhbHVlLnVuaXRzID0gXCJweFwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUubGVuZ3RoID0gbmV3TGVuZ3RoUHg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZS51bml0cyA9IFwicHhcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vV29uJ3QgbmVlZCB0aGlzIGFueW1vcmUuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUud2FybihcIkNvdWxkbid0IGFuaW1hdGUgXCIgKyB0aGlzLmpzRnJpZW5kbHlQcm9wICsgXCIuIEluY29uc2lzdGVudCB1bml0cy5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3JldHVybiBkb3Rjc3MyLl9sYXN0QnVpbGRlcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMudHlwZSA9PSBcImNvbG9yXCIpIHsgfSAvL09LXHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLnR5cGUgPT0gXCJ0cmFuc2Zvcm1hdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9Db3VwbGUgdGhpbmdzIHRvIGRvIGhlcmUuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8xLiBUaGUgb2xkIGFuZCBuZXcgdmFsdWVzIG11c3QgY29udGFpbiB0aGUgZXhhY3Qgc2FtZSB0cmFuc2Zvcm1hdGlvbiB0ZW1wbGF0ZS5cclxuICAgICAgICAgICAgICAgICAgICAvLzIuIEFuZ2xlcyBpbiB0aGUgb2xkIHRyYW5zZm9ybWF0aW9uIHNob3VsZCBiZSByZWZyYW1lZCBzbyB0aGF0IHRoZXkgYXJlIGNsb3NlIHRvIHRoZSBuZXcgYW5nbGVzIChvciBzaG91bGQgdGhleSlcclxuICAgICAgICAgICAgICAgICAgICBsZXQgc3RhcnRUcmFuc2Zvcm0gPSBcIlwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBkZXNpcmVkVHJhbnNmb3JtID0gXCJcIjtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgb2xkSW5kZXggPSBvbGRWYWx1ZS50cmFuc2Zvcm1hdGlvbnMubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbmV3SW5kZXggPSBuZXdWYWx1ZS50cmFuc2Zvcm1hdGlvbnMubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAob2xkSW5kZXggPj0gMCB8fCBuZXdJbmRleCA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0cmFuc2Zvcm1Ub0FkZCA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBvbGRUcmFuc2Zvcm1WYWx1ZXMgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmV3VHJhbnNmb3JtVmFsdWVzID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9sZEluZGV4ID49IDAgJiYgbmV3SW5kZXggPj0gMCAmJiBvbGRWYWx1ZS50cmFuc2Zvcm1hdGlvbnNbb2xkSW5kZXhdLnRyYW5zZm9ybWF0aW9uID09IG5ld1ZhbHVlLnRyYW5zZm9ybWF0aW9uc1tuZXdJbmRleF0udHJhbnNmb3JtYXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjdXJyZW50T2xkVCA9IG9sZFZhbHVlLnRyYW5zZm9ybWF0aW9uc1tvbGRJbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgY3VycmVudE5ld1QgPSBuZXdWYWx1ZS50cmFuc2Zvcm1hdGlvbnNbbmV3SW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtVG9BZGQgPSBjdXJyZW50T2xkVC50cmFuc2Zvcm1hdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZFRyYW5zZm9ybVZhbHVlcyA9IGN1cnJlbnRPbGRULmFyZ3M7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdUcmFuc2Zvcm1WYWx1ZXMgPSBjdXJyZW50TmV3VC5hcmdzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkSW5kZXgtLTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0luZGV4LS07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob2xkSW5kZXggPj0gbmV3SW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjdXJyZW50T2xkVCA9IG9sZFZhbHVlLnRyYW5zZm9ybWF0aW9uc1tvbGRJbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1Ub0FkZCA9IGN1cnJlbnRPbGRULnRyYW5zZm9ybWF0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkVHJhbnNmb3JtVmFsdWVzID0gY3VycmVudE9sZFQuYXJncztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0cmFuc2Zvcm1Ub0FkZCA9PSBcIm1hdHJpeFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3VHJhbnNmb3JtVmFsdWVzID0gWzEsIDAsIDAsIDEsIDAsIDBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHJhbnNmb3JtVG9BZGQgPT0gXCJtYXRyaXgzZFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3VHJhbnNmb3JtVmFsdWVzID0gWzEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZpbGxlciA9ICh0cmFuc2Zvcm1Ub0FkZC5pbmRleE9mKFwic2NhbGVcIikgPT0gLTEpID8gMCA6IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3VHJhbnNmb3JtVmFsdWVzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBvbGRUcmFuc2Zvcm1WYWx1ZXMubGVuZ3RoOyBqKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1RyYW5zZm9ybVZhbHVlcy5wdXNoKCFpc05hTihvbGRUcmFuc2Zvcm1WYWx1ZXNbal0pID8gZmlsbGVyIDogKCFpc05hTihvbGRUcmFuc2Zvcm1WYWx1ZXNbal0uYW5nbGUpID8gbmV3IGNzc19hbmdsZV8xLmRlZmF1bHQoMCkgOiAoIWlzTmFOKG9sZFRyYW5zZm9ybVZhbHVlc1tqXS5sZW5ndGgpID8gbmV3IGNzc19sZW5ndGhfMS5kZWZhdWx0KDApIDogKDApKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkSW5kZXgtLTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjdXJyZW50TmV3VCA9IG5ld1ZhbHVlLnRyYW5zZm9ybWF0aW9uc1tuZXdJbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1Ub0FkZCA9IGN1cnJlbnROZXdULnRyYW5zZm9ybWF0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3VHJhbnNmb3JtVmFsdWVzID0gY3VycmVudE5ld1QuYXJncztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0cmFuc2Zvcm1Ub0FkZCA9PSBcIm1hdHJpeFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkVHJhbnNmb3JtVmFsdWVzID0gWzEsIDAsIDAsIDEsIDAsIDBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHJhbnNmb3JtVG9BZGQgPT0gXCJtYXRyaXgzZFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkVHJhbnNmb3JtVmFsdWVzID0gWzEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZpbGxlciA9ICh0cmFuc2Zvcm1Ub0FkZC5pbmRleE9mKFwic2NhbGVcIikgPT0gLTEpID8gMCA6IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkVHJhbnNmb3JtVmFsdWVzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBuZXdUcmFuc2Zvcm1WYWx1ZXMubGVuZ3RoOyBqKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZFRyYW5zZm9ybVZhbHVlcy5wdXNoKCFpc05hTihuZXdUcmFuc2Zvcm1WYWx1ZXNbal0pID8gZmlsbGVyIDogKCFpc05hTihuZXdUcmFuc2Zvcm1WYWx1ZXNbal0uYW5nbGUpID8gbmV3IGNzc19hbmdsZV8xLmRlZmF1bHQoMCkgOiAoIWlzTmFOKG5ld1RyYW5zZm9ybVZhbHVlc1tqXS5sZW5ndGgpID8gbmV3IGNzc19sZW5ndGhfMS5kZWZhdWx0KDApIDogKDApKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3SW5kZXgtLTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydFRyYW5zZm9ybSA9IFwiKSBcIiArIHN0YXJ0VHJhbnNmb3JtO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNpcmVkVHJhbnNmb3JtID0gXCIpIFwiICsgZGVzaXJlZFRyYW5zZm9ybTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9IYW5kbGUgc3BlY2lhbCB2YWx1ZXMgaGVyZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRyYW5zZm9ybVRvQWRkLmluZGV4T2YoXCJyb3RhdGVcIikgIT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBvbGRBbmdsZSA9IG9sZFRyYW5zZm9ybVZhbHVlc1tvbGRUcmFuc2Zvcm1WYWx1ZXMubGVuZ3RoIC0gMV0uYW5nbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmV3QW5nbGUgPSBuZXdUcmFuc2Zvcm1WYWx1ZXNbbmV3VHJhbnNmb3JtVmFsdWVzLmxlbmd0aCAtIDFdLmFuZ2xlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHNlcCA9IGRvdGNzcy5hbmdsZVN1YnRyYWN0KG5ld0FuZ2xlLCBvbGRBbmdsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGRUcmFuc2Zvcm1WYWx1ZXNbb2xkVHJhbnNmb3JtVmFsdWVzLmxlbmd0aCAtIDFdLmFuZ2xlID0gbmV3QW5nbGUgLSBzZXA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IG9sZFRyYW5zZm9ybVZhbHVlcy5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRUcmFuc2Zvcm0gPSBcIixcIiArIG9sZFRyYW5zZm9ybVZhbHVlc1tpXSArIHN0YXJ0VHJhbnNmb3JtO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzaXJlZFRyYW5zZm9ybSA9IFwiLFwiICsgbmV3VHJhbnNmb3JtVmFsdWVzW2ldICsgZGVzaXJlZFRyYW5zZm9ybTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydFRyYW5zZm9ybSA9IHRyYW5zZm9ybVRvQWRkICsgXCIoXCIgKyBzdGFydFRyYW5zZm9ybS5zdWJzdHJpbmcoMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2lyZWRUcmFuc2Zvcm0gPSB0cmFuc2Zvcm1Ub0FkZCArIFwiKFwiICsgZGVzaXJlZFRyYW5zZm9ybS5zdWJzdHJpbmcoMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIG9sZFZhbHVlID0gZG90Y3NzMi5jb252ZXJ0U3R5bGVJbnRvRG90Q3NzT2JqZWN0KHN0YXJ0VHJhbnNmb3JtLCBcInRyYW5zZm9ybWF0aW9uXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gZG90Y3NzMi5jb252ZXJ0U3R5bGVJbnRvRG90Q3NzT2JqZWN0KGRlc2lyZWRUcmFuc2Zvcm0sIFwidHJhbnNmb3JtYXRpb25cIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvbGRWYWx1ZS50eXBlID09IFwibnVtYmVyXCIgJiYgbmV3VmFsdWUudHlwZSA9PSBcIm51bWJlclwiKSB7IH0gLy9PS1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob2xkVmFsdWUudHlwZSA9PSBcImNvbXBsZXhcIiAmJiBuZXdWYWx1ZS50eXBlID09IFwiY29tcGxleFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkb3Rjc3MyLmNvbXBhcmVDb21wbGV4RGF0YVR5cGVzKG9sZFZhbHVlLCBuZXdWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiQ291bGRuJ3QgYW5pbWF0ZSBcIiArIHRoaXMuanNGcmllbmRseVByb3AgKyBcIi4gVmFsdWUgbWlzbWF0Y2guXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJDb3VsZG4ndCBhbmltYXRlIFwiICsgdGhpcy5qc0ZyaWVuZGx5UHJvcCArIFwiLiBOb3QgYSByZWNvZ25pemFibGUgbGVuZ3RoLCBjb2xvciwgb3IgbnVtYmVyLlwiKTtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGRvdGNzczIuYW5pbWF0ZUZ1bGwodGFyZ2V0LCB0aGlzLmpzRnJpZW5kbHlQcm9wLCBvbGRWYWx1ZS50eXBlIHx8IHRoaXMudHlwZSwgb2xkVmFsdWUsIG5ld1ZhbHVlLCBmaW5hbFZhbHVlLCBkb3Rjc3MyLmZ4SW50ZXJ2YWwsIGR1cmF0aW9uLCBzdHlsZSB8fCBcImVhc2VcIiwgY29tcGxldGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkb3Rjc3MyLmxhc3RCdWlsZGVyO1xyXG4gICAgfVxyXG59XHJcbjtcclxuZG90Y3NzLmZvcm1hdE51bWJlclZhbHVlID0gZnVuY3Rpb24gKHZhbHVlLCB1bml0KSB7XHJcbiAgICBzd2l0Y2ggKHVuaXQpIHtcclxuICAgICAgICBjYXNlIFwicHhcIjogcmV0dXJuIE1hdGgucm91bmQodmFsdWUpO1xyXG4gICAgICAgIGRlZmF1bHQ6IHJldHVybiBNYXRoLnJvdW5kKHZhbHVlICogMTAwKSAvIDEwMDtcclxuICAgIH1cclxufTtcclxuLy8gVE9ETzogZmlndXJlIG91dCBhIHdheSB0byBhZGQgdk1hcmdpbiwgaE1hcmdpbiwgdlBhZGRpbmcsIGV0Yy5cclxuY29uc3QgX2FsbFByb3BzID0ge1xyXG4gICAgY29sb3I6IFwiY29sb3J8YmFja2dyb3VuZC1Db2xvcnxib3JkZXItQm90dG9tLUNvbG9yfGJvcmRlci1Db2xvcnxib3JkZXItTGVmdC1Db2xvcnxib3JkZXItUmlnaHQtQ29sb3J8Ym9yZGVyLVRvcC1Db2xvcnx0ZXh0LURlY29yYXRpb24tQ29sb3J8b3V0bGluZS1Db2xvcnxjb2x1bW4tUnVsZS1Db2xvclwiLFxyXG4gICAgbGVuZ3RoOiBcImJhY2tncm91bmQtU2l6ZXxibG9jay1TaXplfGJvcmRlci1Cb3R0b20tTGVmdC1SYWRpdXN8Ym9yZGVyLUJvdHRvbS1SaWdodC1SYWRpdXN8Ym9yZGVyLUJvdHRvbS1XaWR0aHxib3JkZXItSW1hZ2UtV2lkdGh8Ym9yZGVyLUxlZnQtV2lkdGh8Ym9yZGVyLVJhZGl1c3xib3JkZXItUmlnaHQtV2lkdGh8Ym9yZGVyLVRvcC1MZWZ0LVJhZGl1c3xib3JkZXItVG9wLVJpZ2h0LVJhZGl1c3xib3JkZXItVG9wLVdpZHRofGJvcmRlci1XaWR0aHxib3R0b218Z2FwfGhlaWdodHxsZWZ0fG1hcmdpbnxtYXJnaW4tQm90dG9tfG1hcmdpbi1MZWZ0fG1hcmdpbi1SaWdodHxtYXJnaW4tVG9wfG1heC1IZWlnaHR8bWF4LVdpZHRofG1pbi1IZWlnaHR8bWluLVdpZHRofHBhZGRpbmd8cGFkZGluZy1Cb3R0b218cGFkZGluZy1MZWZ0fHBhZGRpbmctUmlnaHR8cGFkZGluZy1Ub3B8cmlnaHR8dG9wfHdpZHRofGxpbmUtSGVpZ2h0fGZsZXgtQmFzaXN8Zm9udC1TaXplfHRleHQtSW5kZW50XCIsXHJcbiAgICB1cmw6IFwiYmFja2dyb3VuZC1JbWFnZXxib3JkZXItSW1hZ2V8bGlzdC1TdHlsZS1JbWFnZXxjb250ZW50fGltYWdlLU9yaWVudGF0aW9uXCIsXHJcbiAgICB0cmFuc2Zvcm1hdGlvbjogXCJ0cmFuc2Zvcm1cIixcclxuICAgIGZpbHRlcjogXCJmaWx0ZXJ8YmFja2Ryb3AtRmlsdGVyXCIsXHJcbiAgICBtaXNjOiBcImFwcGVhcmFuY2V8YXNwZWN0LVJhdGlvfG9wYWNpdHl8YmFja2dyb3VuZHxiYWNrZ3JvdW5kLUF0dGFjaG1lbnR8YmFja2dyb3VuZC1CbGVuZC1Nb2RlfGJhY2tncm91bmQtUG9zaXRpb258YmFja2dyb3VuZC1SZXBlYXR8YmFja2dyb3VuZC1DbGlwfGJhY2tncm91bmQtT3JpZ2lufGJvcmRlcnxib3JkZXItQm90dG9tfGJvcmRlci1Cb3R0b20tU3R5bGV8Ym9yZGVyLUltYWdlLU91dHNldHxib3JkZXItSW1hZ2UtUmVwZWF0fGJvcmRlci1JbWFnZS1TbGljZXxib3JkZXItSW1hZ2UtU291cmNlfGJvcmRlci1MZWZ0fGJvcmRlci1MZWZ0LVN0eWxlfGJvcmRlci1SaWdodHxib3JkZXItUmlnaHQtU3R5bGV8Ym9yZGVyLVN0eWxlfGJvcmRlci1Ub3B8Ym9yZGVyLVRvcC1TdHlsZXxib3gtRGVjb3JhdGlvbi1CcmVha3xib3gtU2hhZG93fGNsZWFyfGNsaXB8ZGlzcGxheXxmbG9hdHxvdmVyZmxvd3xib3h8b3ZlcmZsb3ctWHxvdmVyZmxvdy1ZfHBvc2l0aW9ufHZpc2liaWxpdHl8dmVydGljYWwtQWxpZ258ei1JbmRleHxhbGlnbi1Db250ZW50fGFsaWduLUl0ZW1zfGFsaWduLVNlbGZ8ZmxleHxmbGV4LUJhc2lzfGZsZXgtRGlyZWN0aW9ufGZsZXgtRmxvd3xmbGV4LUdyb3d8ZmxleC1TaHJpbmt8ZmxleC1XcmFwfGdyaWR8Z3JpZC1BcmVhfGdyaWQtQXV0by1Db2x1bW5zfGdyaWQtYXV0by1Sb3dzfGdyaWQtQ29sdW1ufGdyaWQtQ29sdW1uLUVuZHxncmlkLUNvbHVtbi1HYXB8Z3JpZC1Db2x1bW4tU3RhcnR8Z3JpZC1HYXB8Z3JpZC1Sb3d8Z3JpZC1Sb3ctRW5kfGdyaWQtUm93LUdhcHxncmlkLVJvdy1TdGFydHxncmlkLVRlbXBsYXRlfGdyaWQtVGVtcGxhdGUtQXJlYXN8Z3JpZC1UZW1wbGF0ZS1Db2x1bW5zfGdyaWQtVGVtcGxhdGUtUm93c3xqdXN0aWZ5LUNvbnRlbnR8b3JkZXJ8aGFuZ2luZy1QdW5jdHVhdGlvbnxoeXBoZW5zfGxldHRlci1TcGFjaW5nfGxpbmUtQnJlYWt8b3ZlcmZsb3ctV3JhcHx0YWItU2l6ZXx0ZXh0LUFsaWdufHRleHQtQWxpZ24tTGFzdHx0ZXh0LUNvbWJpbmUtVXByaWdodHx0ZXh0LUp1c3RpZnl8dGV4dC1UcmFuc2Zvcm18d2hpdGUtU3BhY2V8d29yZC1CcmVha3x3b3JkLVNwYWNpbmd8d29yZC1XcmFwfHRleHQtRGVjb3JhdGlvbnx0ZXh0LURlY29yYXRpb24tTGluZXx0ZXh0LURlY29yYXRpb24tU3R5bGV8dGV4dC1TaGFkb3d8dGV4dC1VbmRlcmxpbmUtUG9zaXRpb258Zm9udHxmb250LUZhbWlseXxmb250LUZlYXR1cmUtU2V0dGluZ3N8Zm9udC1LZXJuaW5nfGZvbnQtTGFuZ3VhZ2UtT3ZlcnJpZGV8Zm9udC1TaXplLUFkanVzdHxmb250LVN0cmV0Y2h8Zm9udC1TdHlsZXxmb250LVN5bnRoZXNpc3xmb250LVZhcmlhbnR8Zm9udC1WYXJpYW50LUFsdGVybmF0ZXN8Zm9udC1WYXJpYW50LUNhcHN8Zm9udC1WYXJpYW50LUVhc3QtQXNpYW58Zm9udC1WYXJpYW50LUxpZ2F0dXJlc3xmb250LVZhcmlhbnQtTnVtZXJpY3xmb250LVZhcmlhbnQtUG9zaXRpb258Zm9udC1XZWlnaHR8ZGlyZWN0aW9ufHRleHQtT3JpZW50YXRpb258dGV4dC1Db21iaW5lLVVwcmlnaHR8dW5pY29kZS1CaWRpfHVzZXItU2VsZWN0fHdyaXRpbmctTW9kZXxib3JkZXItQ29sbGFwc2V8Ym9yZGVyLVNwYWNpbmd8Y2FwdGlvbi1TaWRlfGVtcHR5LUNlbGxzfHRhYmxlLUxheW91dHxjb3VudGVyLUluY3JlbWVudHxjb3VudGVyLVJlc2V0fGxpc3QtU3R5bGV8bGlzdC1TdHlsZS1Qb3NpdGlvbnxsaXN0LVN0eWxlLVR5cGV8YW5pbWF0aW9ufGFuaW1hdGlvbi1EZWxheXxhbmltYXRpb24tRGlyZWN0aW9ufGFuaW1hdGlvbi1EdXJhdGlvbnxhbmltYXRpb24tRmlsbC1Nb2RlfGFuaW1hdGlvbi1JdGVyYXRpb24tQ291bnR8YW5pbWF0aW9uLU5hbWV8YW5pbWF0aW9uLVBsYXktU3RhdGV8YW5pbWF0aW9uLVRpbWluZy1GdW5jdGlvbnxiYWNrZmFjZS1WaXNpYmlsaXR5fHBlcnNwZWN0aXZlMmR8cGVyc3BlY3RpdmUtT3JpZ2lufHRyYW5zZm9ybS1PcmlnaW58dHJhbnNmb3JtLVN0eWxlfHRyYW5zaXRpb258dHJhbnNpdGlvbi1Qcm9wZXJ0eXx0cmFuc2l0aW9uLUR1cmF0aW9ufHRyYW5zaXRpb24tVGltaW5nLUZ1bmN0aW9ufHRyYW5zaXRpb24tRGVsYXl8Ym94LVNpemluZ3xjdXJzb3J8aW1lLU1vZGV8bmF2LURvd258bmF2LUluZGV4fG5hdi1MZWZ0fG5hdi1SaWdodHxuYXYtVXB8b3V0bGluZXxvdXRsaW5lLU9mZnNldHxvdXRsaW5lLVN0eWxlfG91dGxpbmUtV2lkdGh8cmVzaXplfHRleHQtT3ZlcmZsb3d8YnJlYWstQWZ0ZXJ8YnJlYWstQmVmb3JlfGJyZWFrLUluc2lkZXxjb2x1bW4tQ291bnR8Y29sdW1uLUZpbGx8Y29sdW1uLUdhcHxjb2x1bW4tUnVsZXxjb2x1bW4tUnVsZS1TdHlsZXxjb2x1bW4tUnVsZS1XaWR0aHxjb2x1bW4tU3Bhbnxjb2x1bW4tV2lkdGh8Y29sdW1uc3x3aWRvd3N8b3JwaGFuc3xwYWdlLUJyZWFrLUFmdGVyfHBhZ2UtQnJlYWstQmVmb3JlfHBhZ2UtQnJlYWstSW5zaWRlfG1hcmtzfHF1b3Rlc3xpbWFnZS1SZW5kZXJpbmd8aW1hZ2UtUmVzb2x1dGlvbnxvYmplY3QtRml0fG9iamVjdC1Qb3NpdGlvbnxtYXNrfG1hc2stVHlwZXxtYXJrfG1hcmstQWZ0ZXJ8bWFyay1CZWZvcmV8cGhvbmVtZXN8cmVzdHxyZXN0LUFmdGVyfHJlc3QtQmVmb3JlfHZvaWNlLUJhbGFuY2V8dm9pY2UtRHVyYXRpb258dm9pY2UtUGl0Y2h8dm9pY2UtUGl0Y2gtUmFuZ2V8dm9pY2UtUmF0ZXx2b2ljZS1TdHJlc3N8dm9pY2UtVm9sdW1lfG1hcnF1ZWUtRGlyZWN0aW9ufG1hcnF1ZWUtUGxheS1Db3VudHxtYXJxdWVlLVNwZWVkfG1hcnF1ZWUtU3R5bGV8cG9pbnRlci1FdmVudHNcIlxyXG59O1xyXG4vLyBjb25zdCBfYWxsVHJhbnNmb3JtcyA9IFtcclxuLy8gXHRcIm1hdHJpeFwiLFxyXG4vLyBcdFwibWF0cml4M2RcIixcclxuLy8gXHRcInRyYW5zbGF0ZVwiLFxyXG4vLyBcdFwidHJhbnNsYXRlM2RcIixcclxuLy8gXHRcInRyYW5zbGF0ZVhcIixcclxuLy8gXHRcInRyYW5zbGF0ZVlcIixcclxuLy8gXHRcInRyYW5zbGF0ZVpcIixcclxuLy8gXHRcInNjYWxlXCIsXHJcbi8vIFx0XCJzY2FsZTNkXCIsXHJcbi8vIFx0XCJzY2FsZVhcIixcclxuLy8gXHRcInNjYWxlWVwiLFxyXG4vLyBcdFwic2NhbGVaXCIsXHJcbi8vIFx0XCJyb3RhdGVcIixcclxuLy8gXHRcInJvdGF0ZTNkXCIsXHJcbi8vIFx0XCJyb3RhdGVYXCIsXHJcbi8vIFx0XCJyb3RhdGVZXCIsXHJcbi8vIFx0XCJyb3RhdGVaXCIsXHJcbi8vIFx0XCJza2V3XCIsXHJcbi8vIFx0XCJza2V3WFwiLFxyXG4vLyBcdFwic2tld1lcIixcclxuLy8gXHRcInBlcnNwZWN0aXZlXCJcclxuLy8gXVxyXG4vLyBUT0RPOiB0aGlzIG1heSBoYXZlIGJlZW4gaW50ZW5kZWQgdG8gYmUgcHJpdmF0ZS5cclxuZG90Y3NzLm1hdHJpeE11bHRpcGx5M0QgPSBmdW5jdGlvbiAoQSwgQikge1xyXG4gICAgaWYgKEEubGVuZ3RoICE9IDE2IHx8IEIubGVuZ3RoICE9IDE2KVxyXG4gICAgICAgIHRocm93IFwiM0QgbWF0cmljZXMgbXVzdCBiZSBhcnJheXMgb2YgMTYgbGVuZ3RoLlwiO1xyXG4gICAgdmFyIHJldCA9IFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXTtcclxuICAgIGZvciAodmFyIHkgPSAwOyB5IDwgNDsgeSsrKVxyXG4gICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgNDsgeCsrKVxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKylcclxuICAgICAgICAgICAgICAgIHJldFt5ICsgeCAqIDRdICs9IE51bWJlcihBW3kgKyBpICogNF0pICogTnVtYmVyKEJbaSArIHggKiA0XSk7XHJcbiAgICByZXR1cm4gcmV0O1xyXG59O1xyXG4vL1B1YmxpYyBmdW5jdGlvbnMuXHJcbi8vIFRPRE86IHRoaXMgZG9lc24ndCByZWFsbHkgYmVsb25nIGluIGhlcmUuIFRoaXMgaXMgbGlrZSBhIG1hdGggbGliLlxyXG4vLyAvLyBUT0RPOiBJIGRvbid0IHRoaW5rIHRoZXNlIGFyZSByZWFsbHkgbmVlZGVkLiBUaGUgY3NzIHR5cGVzIHRha2UgY2FyZSBvZiB0aGVzZS5cclxuLy8gZG90Y3NzLmFuZ2xlU3VidHJhY3QgPSBmdW5jdGlvbihhOiBudW1iZXIsIGI6IG51bWJlcik6bnVtYmVye1xyXG4vLyBcdGlmKGEgPCAwKSBhID0gMzYwIC0gKCgtYSkgJSAzNjApOyBlbHNlIGEgPSBhICUgMzYwO1xyXG4vLyBcdGlmKGIgPCAwKSBiID0gMzYwIC0gKCgtYikgJSAzNjApOyBlbHNlIGIgPSBiICUgMzYwO1xyXG4vLyBcdHZhciBwaGkgPSBNYXRoLmFicyhiIC0gYSkgJSAzNjA7XHJcbi8vIFx0dmFyIGQgPSBwaGkgPiAxODAgPyAzNjAgLSBwaGkgOiBwaGk7XHJcbi8vIFx0dmFyIHNpZ24gPSAoYSAtIGIgPj0gMCAmJiBhIC0gYiA8PSAxODApIHx8IChhIC0gYiA8PS0xODAgJiYgYS0gYj49IC0zNjApID8gMSA6IC0xO1xyXG4vLyBcdHJldHVybiBkICogc2lnbjtcclxuLy8gfTtcclxuLy8gLy9TcGVjaWFsIGhhbmRsZXIgZm9yIGJ1aWxkaW5nIHVybHMuXHJcbi8vIGRvdGNzcy51cmwgPSBmdW5jdGlvbih1cmw6IHN0cmluZyk6IHN0cmluZ3tcclxuLy8gXHRyZXR1cm4gYHVybCgnJHt1cmx9JylgO1xyXG4vLyB9O1xyXG4vLyAvL1NwZWNpYWwgaGFuZGxlciBmb3IgYnVpbGRpbmcgcmdiIGNvbG9ycy5cclxuLy8gZG90Y3NzLnJnYiA9IGZ1bmN0aW9uKHI6IG51bWJlciwgZzogbnVtYmVyLCBiOiBudW1iZXIpOiBzdHJpbmd7XHJcbi8vIFx0cmV0dXJuIGByZ2IoJHtyfSwke2d9LCR7Yn0pYDtcclxuLy8gfTtcclxuLy8gLy9TcGVjaWFsIGhhbmRsZXIgZm9yIGJ1aWxkaW5nIHJnYmEgY29sb3JzLlxyXG4vLyBkb3Rjc3MucmdiYSA9IGZ1bmN0aW9uKHI6IG51bWJlciwgZzogbnVtYmVyLCBiOiBudW1iZXIsIGE6IG51bWJlcik6IHN0cmluZ3tcclxuLy8gXHRyZXR1cm4gYHJnYmEoJHtyfSwke2d9LCR7Yn0sJHthfSlgO1xyXG4vLyB9O1xyXG4vLyBXZSBkb24ndCBkbyB0aGlzIGFueW1vcmUuXHJcbi8vIGRvdGNzcy5idWlsZFRyYW5zZm9ybSA9IGZ1bmN0aW9uKCl7XHJcbi8vIFx0cmV0dXJuIG5ldyBkb3Rjc3MyLl9UcmFuc2Zvcm0oKTtcclxuLy8gfTtcclxuZG90Y3NzW1wiY2FjaGVTY29wZWRTdGF0aWNTdHlsZXNcIl0gPSBmdW5jdGlvbiAoZWwpIHtcclxuICAgIGxldCBlbGVtZW50cyA9IGdldFNjb3BlZE5vZGVMaXN0KFwiKlwiLCBlbCk7XHJcbiAgICBmb3IgKGxldCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XHJcbiAgICAgICAgaWYgKGVsZW1lbnQuaGFzQXR0cmlidXRlKFwic3R5bGVcIikpIHtcclxuICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoU1RBVElDX1NZTEVTX0FUVFIsIGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwic3R5bGVcIikpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuZG90Y3NzW1wiY2xlYXJEeW5hbWljU3R5bGVzXCJdID0gZnVuY3Rpb24gKGVsKSB7XHJcbiAgICBsZXQgZWxlbWVudHMgPSBnZXRTY29wZWROb2RlTGlzdChcIipcIiwgZWwpO1xyXG4gICAgZm9yIChsZXQgZWxlbWVudCBvZiBlbGVtZW50cykge1xyXG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwic3R5bGVcIik7XHJcbiAgICAgICAgaWYgKGVsZW1lbnQuaGFzQXR0cmlidXRlKFNUQVRJQ19TWUxFU19BVFRSKSkge1xyXG4gICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIGVsZW1lbnQuZ2V0QXR0cmlidXRlKFNUQVRJQ19TWUxFU19BVFRSKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5kb3Rjc3Muc2NvcGVUb0VsID0gZnVuY3Rpb24gKGVsKSB7XHJcbiAgICBkb3Rjc3MyLnNjb3BlU3RhY2sudW5zaGlmdChlbCk7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuZG90Y3NzLnVuc2NvcGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBkb3Rjc3MyLnNjb3BlU3RhY2suc2hpZnQoKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG4vL0J1aWxkIGRvdGNzcy5cclxuZm9yICh2YXIgayBpbiBfYWxsUHJvcHMpIHtcclxuICAgIGxldCBQID0gX2FsbFByb3BzW2tdLnNwbGl0KFwifFwiKTtcclxuICAgIGZvciAodmFyIGkgaW4gUCkge1xyXG4gICAgICAgIGRvdGNzczIuZXh0ZW5kRG90aHRtbChQW2ldLnRvTG93ZXJDYXNlKCksIFBbaV0ucmVwbGFjZShuZXcgUmVnRXhwKFwiLVwiLCBcImdcIiksIFwiXCIpLCBrKTtcclxuICAgIH1cclxufVxyXG4vLyBmb3IobGV0IGk6IG51bWJlciA9IDA7IGkgPCBfYWxsTGVuZ3RoVW5pdHMubGVuZ3RoOyBpKyspIGRvdGNzczIubWFrZVRyYW5zZm9ybUZ1bmN0aW9uKF9hbGxMZW5ndGhVbml0c1tpXSk7XHJcbi8vZG90Y3NzID0gbmV3IGRvdGNzcygpO1xyXG4vLyBmb3IgKHZhciBrIGluIF9iKSB7XHJcbi8vIFx0aWYoX0J1aWxkZXJba10gPT09IHVuZGVmaW5lZCkgZG90Y3NzW2tdID0gX3Bba107XHJcbi8vIH1cclxuZXhwb3J0cy5kZWZhdWx0ID0gZG90Y3NzO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHlsZS1idWlsZGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==