"use strict";
(self["webpackChunkwedding_website"] = self["webpackChunkwedding_website"] || []).push([["vendors-node_modules_dothtml_lib_styling_css-types_ts_css-filter_js-node_modules_dothtml_lib_-92259a"],{

/***/ "./node_modules/dothtml/lib/styling/css-types.ts/css-filter.js":
/*!*********************************************************************!*\
  !*** ./node_modules/dothtml/lib/styling/css-types.ts/css-filter.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const dot_util_1 = __webpack_require__(/*! ../../dot-util */ "./node_modules/dothtml/lib/dot-util.js");
const css_data_type_1 = __importDefault(__webpack_require__(/*! ./css-data-type */ "./node_modules/dothtml/lib/styling/css-types.ts/css-data-type.js"));
const css_length_1 = __importDefault(__webpack_require__(/*! ./css-length */ "./node_modules/dothtml/lib/styling/css-types.ts/css-length.js"));
const css_percentage_1 = __importDefault(__webpack_require__(/*! ./css-percentage */ "./node_modules/dothtml/lib/styling/css-types.ts/css-percentage.js"));
const css_color_1 = __importDefault(__webpack_require__(/*! ./css-color */ "./node_modules/dothtml/lib/styling/css-types.ts/css-color.js"));
class CssFilter extends css_data_type_1.default {
    constructor(value) {
        super("filter");
        this.filters = [];
        if (typeof value == "string") {
            this.simpleValue = value;
            return; //?? Need a better way to handle this.
        }
        else if ((0, dot_util_1.isF)(value)) {
            value(this);
            // console.log(this.toString());
        }
        //var ret = {value: value, type: cssDataType};
        // The old way of doing transformations was that it was set up to accept a big string. The added complexity was to support animations.
        // The new way is to use the builder. But I might want to come back and revisit the idea of accepting a string.
        // For instance, a use case of accepting a string for a transformation is if we're trying to animate transforms generated by another framework.
        // Not sure if that's realistic.
        // var transformations = value.split(/\)\s*/); transformations.pop(); for(var i = 0; i < transformations.length; i++) transformations[i] += ")";
        // // var cos = Math.cos; var sin = Math.sin; var tan = Math.tan;
        // for(var t = 0; t < transformations.length; t++){
        // 	var trans = transformations[t].trim();
        // 	var parts = trans.split(/[\(\)]/);
        // 	var func = parts[0]
        // 	var p = parts[1].split(/\s*,\s*/)
        // 	if(this[func]){
        // 		this[func].apply(this, p);
        // 	}
        // }
    }
    toString() {
        if (this.simpleValue) {
            return this.simpleValue;
        }
        var ret = "";
        for (var i = 0; i < this.filters.length; i++) {
            var t = this.filters[i];
            ret += t.filter + "(";
            for (var k = 0; k < t.args.length; k++) {
                ret += t.args[k].toString() + " ";
            }
            ret = ret.trim() + ") ";
        }
        return ret.trim();
    }
    appendFilterString(filter, args) {
        //this.finalMatrix = dotcss.matrixMultiply3D(m, this.finalMatrix);
        this.filters.push({ filter: filter, args: args });
        /*if(this.value.length > 0) this.value += " ";
        this.value += transformation + "(";
        for(var i = 0; i < args.length; i++){
            this.value += args[i] + (i == args.length -1 ? "" : ",")
        }*/
        return this;
    }
    blur(v) {
        return this.appendFilterString("blur", [new css_length_1.default(v)]);
    }
    brightness(v) {
        return this.appendFilterString("brightness", [new css_percentage_1.default(v)]);
    }
    contrast(v) {
        return this.appendFilterString("contrast", [new css_percentage_1.default(v)]);
    }
    dropShadow(x, y, blur, color) {
        return this.appendFilterString("drop-shadow", [new css_length_1.default(x), new css_length_1.default(y), new css_length_1.default(blur), new css_color_1.default(color)]);
    }
    grayscale(v) {
        return this.appendFilterString("grayscale", [new css_percentage_1.default(v)]);
    }
    hueRotate(v) {
        return this.appendFilterString("hue-rotate", [new css_percentage_1.default(v)]);
    }
    invert(v) {
        return this.appendFilterString("invert", [new css_percentage_1.default(v)]);
    }
    opacity(v) {
        return this.appendFilterString("opacity", [new css_percentage_1.default(v)]);
    }
    sepia(v) {
        return this.appendFilterString("sepia", [new css_percentage_1.default(v)]);
    }
    saturate(v) {
        return this.appendFilterString("saturate", [new css_percentage_1.default(v)]);
    }
}
exports["default"] = CssFilter;
// Extend the above with special length and degree functions.
// TODO: when I have some time it would be nice to do the unit functions the same way we do for transforms.
// const lengthFuncs = "translate|translate3d|translateX|translateY|translateZ|perspective".split("|");
// const angleFuncs = "rotate|rotateX|rotateY|rotateZ|skew|skewX|skewY".split("|");
// for(let i = 0; i < lengthFuncs.length; i++){
// 	let F = lengthFuncs[i];
// 	for(let u = 0; u < AllLengthUnits.length; u++){
// 		let uu = AllLengthUnits[u];
// 		CssTransform.prototype[F + (uu.jsName || uu.unit)] = function(){
// 			for(var i = 0; i < arguments.length; i++) arguments[i] = arguments[i] + uu.unit.toLowerCase();
// 			return CssTransform.prototype[F].apply(this, arguments);
// 		}
// 	}
// }
// for(let i = 0; i < angleFuncs.length; i++){
// 	let F = angleFuncs[i];
// 	for(let u = 0; u < AllAngleUnits.length; u++){
// 		let uu = AllAngleUnits[u];
// 		CssTransform.prototype[F + (uu.unit)] = function(){
// 			for(var i = 0; i < arguments.length; i++) arguments[i] = arguments[i] + uu.unit.toLowerCase();
// 			return CssTransform.prototype[F].apply(this, arguments);
// 		}
// 	}
// }
//# sourceMappingURL=css-filter.js.map

/***/ }),

/***/ "./node_modules/dothtml/lib/styling/css-types.ts/css-length.js":
/*!*********************************************************************!*\
  !*** ./node_modules/dothtml/lib/styling/css-types.ts/css-length.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const dot_util_1 = __webpack_require__(/*! ../../dot-util */ "./node_modules/dothtml/lib/dot-util.js");
const css_data_type_1 = __importDefault(__webpack_require__(/*! ./css-data-type */ "./node_modules/dothtml/lib/styling/css-types.ts/css-data-type.js"));
//TODO: this should support multiple lengths.
// TODO: add some test cases to test these.
class CssLength extends css_data_type_1.default {
    constructor(value) {
        super("length");
        value = value || "0px";
        if (!isNaN(value))
            value = Math.round(value) + "px";
        this.length = Number(value.match(dot_util_1.floatRegex)[0]);
        this.units = value.split(dot_util_1.floatRegex)[1] || "px";
    }
    toString() {
        return `${this.length}${this.units}`;
    }
}
exports["default"] = CssLength;
//# sourceMappingURL=css-length.js.map

/***/ }),

/***/ "./node_modules/dothtml/lib/styling/css-types.ts/css-number.js":
/*!*********************************************************************!*\
  !*** ./node_modules/dothtml/lib/styling/css-types.ts/css-number.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const css_data_type_1 = __importDefault(__webpack_require__(/*! ./css-data-type */ "./node_modules/dothtml/lib/styling/css-types.ts/css-data-type.js"));
class CssNumber extends css_data_type_1.default {
    constructor(value) {
        super("number");
        this.value = Number(value);
    }
    toString() {
        return this.value;
    }
}
exports["default"] = CssNumber;
//# sourceMappingURL=css-number.js.map

/***/ }),

/***/ "./node_modules/dothtml/lib/styling/css-types.ts/css-percentage.js":
/*!*************************************************************************!*\
  !*** ./node_modules/dothtml/lib/styling/css-types.ts/css-percentage.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const css_length_1 = __importDefault(__webpack_require__(/*! ./css-length */ "./node_modules/dothtml/lib/styling/css-types.ts/css-length.js"));
class CssPercentage extends css_length_1.default {
    constructor(value) {
        super(isNaN(value) ? value : `${value}%`);
    }
}
exports["default"] = CssPercentage;
//# sourceMappingURL=css-percentage.js.map

/***/ }),

/***/ "./node_modules/dothtml/lib/styling/css-types.ts/css-transform.js":
/*!************************************************************************!*\
  !*** ./node_modules/dothtml/lib/styling/css-types.ts/css-transform.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const dot_util_1 = __webpack_require__(/*! ../../dot-util */ "./node_modules/dothtml/lib/dot-util.js");
const unit_function_tables_1 = __webpack_require__(/*! ../unit-function-tables */ "./node_modules/dothtml/lib/styling/unit-function-tables.js");
const css_angle_1 = __importDefault(__webpack_require__(/*! ./css-angle */ "./node_modules/dothtml/lib/styling/css-types.ts/css-angle.js"));
const css_data_type_1 = __importDefault(__webpack_require__(/*! ./css-data-type */ "./node_modules/dothtml/lib/styling/css-types.ts/css-data-type.js"));
const css_length_1 = __importDefault(__webpack_require__(/*! ./css-length */ "./node_modules/dothtml/lib/styling/css-types.ts/css-length.js"));
class CssTransform extends css_data_type_1.default {
    constructor(value) {
        super("transformation");
        this.transformations = [];
        //this.finalMatrix = [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];
        if (typeof value == "string") {
            //this.value = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)";
            this.simpleValue = value;
            return; //?? Need a better way to handle this.
        }
        else if ((0, dot_util_1.isF)(value)) {
            value(this);
        }
        //var ret = {value: value, type: cssDataType};
        // The old way of doing transformations was that it was set up to accept a big string. The added complexity was to support animations.
        // The new way is to use the builder. But I might want to come back and revisit the idea of accepting a string.
        // For instance, a use case of accepting a string for a transformation is if we're trying to animate transforms generated by another framework.
        // Not sure if that's realistic.
        // var transformations = value.split(/\)\s*/); transformations.pop(); for(var i = 0; i < transformations.length; i++) transformations[i] += ")";
        // // var cos = Math.cos; var sin = Math.sin; var tan = Math.tan;
        // for(var t = 0; t < transformations.length; t++){
        // 	var trans = transformations[t].trim();
        // 	var parts = trans.split(/[\(\)]/);
        // 	var func = parts[0]
        // 	var p = parts[1].split(/\s*,\s*/)
        // 	if(this[func]){
        // 		this[func].apply(this, p);
        // 	}
        // }
    }
    toString() {
        if (this.simpleValue) {
            return this.simpleValue;
        }
        var ret = "";
        for (var i = 0; i < this.transformations.length; i++) {
            var t = this.transformations[i];
            ret += t.transformation + "(";
            for (var k = 0; k < t.args.length; k++) {
                ret += t.args[k].toString() + ",";
            }
            ret = ret.substring(0, ret.length - 1);
            ret += ") ";
        }
        return ret.trim();
    }
    appendTransformString(transformation, args) {
        //this.finalMatrix = dotcss.matrixMultiply3D(m, this.finalMatrix);
        this.transformations.push({ transformation: transformation, args: args });
        /*if(this.value.length > 0) this.value += " ";
        this.value += transformation + "(";
        for(var i = 0; i < args.length; i++){
            this.value += args[i] + (i == args.length -1 ? "" : ",")
        }*/
        return this;
    }
    matrix3d(a1, b1, c1, d1, a2, b2, c2, d2, a3, b3, c3, d3, a4, b4, c4, d4) {
        // Why do we need this again?
        // Going to try to remove it to see what breaks. I believe it's used for animations.
        // this.finalMatrix = dotcss.matrixMultiply3D(arguments as unknown as Array<number>, this.finalMatrix);
        return this.appendTransformString("matrix3d", arguments);
    }
    matrix(a, b, c, d, tx, ty) {
        return this.appendTransformString("matrix", arguments);
    }
    translate(x, y) {
        return arguments.length == 1
            ? this.appendTransformString("translate", [new css_length_1.default(x)] /*, [1,0,0,0,0,1,0,0,0,0,1,0,x,0,0,1]*/)
            : this.appendTransformString("translate", [new css_length_1.default(x), new css_length_1.default(y)] /*, [1,0,0,0,0,1,0,0,0,0,1,0,x,y,0,1]*/);
    }
    translate3d(x, y, z) {
        return this.appendTransformString("translate3d", [new css_length_1.default(x), new css_length_1.default(y), new css_length_1.default(z)] /*, [1,0,0,0,0,1,0,0,0,0,1,0,x,y,z,1]*/);
    }
    translateX(x) {
        //var x = dotcss.lengthToPx(p[0]);
        //this.updateValue("translateX", [new CssLength(x + "px")]/*, [1,0,0,0,0,1,0,0,0,0,1,0,x,0,0,1]*/);
        return this.appendTransformString("translateX", [new css_length_1.default(x)]);
    }
    translateY(y) {
        //var y = dotcss.lengthToPx(p[0]);
        //this.updateValue("translateY", [new CssLength(y + "px")]/*, [1,0,0,0,0,1,0,0,0,0,1,0,0,y,0,1]*/);
        return this.appendTransformString("translateY", [new css_length_1.default(y)]);
    }
    translateZ(z) {
        //var z = dotcss.lengthToPx(p[0]);
        //this.updateValue("translateZ", [new CssLength(z + "px")]/*, [1,0,0,0,0,1,0,0,0,0,1,0,0,0,z,1]*/);
        return this.appendTransformString("translateZ", [new css_length_1.default(z)]);
    }
    scale(x, y) {
        return this.appendTransformString("scale", [x, y ?? 1] /*, [x,0,0,0,0,y,0,0,0,0,1,0,0,0,0,1]*/);
    }
    scale3d(x, y, z) {
        return this.appendTransformString("scale3d", [x, y, z] /*, [p[0],0,0,0,0,p[1],0,0,0,0,p[2],0,0,0,0,1]*/);
    }
    scaleX(x) {
        //this.updateValue("scaleX", p/*, [p[0],0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]*/);
        return this.appendTransformString("scaleX", [x]);
    }
    scaleY(y) {
        //this.updateValue("scaleY", p/*, [1,0,0,0,0,p[0],0,0,0,0,1,0,0,0,0,1]*/);
        return this.appendTransformString("scaleY", [y]);
    }
    scaleZ(z) {
        //this.updateValue("scaleZ", p/*, [1,0,0,0,0,1,0,0,0,0,p[0],0,0,0,0,1]*/);
        return this.appendTransformString("scaleZ", [z]);
    }
    rotate(x) {
        // var a = Util.angleToDeg(x);
        return this.appendTransformString("rotate", [new css_angle_1.default(x)] /*, [Math.cos(a),Math.sin(a),0,0,-Math.sin(axxx),Math.cos(axxx),0,0,0,0,1,0,0,0,0,1]*/);
    }
    rotate3d(x, y, z, a) {
        return this.appendTransformString("rotate3d", [x, y, z, new css_angle_1.default(a)] /*,
            [1+C*(x*x-1),	z*S+x*y*C,		-y*S+x*z*C,		0,
            -z*S+x*y*C,		1+C*(y*y-1),	x*S+y*z*C,		0,
            y*S+x*z*C,		-x*S+y*z*C,		1+C*(z*z-1),	0,
            0,				0,				0,				1]*/);
    }
    // Manually create the 4 unit functions for rotate 3d since the arg structure is mixed.
    rotate3dDeg(x, y, z, a) { return this.rotate3d(x, y, z, a); }
    rotate3dRad(x, y, z, a) { return this.rotate3d(x, y, z, `${a}rad`); }
    rotate3dGrad(x, y, z, a) { return this.rotate3d(x, y, z, `${a}grad`); }
    rotate3dTurn(x, y, z, a) { return this.rotate3d(x, y, z, `${a}turn`); }
    rotateX(x) {
        return this.appendTransformString("rotateX", [new css_angle_1.default(x)] /*, [1,0,0,0,0,Math.cos(axx),Math.sin(axx),0,0,-Math.sin(axx),Math.cos(axx),0,0,0,0,1]*/);
    }
    rotateY(y) {
        return this.appendTransformString("rotateY", [new css_angle_1.default(y)]);
    }
    rotateZ(z) {
        return this.appendTransformString("rotateZ", [new css_angle_1.default(z)]);
    }
    skew(x, y) {
        return arguments.length == 1
            ? this.appendTransformString("skew", [new css_angle_1.default(x)] /*, [1,0,0,0,Math.tan(axxxxx),1,0,0,0,0,1,0,0,0,0,1]*/)
            : this.appendTransformString("skew", [new css_angle_1.default(x), new css_angle_1.default(y)] /*, [1,Math.tan(axxxy),0,0,Math.tan(axxxx),1,0,0,0,0,1,0,0,0,0,1]*/);
    }
    skewX(x) {
        return this.appendTransformString("skewX", [new css_angle_1.default(x)]);
    }
    skewY(y) {
        return this.appendTransformString("skewY", [new css_angle_1.default(y)]);
    }
    perspective(d) {
        return this.appendTransformString("perspective", [new css_length_1.default(d)] /*, [1,0,0,0,0,1,0,0,0,0,1,0,0,0,dotcss.formatNumberValue(-1 / d),1]*/);
    }
}
exports["default"] = CssTransform;
// Extend the above with special length and degree functions.
const lengthFuncs = "translate|translate3d|translateX|translateY|translateZ|perspective".split("|");
const angleFuncs = "rotate|rotateX|rotateY|rotateZ|skew|skewX|skewY".split("|");
for (let i = 0; i < lengthFuncs.length; i++) {
    let F = lengthFuncs[i];
    for (let u = 0; u < unit_function_tables_1.AllLengthUnits.length; u++) {
        let uu = unit_function_tables_1.AllLengthUnits[u];
        CssTransform.prototype[F + (uu.jsName || uu.unit)] = function () {
            for (var i = 0; i < arguments.length; i++)
                arguments[i] = arguments[i] + uu.unit.toLowerCase();
            return CssTransform.prototype[F].apply(this, arguments);
        };
    }
}
for (let i = 0; i < angleFuncs.length; i++) {
    let F = angleFuncs[i];
    for (let u = 0; u < unit_function_tables_1.AllAngleUnits.length; u++) {
        let uu = unit_function_tables_1.AllAngleUnits[u];
        CssTransform.prototype[F + (uu.unit)] = function () {
            for (var i = 0; i < arguments.length; i++)
                arguments[i] = arguments[i] + uu.unit.toLowerCase();
            return CssTransform.prototype[F].apply(this, arguments);
        };
    }
}
//# sourceMappingURL=css-transform.js.map

/***/ }),

/***/ "./node_modules/dothtml/lib/styling/css-types.ts/css-unknown.js":
/*!**********************************************************************!*\
  !*** ./node_modules/dothtml/lib/styling/css-types.ts/css-unknown.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const css_data_type_1 = __importDefault(__webpack_require__(/*! ./css-data-type */ "./node_modules/dothtml/lib/styling/css-types.ts/css-data-type.js"));
class CssUnknown extends css_data_type_1.default {
    constructor(value) {
        super("unknown");
        this.value = value;
    }
    toString() {
        return this.value;
    }
}
exports["default"] = CssUnknown;
//# sourceMappingURL=css-unknown.js.map

/***/ }),

/***/ "./node_modules/dothtml/lib/styling/css-types.ts/css-url.js":
/*!******************************************************************!*\
  !*** ./node_modules/dothtml/lib/styling/css-types.ts/css-url.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const css_data_type_1 = __importDefault(__webpack_require__(/*! ./css-data-type */ "./node_modules/dothtml/lib/styling/css-types.ts/css-data-type.js"));
class CssUrl extends css_data_type_1.default {
    constructor(value) {
        super("url");
        this.url = null;
        if (!value || value.length == 0 || (value.length == 1 && value[0] == "" || value[0] == "none" || value[0] == "initial" || value[0] == "inherit")) {
            this.url = null;
        }
        else {
            this.url = [];
            for (var i = 0; i < value.length; i++) {
                var currentURL = "";
                if (value[i].toLowerCase().indexOf("url") === 0) {
                    var url = value[i].substring(value[i].indexOf("("), value[i].lastIndexOf(")")).trim();
                    if ((url.indexOf("\"") && url.lastIndexOf("\"") == url.length - 1) ||
                        (url.indexOf("'") && url.lastIndexOf("'") == url.length - 1)) {
                        url = url.substring(1, url.length - 1);
                    }
                    this.url.push(url);
                }
                else {
                    this.url.push(value[i]);
                }
            }
        }
    }
    toString() {
        if (!this.url)
            return "none";
        else {
            var ret = [];
            for (var i = 0; i < this.url.length; i++) {
                ret.push("url(\"" + this.url[i] + "\")");
            }
            return ret.join(", ");
        }
    }
}
exports["default"] = CssUrl;
//# sourceMappingURL=css-url.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfZG90aHRtbF9saWJfc3R5bGluZ19jc3MtdHlwZXNfdHNfY3NzLWZpbHRlcl9qcy1ub2RlX21vZHVsZXNfZG90aHRtbF9saWJfLTkyMjU5YS42ZjA3Yzk0ZmRlODQwMzExOWNmMC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQixtQkFBTyxDQUFDLDhEQUFnQjtBQUMzQyx3Q0FBd0MsbUJBQU8sQ0FBQyx5RkFBaUI7QUFDakUscUNBQXFDLG1CQUFPLENBQUMsbUZBQWM7QUFDM0QseUNBQXlDLG1CQUFPLENBQUMsMkZBQWtCO0FBQ25FLG9DQUFvQyxtQkFBTyxDQUFDLGlGQUFhO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELHVCQUF1QixlQUFlLDRCQUE0QjtBQUN6SCxrQ0FBa0Msb0JBQW9CO0FBQ3RELDBCQUEwQiw0QkFBNEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQ7QUFDQTtBQUNBLDRCQUE0QixtQkFBbUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw0QkFBNEI7QUFDeEQ7QUFDQTtBQUNBLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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d2VicGFjazovL3dlZGRpbmctd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9kb3RodG1sL2xpYi9zdHlsaW5nL2Nzcy10eXBlcy50cy9jc3MtZmlsdGVyLmpzIiwid2VicGFjazovL3dlZGRpbmctd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9kb3RodG1sL2xpYi9zdHlsaW5nL2Nzcy10eXBlcy50cy9jc3MtbGVuZ3RoLmpzIiwid2VicGFjazovL3dlZGRpbmctd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9kb3RodG1sL2xpYi9zdHlsaW5nL2Nzcy10eXBlcy50cy9jc3MtbnVtYmVyLmpzIiwid2VicGFjazovL3dlZGRpbmctd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9kb3RodG1sL2xpYi9zdHlsaW5nL2Nzcy10eXBlcy50cy9jc3MtcGVyY2VudGFnZS5qcyIsIndlYnBhY2s6Ly93ZWRkaW5nLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZG90aHRtbC9saWIvc3R5bGluZy9jc3MtdHlwZXMudHMvY3NzLXRyYW5zZm9ybS5qcyIsIndlYnBhY2s6Ly93ZWRkaW5nLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZG90aHRtbC9saWIvc3R5bGluZy9jc3MtdHlwZXMudHMvY3NzLXVua25vd24uanMiLCJ3ZWJwYWNrOi8vd2VkZGluZy13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2RvdGh0bWwvbGliL3N0eWxpbmcvY3NzLXR5cGVzLnRzL2Nzcy11cmwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgZG90X3V0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9kb3QtdXRpbFwiKTtcclxuY29uc3QgY3NzX2RhdGFfdHlwZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2Nzcy1kYXRhLXR5cGVcIikpO1xyXG5jb25zdCBjc3NfbGVuZ3RoXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vY3NzLWxlbmd0aFwiKSk7XHJcbmNvbnN0IGNzc19wZXJjZW50YWdlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vY3NzLXBlcmNlbnRhZ2VcIikpO1xyXG5jb25zdCBjc3NfY29sb3JfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9jc3MtY29sb3JcIikpO1xyXG5jbGFzcyBDc3NGaWx0ZXIgZXh0ZW5kcyBjc3NfZGF0YV90eXBlXzEuZGVmYXVsdCB7XHJcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xyXG4gICAgICAgIHN1cGVyKFwiZmlsdGVyXCIpO1xyXG4gICAgICAgIHRoaXMuZmlsdGVycyA9IFtdO1xyXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICB0aGlzLnNpbXBsZVZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHJldHVybjsgLy8/PyBOZWVkIGEgYmV0dGVyIHdheSB0byBoYW5kbGUgdGhpcy5cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoKDAsIGRvdF91dGlsXzEuaXNGKSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgdmFsdWUodGhpcyk7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vdmFyIHJldCA9IHt2YWx1ZTogdmFsdWUsIHR5cGU6IGNzc0RhdGFUeXBlfTtcclxuICAgICAgICAvLyBUaGUgb2xkIHdheSBvZiBkb2luZyB0cmFuc2Zvcm1hdGlvbnMgd2FzIHRoYXQgaXQgd2FzIHNldCB1cCB0byBhY2NlcHQgYSBiaWcgc3RyaW5nLiBUaGUgYWRkZWQgY29tcGxleGl0eSB3YXMgdG8gc3VwcG9ydCBhbmltYXRpb25zLlxyXG4gICAgICAgIC8vIFRoZSBuZXcgd2F5IGlzIHRvIHVzZSB0aGUgYnVpbGRlci4gQnV0IEkgbWlnaHQgd2FudCB0byBjb21lIGJhY2sgYW5kIHJldmlzaXQgdGhlIGlkZWEgb2YgYWNjZXB0aW5nIGEgc3RyaW5nLlxyXG4gICAgICAgIC8vIEZvciBpbnN0YW5jZSwgYSB1c2UgY2FzZSBvZiBhY2NlcHRpbmcgYSBzdHJpbmcgZm9yIGEgdHJhbnNmb3JtYXRpb24gaXMgaWYgd2UncmUgdHJ5aW5nIHRvIGFuaW1hdGUgdHJhbnNmb3JtcyBnZW5lcmF0ZWQgYnkgYW5vdGhlciBmcmFtZXdvcmsuXHJcbiAgICAgICAgLy8gTm90IHN1cmUgaWYgdGhhdCdzIHJlYWxpc3RpYy5cclxuICAgICAgICAvLyB2YXIgdHJhbnNmb3JtYXRpb25zID0gdmFsdWUuc3BsaXQoL1xcKVxccyovKTsgdHJhbnNmb3JtYXRpb25zLnBvcCgpOyBmb3IodmFyIGkgPSAwOyBpIDwgdHJhbnNmb3JtYXRpb25zLmxlbmd0aDsgaSsrKSB0cmFuc2Zvcm1hdGlvbnNbaV0gKz0gXCIpXCI7XHJcbiAgICAgICAgLy8gLy8gdmFyIGNvcyA9IE1hdGguY29zOyB2YXIgc2luID0gTWF0aC5zaW47IHZhciB0YW4gPSBNYXRoLnRhbjtcclxuICAgICAgICAvLyBmb3IodmFyIHQgPSAwOyB0IDwgdHJhbnNmb3JtYXRpb25zLmxlbmd0aDsgdCsrKXtcclxuICAgICAgICAvLyBcdHZhciB0cmFucyA9IHRyYW5zZm9ybWF0aW9uc1t0XS50cmltKCk7XHJcbiAgICAgICAgLy8gXHR2YXIgcGFydHMgPSB0cmFucy5zcGxpdCgvW1xcKFxcKV0vKTtcclxuICAgICAgICAvLyBcdHZhciBmdW5jID0gcGFydHNbMF1cclxuICAgICAgICAvLyBcdHZhciBwID0gcGFydHNbMV0uc3BsaXQoL1xccyosXFxzKi8pXHJcbiAgICAgICAgLy8gXHRpZih0aGlzW2Z1bmNdKXtcclxuICAgICAgICAvLyBcdFx0dGhpc1tmdW5jXS5hcHBseSh0aGlzLCBwKTtcclxuICAgICAgICAvLyBcdH1cclxuICAgICAgICAvLyB9XHJcbiAgICB9XHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICBpZiAodGhpcy5zaW1wbGVWYWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zaW1wbGVWYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJldCA9IFwiXCI7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmZpbHRlcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHQgPSB0aGlzLmZpbHRlcnNbaV07XHJcbiAgICAgICAgICAgIHJldCArPSB0LmZpbHRlciArIFwiKFwiO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHQuYXJncy5sZW5ndGg7IGsrKykge1xyXG4gICAgICAgICAgICAgICAgcmV0ICs9IHQuYXJnc1trXS50b1N0cmluZygpICsgXCIgXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0ID0gcmV0LnRyaW0oKSArIFwiKSBcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJldC50cmltKCk7XHJcbiAgICB9XHJcbiAgICBhcHBlbmRGaWx0ZXJTdHJpbmcoZmlsdGVyLCBhcmdzKSB7XHJcbiAgICAgICAgLy90aGlzLmZpbmFsTWF0cml4ID0gZG90Y3NzLm1hdHJpeE11bHRpcGx5M0QobSwgdGhpcy5maW5hbE1hdHJpeCk7XHJcbiAgICAgICAgdGhpcy5maWx0ZXJzLnB1c2goeyBmaWx0ZXI6IGZpbHRlciwgYXJnczogYXJncyB9KTtcclxuICAgICAgICAvKmlmKHRoaXMudmFsdWUubGVuZ3RoID4gMCkgdGhpcy52YWx1ZSArPSBcIiBcIjtcclxuICAgICAgICB0aGlzLnZhbHVlICs9IHRyYW5zZm9ybWF0aW9uICsgXCIoXCI7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlICs9IGFyZ3NbaV0gKyAoaSA9PSBhcmdzLmxlbmd0aCAtMSA/IFwiXCIgOiBcIixcIilcclxuICAgICAgICB9Ki9cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIGJsdXIodikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFwcGVuZEZpbHRlclN0cmluZyhcImJsdXJcIiwgW25ldyBjc3NfbGVuZ3RoXzEuZGVmYXVsdCh2KV0pO1xyXG4gICAgfVxyXG4gICAgYnJpZ2h0bmVzcyh2KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwZW5kRmlsdGVyU3RyaW5nKFwiYnJpZ2h0bmVzc1wiLCBbbmV3IGNzc19wZXJjZW50YWdlXzEuZGVmYXVsdCh2KV0pO1xyXG4gICAgfVxyXG4gICAgY29udHJhc3Qodikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFwcGVuZEZpbHRlclN0cmluZyhcImNvbnRyYXN0XCIsIFtuZXcgY3NzX3BlcmNlbnRhZ2VfMS5kZWZhdWx0KHYpXSk7XHJcbiAgICB9XHJcbiAgICBkcm9wU2hhZG93KHgsIHksIGJsdXIsIGNvbG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwZW5kRmlsdGVyU3RyaW5nKFwiZHJvcC1zaGFkb3dcIiwgW25ldyBjc3NfbGVuZ3RoXzEuZGVmYXVsdCh4KSwgbmV3IGNzc19sZW5ndGhfMS5kZWZhdWx0KHkpLCBuZXcgY3NzX2xlbmd0aF8xLmRlZmF1bHQoYmx1ciksIG5ldyBjc3NfY29sb3JfMS5kZWZhdWx0KGNvbG9yKV0pO1xyXG4gICAgfVxyXG4gICAgZ3JheXNjYWxlKHYpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hcHBlbmRGaWx0ZXJTdHJpbmcoXCJncmF5c2NhbGVcIiwgW25ldyBjc3NfcGVyY2VudGFnZV8xLmRlZmF1bHQodildKTtcclxuICAgIH1cclxuICAgIGh1ZVJvdGF0ZSh2KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwZW5kRmlsdGVyU3RyaW5nKFwiaHVlLXJvdGF0ZVwiLCBbbmV3IGNzc19wZXJjZW50YWdlXzEuZGVmYXVsdCh2KV0pO1xyXG4gICAgfVxyXG4gICAgaW52ZXJ0KHYpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hcHBlbmRGaWx0ZXJTdHJpbmcoXCJpbnZlcnRcIiwgW25ldyBjc3NfcGVyY2VudGFnZV8xLmRlZmF1bHQodildKTtcclxuICAgIH1cclxuICAgIG9wYWNpdHkodikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFwcGVuZEZpbHRlclN0cmluZyhcIm9wYWNpdHlcIiwgW25ldyBjc3NfcGVyY2VudGFnZV8xLmRlZmF1bHQodildKTtcclxuICAgIH1cclxuICAgIHNlcGlhKHYpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hcHBlbmRGaWx0ZXJTdHJpbmcoXCJzZXBpYVwiLCBbbmV3IGNzc19wZXJjZW50YWdlXzEuZGVmYXVsdCh2KV0pO1xyXG4gICAgfVxyXG4gICAgc2F0dXJhdGUodikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFwcGVuZEZpbHRlclN0cmluZyhcInNhdHVyYXRlXCIsIFtuZXcgY3NzX3BlcmNlbnRhZ2VfMS5kZWZhdWx0KHYpXSk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5kZWZhdWx0ID0gQ3NzRmlsdGVyO1xyXG4vLyBFeHRlbmQgdGhlIGFib3ZlIHdpdGggc3BlY2lhbCBsZW5ndGggYW5kIGRlZ3JlZSBmdW5jdGlvbnMuXHJcbi8vIFRPRE86IHdoZW4gSSBoYXZlIHNvbWUgdGltZSBpdCB3b3VsZCBiZSBuaWNlIHRvIGRvIHRoZSB1bml0IGZ1bmN0aW9ucyB0aGUgc2FtZSB3YXkgd2UgZG8gZm9yIHRyYW5zZm9ybXMuXHJcbi8vIGNvbnN0IGxlbmd0aEZ1bmNzID0gXCJ0cmFuc2xhdGV8dHJhbnNsYXRlM2R8dHJhbnNsYXRlWHx0cmFuc2xhdGVZfHRyYW5zbGF0ZVp8cGVyc3BlY3RpdmVcIi5zcGxpdChcInxcIik7XHJcbi8vIGNvbnN0IGFuZ2xlRnVuY3MgPSBcInJvdGF0ZXxyb3RhdGVYfHJvdGF0ZVl8cm90YXRlWnxza2V3fHNrZXdYfHNrZXdZXCIuc3BsaXQoXCJ8XCIpO1xyXG4vLyBmb3IobGV0IGkgPSAwOyBpIDwgbGVuZ3RoRnVuY3MubGVuZ3RoOyBpKyspe1xyXG4vLyBcdGxldCBGID0gbGVuZ3RoRnVuY3NbaV07XHJcbi8vIFx0Zm9yKGxldCB1ID0gMDsgdSA8IEFsbExlbmd0aFVuaXRzLmxlbmd0aDsgdSsrKXtcclxuLy8gXHRcdGxldCB1dSA9IEFsbExlbmd0aFVuaXRzW3VdO1xyXG4vLyBcdFx0Q3NzVHJhbnNmb3JtLnByb3RvdHlwZVtGICsgKHV1LmpzTmFtZSB8fCB1dS51bml0KV0gPSBmdW5jdGlvbigpe1xyXG4vLyBcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSBhcmd1bWVudHNbaV0gPSBhcmd1bWVudHNbaV0gKyB1dS51bml0LnRvTG93ZXJDYXNlKCk7XHJcbi8vIFx0XHRcdHJldHVybiBDc3NUcmFuc2Zvcm0ucHJvdG90eXBlW0ZdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbi8vIFx0XHR9XHJcbi8vIFx0fVxyXG4vLyB9XHJcbi8vIGZvcihsZXQgaSA9IDA7IGkgPCBhbmdsZUZ1bmNzLmxlbmd0aDsgaSsrKXtcclxuLy8gXHRsZXQgRiA9IGFuZ2xlRnVuY3NbaV07XHJcbi8vIFx0Zm9yKGxldCB1ID0gMDsgdSA8IEFsbEFuZ2xlVW5pdHMubGVuZ3RoOyB1Kyspe1xyXG4vLyBcdFx0bGV0IHV1ID0gQWxsQW5nbGVVbml0c1t1XTtcclxuLy8gXHRcdENzc1RyYW5zZm9ybS5wcm90b3R5cGVbRiArICh1dS51bml0KV0gPSBmdW5jdGlvbigpe1xyXG4vLyBcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSBhcmd1bWVudHNbaV0gPSBhcmd1bWVudHNbaV0gKyB1dS51bml0LnRvTG93ZXJDYXNlKCk7XHJcbi8vIFx0XHRcdHJldHVybiBDc3NUcmFuc2Zvcm0ucHJvdG90eXBlW0ZdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbi8vIFx0XHR9XHJcbi8vIFx0fVxyXG4vLyB9XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNzcy1maWx0ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgZG90X3V0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9kb3QtdXRpbFwiKTtcclxuY29uc3QgY3NzX2RhdGFfdHlwZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2Nzcy1kYXRhLXR5cGVcIikpO1xyXG4vL1RPRE86IHRoaXMgc2hvdWxkIHN1cHBvcnQgbXVsdGlwbGUgbGVuZ3Rocy5cclxuLy8gVE9ETzogYWRkIHNvbWUgdGVzdCBjYXNlcyB0byB0ZXN0IHRoZXNlLlxyXG5jbGFzcyBDc3NMZW5ndGggZXh0ZW5kcyBjc3NfZGF0YV90eXBlXzEuZGVmYXVsdCB7XHJcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xyXG4gICAgICAgIHN1cGVyKFwibGVuZ3RoXCIpO1xyXG4gICAgICAgIHZhbHVlID0gdmFsdWUgfHwgXCIwcHhcIjtcclxuICAgICAgICBpZiAoIWlzTmFOKHZhbHVlKSlcclxuICAgICAgICAgICAgdmFsdWUgPSBNYXRoLnJvdW5kKHZhbHVlKSArIFwicHhcIjtcclxuICAgICAgICB0aGlzLmxlbmd0aCA9IE51bWJlcih2YWx1ZS5tYXRjaChkb3RfdXRpbF8xLmZsb2F0UmVnZXgpWzBdKTtcclxuICAgICAgICB0aGlzLnVuaXRzID0gdmFsdWUuc3BsaXQoZG90X3V0aWxfMS5mbG9hdFJlZ2V4KVsxXSB8fCBcInB4XCI7XHJcbiAgICB9XHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gYCR7dGhpcy5sZW5ndGh9JHt0aGlzLnVuaXRzfWA7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5kZWZhdWx0ID0gQ3NzTGVuZ3RoO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jc3MtbGVuZ3RoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IGNzc19kYXRhX3R5cGVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9jc3MtZGF0YS10eXBlXCIpKTtcclxuY2xhc3MgQ3NzTnVtYmVyIGV4dGVuZHMgY3NzX2RhdGFfdHlwZV8xLmRlZmF1bHQge1xyXG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcclxuICAgICAgICBzdXBlcihcIm51bWJlclwiKTtcclxuICAgICAgICB0aGlzLnZhbHVlID0gTnVtYmVyKHZhbHVlKTtcclxuICAgIH1cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuZGVmYXVsdCA9IENzc051bWJlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3NzLW51bWJlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBjc3NfbGVuZ3RoXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vY3NzLWxlbmd0aFwiKSk7XHJcbmNsYXNzIENzc1BlcmNlbnRhZ2UgZXh0ZW5kcyBjc3NfbGVuZ3RoXzEuZGVmYXVsdCB7XHJcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xyXG4gICAgICAgIHN1cGVyKGlzTmFOKHZhbHVlKSA/IHZhbHVlIDogYCR7dmFsdWV9JWApO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuZGVmYXVsdCA9IENzc1BlcmNlbnRhZ2U7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNzcy1wZXJjZW50YWdlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IGRvdF91dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vZG90LXV0aWxcIik7XHJcbmNvbnN0IHVuaXRfZnVuY3Rpb25fdGFibGVzXzEgPSByZXF1aXJlKFwiLi4vdW5pdC1mdW5jdGlvbi10YWJsZXNcIik7XHJcbmNvbnN0IGNzc19hbmdsZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2Nzcy1hbmdsZVwiKSk7XHJcbmNvbnN0IGNzc19kYXRhX3R5cGVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9jc3MtZGF0YS10eXBlXCIpKTtcclxuY29uc3QgY3NzX2xlbmd0aF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2Nzcy1sZW5ndGhcIikpO1xyXG5jbGFzcyBDc3NUcmFuc2Zvcm0gZXh0ZW5kcyBjc3NfZGF0YV90eXBlXzEuZGVmYXVsdCB7XHJcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xyXG4gICAgICAgIHN1cGVyKFwidHJhbnNmb3JtYXRpb25cIik7XHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1hdGlvbnMgPSBbXTtcclxuICAgICAgICAvL3RoaXMuZmluYWxNYXRyaXggPSBbMSwwLDAsMCwwLDEsMCwwLDAsMCwxLDAsMCwwLDAsMV07XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgIC8vdGhpcy52YWx1ZSA9IFwibWF0cml4M2QoMSwwLDAsMCwwLDEsMCwwLDAsMCwxLDAsMCwwLDAsMSlcIjtcclxuICAgICAgICAgICAgdGhpcy5zaW1wbGVWYWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICByZXR1cm47IC8vPz8gTmVlZCBhIGJldHRlciB3YXkgdG8gaGFuZGxlIHRoaXMuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCgwLCBkb3RfdXRpbF8xLmlzRikodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHZhbHVlKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL3ZhciByZXQgPSB7dmFsdWU6IHZhbHVlLCB0eXBlOiBjc3NEYXRhVHlwZX07XHJcbiAgICAgICAgLy8gVGhlIG9sZCB3YXkgb2YgZG9pbmcgdHJhbnNmb3JtYXRpb25zIHdhcyB0aGF0IGl0IHdhcyBzZXQgdXAgdG8gYWNjZXB0IGEgYmlnIHN0cmluZy4gVGhlIGFkZGVkIGNvbXBsZXhpdHkgd2FzIHRvIHN1cHBvcnQgYW5pbWF0aW9ucy5cclxuICAgICAgICAvLyBUaGUgbmV3IHdheSBpcyB0byB1c2UgdGhlIGJ1aWxkZXIuIEJ1dCBJIG1pZ2h0IHdhbnQgdG8gY29tZSBiYWNrIGFuZCByZXZpc2l0IHRoZSBpZGVhIG9mIGFjY2VwdGluZyBhIHN0cmluZy5cclxuICAgICAgICAvLyBGb3IgaW5zdGFuY2UsIGEgdXNlIGNhc2Ugb2YgYWNjZXB0aW5nIGEgc3RyaW5nIGZvciBhIHRyYW5zZm9ybWF0aW9uIGlzIGlmIHdlJ3JlIHRyeWluZyB0byBhbmltYXRlIHRyYW5zZm9ybXMgZ2VuZXJhdGVkIGJ5IGFub3RoZXIgZnJhbWV3b3JrLlxyXG4gICAgICAgIC8vIE5vdCBzdXJlIGlmIHRoYXQncyByZWFsaXN0aWMuXHJcbiAgICAgICAgLy8gdmFyIHRyYW5zZm9ybWF0aW9ucyA9IHZhbHVlLnNwbGl0KC9cXClcXHMqLyk7IHRyYW5zZm9ybWF0aW9ucy5wb3AoKTsgZm9yKHZhciBpID0gMDsgaSA8IHRyYW5zZm9ybWF0aW9ucy5sZW5ndGg7IGkrKykgdHJhbnNmb3JtYXRpb25zW2ldICs9IFwiKVwiO1xyXG4gICAgICAgIC8vIC8vIHZhciBjb3MgPSBNYXRoLmNvczsgdmFyIHNpbiA9IE1hdGguc2luOyB2YXIgdGFuID0gTWF0aC50YW47XHJcbiAgICAgICAgLy8gZm9yKHZhciB0ID0gMDsgdCA8IHRyYW5zZm9ybWF0aW9ucy5sZW5ndGg7IHQrKyl7XHJcbiAgICAgICAgLy8gXHR2YXIgdHJhbnMgPSB0cmFuc2Zvcm1hdGlvbnNbdF0udHJpbSgpO1xyXG4gICAgICAgIC8vIFx0dmFyIHBhcnRzID0gdHJhbnMuc3BsaXQoL1tcXChcXCldLyk7XHJcbiAgICAgICAgLy8gXHR2YXIgZnVuYyA9IHBhcnRzWzBdXHJcbiAgICAgICAgLy8gXHR2YXIgcCA9IHBhcnRzWzFdLnNwbGl0KC9cXHMqLFxccyovKVxyXG4gICAgICAgIC8vIFx0aWYodGhpc1tmdW5jXSl7XHJcbiAgICAgICAgLy8gXHRcdHRoaXNbZnVuY10uYXBwbHkodGhpcywgcCk7XHJcbiAgICAgICAgLy8gXHR9XHJcbiAgICAgICAgLy8gfVxyXG4gICAgfVxyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc2ltcGxlVmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2ltcGxlVmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByZXQgPSBcIlwiO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy50cmFuc2Zvcm1hdGlvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHQgPSB0aGlzLnRyYW5zZm9ybWF0aW9uc1tpXTtcclxuICAgICAgICAgICAgcmV0ICs9IHQudHJhbnNmb3JtYXRpb24gKyBcIihcIjtcclxuICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCB0LmFyZ3MubGVuZ3RoOyBrKyspIHtcclxuICAgICAgICAgICAgICAgIHJldCArPSB0LmFyZ3Nba10udG9TdHJpbmcoKSArIFwiLFwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldCA9IHJldC5zdWJzdHJpbmcoMCwgcmV0Lmxlbmd0aCAtIDEpO1xyXG4gICAgICAgICAgICByZXQgKz0gXCIpIFwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmV0LnRyaW0oKTtcclxuICAgIH1cclxuICAgIGFwcGVuZFRyYW5zZm9ybVN0cmluZyh0cmFuc2Zvcm1hdGlvbiwgYXJncykge1xyXG4gICAgICAgIC8vdGhpcy5maW5hbE1hdHJpeCA9IGRvdGNzcy5tYXRyaXhNdWx0aXBseTNEKG0sIHRoaXMuZmluYWxNYXRyaXgpO1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtYXRpb25zLnB1c2goeyB0cmFuc2Zvcm1hdGlvbjogdHJhbnNmb3JtYXRpb24sIGFyZ3M6IGFyZ3MgfSk7XHJcbiAgICAgICAgLyppZih0aGlzLnZhbHVlLmxlbmd0aCA+IDApIHRoaXMudmFsdWUgKz0gXCIgXCI7XHJcbiAgICAgICAgdGhpcy52YWx1ZSArPSB0cmFuc2Zvcm1hdGlvbiArIFwiKFwiO1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKXtcclxuICAgICAgICAgICAgdGhpcy52YWx1ZSArPSBhcmdzW2ldICsgKGkgPT0gYXJncy5sZW5ndGggLTEgPyBcIlwiIDogXCIsXCIpXHJcbiAgICAgICAgfSovXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBtYXRyaXgzZChhMSwgYjEsIGMxLCBkMSwgYTIsIGIyLCBjMiwgZDIsIGEzLCBiMywgYzMsIGQzLCBhNCwgYjQsIGM0LCBkNCkge1xyXG4gICAgICAgIC8vIFdoeSBkbyB3ZSBuZWVkIHRoaXMgYWdhaW4/XHJcbiAgICAgICAgLy8gR29pbmcgdG8gdHJ5IHRvIHJlbW92ZSBpdCB0byBzZWUgd2hhdCBicmVha3MuIEkgYmVsaWV2ZSBpdCdzIHVzZWQgZm9yIGFuaW1hdGlvbnMuXHJcbiAgICAgICAgLy8gdGhpcy5maW5hbE1hdHJpeCA9IGRvdGNzcy5tYXRyaXhNdWx0aXBseTNEKGFyZ3VtZW50cyBhcyB1bmtub3duIGFzIEFycmF5PG51bWJlcj4sIHRoaXMuZmluYWxNYXRyaXgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFwcGVuZFRyYW5zZm9ybVN0cmluZyhcIm1hdHJpeDNkXCIsIGFyZ3VtZW50cyk7XHJcbiAgICB9XHJcbiAgICBtYXRyaXgoYSwgYiwgYywgZCwgdHgsIHR5KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwZW5kVHJhbnNmb3JtU3RyaW5nKFwibWF0cml4XCIsIGFyZ3VtZW50cyk7XHJcbiAgICB9XHJcbiAgICB0cmFuc2xhdGUoeCwgeSkge1xyXG4gICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09IDFcclxuICAgICAgICAgICAgPyB0aGlzLmFwcGVuZFRyYW5zZm9ybVN0cmluZyhcInRyYW5zbGF0ZVwiLCBbbmV3IGNzc19sZW5ndGhfMS5kZWZhdWx0KHgpXSAvKiwgWzEsMCwwLDAsMCwxLDAsMCwwLDAsMSwwLHgsMCwwLDFdKi8pXHJcbiAgICAgICAgICAgIDogdGhpcy5hcHBlbmRUcmFuc2Zvcm1TdHJpbmcoXCJ0cmFuc2xhdGVcIiwgW25ldyBjc3NfbGVuZ3RoXzEuZGVmYXVsdCh4KSwgbmV3IGNzc19sZW5ndGhfMS5kZWZhdWx0KHkpXSAvKiwgWzEsMCwwLDAsMCwxLDAsMCwwLDAsMSwwLHgseSwwLDFdKi8pO1xyXG4gICAgfVxyXG4gICAgdHJhbnNsYXRlM2QoeCwgeSwgeikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFwcGVuZFRyYW5zZm9ybVN0cmluZyhcInRyYW5zbGF0ZTNkXCIsIFtuZXcgY3NzX2xlbmd0aF8xLmRlZmF1bHQoeCksIG5ldyBjc3NfbGVuZ3RoXzEuZGVmYXVsdCh5KSwgbmV3IGNzc19sZW5ndGhfMS5kZWZhdWx0KHopXSAvKiwgWzEsMCwwLDAsMCwxLDAsMCwwLDAsMSwwLHgseSx6LDFdKi8pO1xyXG4gICAgfVxyXG4gICAgdHJhbnNsYXRlWCh4KSB7XHJcbiAgICAgICAgLy92YXIgeCA9IGRvdGNzcy5sZW5ndGhUb1B4KHBbMF0pO1xyXG4gICAgICAgIC8vdGhpcy51cGRhdGVWYWx1ZShcInRyYW5zbGF0ZVhcIiwgW25ldyBDc3NMZW5ndGgoeCArIFwicHhcIildLyosIFsxLDAsMCwwLDAsMSwwLDAsMCwwLDEsMCx4LDAsMCwxXSovKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5hcHBlbmRUcmFuc2Zvcm1TdHJpbmcoXCJ0cmFuc2xhdGVYXCIsIFtuZXcgY3NzX2xlbmd0aF8xLmRlZmF1bHQoeCldKTtcclxuICAgIH1cclxuICAgIHRyYW5zbGF0ZVkoeSkge1xyXG4gICAgICAgIC8vdmFyIHkgPSBkb3Rjc3MubGVuZ3RoVG9QeChwWzBdKTtcclxuICAgICAgICAvL3RoaXMudXBkYXRlVmFsdWUoXCJ0cmFuc2xhdGVZXCIsIFtuZXcgQ3NzTGVuZ3RoKHkgKyBcInB4XCIpXS8qLCBbMSwwLDAsMCwwLDEsMCwwLDAsMCwxLDAsMCx5LDAsMV0qLyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwZW5kVHJhbnNmb3JtU3RyaW5nKFwidHJhbnNsYXRlWVwiLCBbbmV3IGNzc19sZW5ndGhfMS5kZWZhdWx0KHkpXSk7XHJcbiAgICB9XHJcbiAgICB0cmFuc2xhdGVaKHopIHtcclxuICAgICAgICAvL3ZhciB6ID0gZG90Y3NzLmxlbmd0aFRvUHgocFswXSk7XHJcbiAgICAgICAgLy90aGlzLnVwZGF0ZVZhbHVlKFwidHJhbnNsYXRlWlwiLCBbbmV3IENzc0xlbmd0aCh6ICsgXCJweFwiKV0vKiwgWzEsMCwwLDAsMCwxLDAsMCwwLDAsMSwwLDAsMCx6LDFdKi8pO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFwcGVuZFRyYW5zZm9ybVN0cmluZyhcInRyYW5zbGF0ZVpcIiwgW25ldyBjc3NfbGVuZ3RoXzEuZGVmYXVsdCh6KV0pO1xyXG4gICAgfVxyXG4gICAgc2NhbGUoeCwgeSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFwcGVuZFRyYW5zZm9ybVN0cmluZyhcInNjYWxlXCIsIFt4LCB5ID8/IDFdIC8qLCBbeCwwLDAsMCwwLHksMCwwLDAsMCwxLDAsMCwwLDAsMV0qLyk7XHJcbiAgICB9XHJcbiAgICBzY2FsZTNkKHgsIHksIHopIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hcHBlbmRUcmFuc2Zvcm1TdHJpbmcoXCJzY2FsZTNkXCIsIFt4LCB5LCB6XSAvKiwgW3BbMF0sMCwwLDAsMCxwWzFdLDAsMCwwLDAscFsyXSwwLDAsMCwwLDFdKi8pO1xyXG4gICAgfVxyXG4gICAgc2NhbGVYKHgpIHtcclxuICAgICAgICAvL3RoaXMudXBkYXRlVmFsdWUoXCJzY2FsZVhcIiwgcC8qLCBbcFswXSwwLDAsMCwwLDEsMCwwLDAsMCwxLDAsMCwwLDAsMV0qLyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwZW5kVHJhbnNmb3JtU3RyaW5nKFwic2NhbGVYXCIsIFt4XSk7XHJcbiAgICB9XHJcbiAgICBzY2FsZVkoeSkge1xyXG4gICAgICAgIC8vdGhpcy51cGRhdGVWYWx1ZShcInNjYWxlWVwiLCBwLyosIFsxLDAsMCwwLDAscFswXSwwLDAsMCwwLDEsMCwwLDAsMCwxXSovKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5hcHBlbmRUcmFuc2Zvcm1TdHJpbmcoXCJzY2FsZVlcIiwgW3ldKTtcclxuICAgIH1cclxuICAgIHNjYWxlWih6KSB7XHJcbiAgICAgICAgLy90aGlzLnVwZGF0ZVZhbHVlKFwic2NhbGVaXCIsIHAvKiwgWzEsMCwwLDAsMCwxLDAsMCwwLDAscFswXSwwLDAsMCwwLDFdKi8pO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFwcGVuZFRyYW5zZm9ybVN0cmluZyhcInNjYWxlWlwiLCBbel0pO1xyXG4gICAgfVxyXG4gICAgcm90YXRlKHgpIHtcclxuICAgICAgICAvLyB2YXIgYSA9IFV0aWwuYW5nbGVUb0RlZyh4KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5hcHBlbmRUcmFuc2Zvcm1TdHJpbmcoXCJyb3RhdGVcIiwgW25ldyBjc3NfYW5nbGVfMS5kZWZhdWx0KHgpXSAvKiwgW01hdGguY29zKGEpLE1hdGguc2luKGEpLDAsMCwtTWF0aC5zaW4oYXh4eCksTWF0aC5jb3MoYXh4eCksMCwwLDAsMCwxLDAsMCwwLDAsMV0qLyk7XHJcbiAgICB9XHJcbiAgICByb3RhdGUzZCh4LCB5LCB6LCBhKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwZW5kVHJhbnNmb3JtU3RyaW5nKFwicm90YXRlM2RcIiwgW3gsIHksIHosIG5ldyBjc3NfYW5nbGVfMS5kZWZhdWx0KGEpXSAvKixcclxuICAgICAgICAgICAgWzErQyooeCp4LTEpLFx0eipTK3gqeSpDLFx0XHQteSpTK3gqeipDLFx0XHQwLFxyXG4gICAgICAgICAgICAteipTK3gqeSpDLFx0XHQxK0MqKHkqeS0xKSxcdHgqUyt5KnoqQyxcdFx0MCxcclxuICAgICAgICAgICAgeSpTK3gqeipDLFx0XHQteCpTK3kqeipDLFx0XHQxK0MqKHoqei0xKSxcdDAsXHJcbiAgICAgICAgICAgIDAsXHRcdFx0XHQwLFx0XHRcdFx0MCxcdFx0XHRcdDFdKi8pO1xyXG4gICAgfVxyXG4gICAgLy8gTWFudWFsbHkgY3JlYXRlIHRoZSA0IHVuaXQgZnVuY3Rpb25zIGZvciByb3RhdGUgM2Qgc2luY2UgdGhlIGFyZyBzdHJ1Y3R1cmUgaXMgbWl4ZWQuXHJcbiAgICByb3RhdGUzZERlZyh4LCB5LCB6LCBhKSB7IHJldHVybiB0aGlzLnJvdGF0ZTNkKHgsIHksIHosIGEpOyB9XHJcbiAgICByb3RhdGUzZFJhZCh4LCB5LCB6LCBhKSB7IHJldHVybiB0aGlzLnJvdGF0ZTNkKHgsIHksIHosIGAke2F9cmFkYCk7IH1cclxuICAgIHJvdGF0ZTNkR3JhZCh4LCB5LCB6LCBhKSB7IHJldHVybiB0aGlzLnJvdGF0ZTNkKHgsIHksIHosIGAke2F9Z3JhZGApOyB9XHJcbiAgICByb3RhdGUzZFR1cm4oeCwgeSwgeiwgYSkgeyByZXR1cm4gdGhpcy5yb3RhdGUzZCh4LCB5LCB6LCBgJHthfXR1cm5gKTsgfVxyXG4gICAgcm90YXRlWCh4KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwZW5kVHJhbnNmb3JtU3RyaW5nKFwicm90YXRlWFwiLCBbbmV3IGNzc19hbmdsZV8xLmRlZmF1bHQoeCldIC8qLCBbMSwwLDAsMCwwLE1hdGguY29zKGF4eCksTWF0aC5zaW4oYXh4KSwwLDAsLU1hdGguc2luKGF4eCksTWF0aC5jb3MoYXh4KSwwLDAsMCwwLDFdKi8pO1xyXG4gICAgfVxyXG4gICAgcm90YXRlWSh5KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwZW5kVHJhbnNmb3JtU3RyaW5nKFwicm90YXRlWVwiLCBbbmV3IGNzc19hbmdsZV8xLmRlZmF1bHQoeSldKTtcclxuICAgIH1cclxuICAgIHJvdGF0ZVooeikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFwcGVuZFRyYW5zZm9ybVN0cmluZyhcInJvdGF0ZVpcIiwgW25ldyBjc3NfYW5nbGVfMS5kZWZhdWx0KHopXSk7XHJcbiAgICB9XHJcbiAgICBza2V3KHgsIHkpIHtcclxuICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PSAxXHJcbiAgICAgICAgICAgID8gdGhpcy5hcHBlbmRUcmFuc2Zvcm1TdHJpbmcoXCJza2V3XCIsIFtuZXcgY3NzX2FuZ2xlXzEuZGVmYXVsdCh4KV0gLyosIFsxLDAsMCwwLE1hdGgudGFuKGF4eHh4eCksMSwwLDAsMCwwLDEsMCwwLDAsMCwxXSovKVxyXG4gICAgICAgICAgICA6IHRoaXMuYXBwZW5kVHJhbnNmb3JtU3RyaW5nKFwic2tld1wiLCBbbmV3IGNzc19hbmdsZV8xLmRlZmF1bHQoeCksIG5ldyBjc3NfYW5nbGVfMS5kZWZhdWx0KHkpXSAvKiwgWzEsTWF0aC50YW4oYXh4eHkpLDAsMCxNYXRoLnRhbihheHh4eCksMSwwLDAsMCwwLDEsMCwwLDAsMCwxXSovKTtcclxuICAgIH1cclxuICAgIHNrZXdYKHgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hcHBlbmRUcmFuc2Zvcm1TdHJpbmcoXCJza2V3WFwiLCBbbmV3IGNzc19hbmdsZV8xLmRlZmF1bHQoeCldKTtcclxuICAgIH1cclxuICAgIHNrZXdZKHkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hcHBlbmRUcmFuc2Zvcm1TdHJpbmcoXCJza2V3WVwiLCBbbmV3IGNzc19hbmdsZV8xLmRlZmF1bHQoeSldKTtcclxuICAgIH1cclxuICAgIHBlcnNwZWN0aXZlKGQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hcHBlbmRUcmFuc2Zvcm1TdHJpbmcoXCJwZXJzcGVjdGl2ZVwiLCBbbmV3IGNzc19sZW5ndGhfMS5kZWZhdWx0KGQpXSAvKiwgWzEsMCwwLDAsMCwxLDAsMCwwLDAsMSwwLDAsMCxkb3Rjc3MuZm9ybWF0TnVtYmVyVmFsdWUoLTEgLyBkKSwxXSovKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLmRlZmF1bHQgPSBDc3NUcmFuc2Zvcm07XHJcbi8vIEV4dGVuZCB0aGUgYWJvdmUgd2l0aCBzcGVjaWFsIGxlbmd0aCBhbmQgZGVncmVlIGZ1bmN0aW9ucy5cclxuY29uc3QgbGVuZ3RoRnVuY3MgPSBcInRyYW5zbGF0ZXx0cmFuc2xhdGUzZHx0cmFuc2xhdGVYfHRyYW5zbGF0ZVl8dHJhbnNsYXRlWnxwZXJzcGVjdGl2ZVwiLnNwbGl0KFwifFwiKTtcclxuY29uc3QgYW5nbGVGdW5jcyA9IFwicm90YXRlfHJvdGF0ZVh8cm90YXRlWXxyb3RhdGVafHNrZXd8c2tld1h8c2tld1lcIi5zcGxpdChcInxcIik7XHJcbmZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoRnVuY3MubGVuZ3RoOyBpKyspIHtcclxuICAgIGxldCBGID0gbGVuZ3RoRnVuY3NbaV07XHJcbiAgICBmb3IgKGxldCB1ID0gMDsgdSA8IHVuaXRfZnVuY3Rpb25fdGFibGVzXzEuQWxsTGVuZ3RoVW5pdHMubGVuZ3RoOyB1KyspIHtcclxuICAgICAgICBsZXQgdXUgPSB1bml0X2Z1bmN0aW9uX3RhYmxlc18xLkFsbExlbmd0aFVuaXRzW3VdO1xyXG4gICAgICAgIENzc1RyYW5zZm9ybS5wcm90b3R5cGVbRiArICh1dS5qc05hbWUgfHwgdXUudW5pdCldID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgIGFyZ3VtZW50c1tpXSA9IGFyZ3VtZW50c1tpXSArIHV1LnVuaXQudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgcmV0dXJuIENzc1RyYW5zZm9ybS5wcm90b3R5cGVbRl0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcbmZvciAobGV0IGkgPSAwOyBpIDwgYW5nbGVGdW5jcy5sZW5ndGg7IGkrKykge1xyXG4gICAgbGV0IEYgPSBhbmdsZUZ1bmNzW2ldO1xyXG4gICAgZm9yIChsZXQgdSA9IDA7IHUgPCB1bml0X2Z1bmN0aW9uX3RhYmxlc18xLkFsbEFuZ2xlVW5pdHMubGVuZ3RoOyB1KyspIHtcclxuICAgICAgICBsZXQgdXUgPSB1bml0X2Z1bmN0aW9uX3RhYmxlc18xLkFsbEFuZ2xlVW5pdHNbdV07XHJcbiAgICAgICAgQ3NzVHJhbnNmb3JtLnByb3RvdHlwZVtGICsgKHV1LnVuaXQpXSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICBhcmd1bWVudHNbaV0gPSBhcmd1bWVudHNbaV0gKyB1dS51bml0LnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBDc3NUcmFuc2Zvcm0ucHJvdG90eXBlW0ZdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jc3MtdHJhbnNmb3JtLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IGNzc19kYXRhX3R5cGVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9jc3MtZGF0YS10eXBlXCIpKTtcclxuY2xhc3MgQ3NzVW5rbm93biBleHRlbmRzIGNzc19kYXRhX3R5cGVfMS5kZWZhdWx0IHtcclxuICAgIGNvbnN0cnVjdG9yKHZhbHVlKSB7XHJcbiAgICAgICAgc3VwZXIoXCJ1bmtub3duXCIpO1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuZGVmYXVsdCA9IENzc1Vua25vd247XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNzcy11bmtub3duLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IGNzc19kYXRhX3R5cGVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9jc3MtZGF0YS10eXBlXCIpKTtcclxuY2xhc3MgQ3NzVXJsIGV4dGVuZHMgY3NzX2RhdGFfdHlwZV8xLmRlZmF1bHQge1xyXG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcclxuICAgICAgICBzdXBlcihcInVybFwiKTtcclxuICAgICAgICB0aGlzLnVybCA9IG51bGw7XHJcbiAgICAgICAgaWYgKCF2YWx1ZSB8fCB2YWx1ZS5sZW5ndGggPT0gMCB8fCAodmFsdWUubGVuZ3RoID09IDEgJiYgdmFsdWVbMF0gPT0gXCJcIiB8fCB2YWx1ZVswXSA9PSBcIm5vbmVcIiB8fCB2YWx1ZVswXSA9PSBcImluaXRpYWxcIiB8fCB2YWx1ZVswXSA9PSBcImluaGVyaXRcIikpIHtcclxuICAgICAgICAgICAgdGhpcy51cmwgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy51cmwgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRVUkwgPSBcIlwiO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlW2ldLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihcInVybFwiKSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB1cmwgPSB2YWx1ZVtpXS5zdWJzdHJpbmcodmFsdWVbaV0uaW5kZXhPZihcIihcIiksIHZhbHVlW2ldLmxhc3RJbmRleE9mKFwiKVwiKSkudHJpbSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgodXJsLmluZGV4T2YoXCJcXFwiXCIpICYmIHVybC5sYXN0SW5kZXhPZihcIlxcXCJcIikgPT0gdXJsLmxlbmd0aCAtIDEpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICh1cmwuaW5kZXhPZihcIidcIikgJiYgdXJsLmxhc3RJbmRleE9mKFwiJ1wiKSA9PSB1cmwubGVuZ3RoIC0gMSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gdXJsLnN1YnN0cmluZygxLCB1cmwubGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXJsLnB1c2godXJsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXJsLnB1c2godmFsdWVbaV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnVybClcclxuICAgICAgICAgICAgcmV0dXJuIFwibm9uZVwiO1xyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgcmV0ID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy51cmwubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHJldC5wdXNoKFwidXJsKFxcXCJcIiArIHRoaXMudXJsW2ldICsgXCJcXFwiKVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmV0LmpvaW4oXCIsIFwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5kZWZhdWx0ID0gQ3NzVXJsO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jc3MtdXJsLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==